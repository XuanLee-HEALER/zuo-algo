# zuo-algo

## ⭐️⭐️⭐️[**左神b站主页，是本人**](https://space.bilibili.com/8888480)⭐️⭐️⭐️

跟着左程云学算法

个人总结：理论性不强，适合小白入门，课程质量非常高，属于练习使你变强的一类课

## 二进制

[code](./examples/1-bit.rs)

### 二进制表示数字

每一位（bit）表示`0`和`1`，计算一个二进制数的十进制表示就是从低位*2的0次方累加的到结果

比如`1001`，计算十进制数为`1*2^0+0*2^1+0*2^2+1*2^3=9`

### 二进制表示非负数和负数

一个n位的二进制数表示的无符号数字范围是`2^n`个

一个n位的二进制数表示的有符号数字范围是`-2^(n-1)~2^(n-1)-1`。每个数字的首位表示符号，0为正、1为负

一个正数的二进制数的负数如何计算？

将所有位减1再取反。`5`的二进制表示`0101`，它的负数计算过程为

1. `0101` -> `0100`
2. `1010` -> `1011`

`1001`就是`-5`的二进制表示，相反，根据一个二进制数来判断它是负几，则将整个数取反再加1

1. `1011` -> `0100`
2. `0100` -> `0101`

由于最后的`0101`是5，所以`1011`表示`-5`

### 二进制对正负数的表示原因

这种表示方式可以在负数和非负数以任何出现顺序做加法的同时不需要加分支判断即可进行，例如`-5+2`

1. `1011+0010`
2. `1101`
3. `1101` -> `0010`
4. `0010` -> `0011`

`0100`是3，结果正确

> **计算机不处理数字计算的溢出情况，需要程序员自己保证**

由于没有分支判断，加法的计算速度很快，这样会导致其它的计算`-`/`*`/`/`的计算性能提高，因为这些计算都是基于加法实现的

### 位计算

位计算没有短路计算方式，逻辑计算存在短路计算

#### `|`

当存在一个位为`1`时，计算结果为`1`，否则为`0`

#### `&`

当存在至少一个位为`0`时，计算结果为`0`，否则为`1`

#### `^`

当两个位相同时为`0`，否则为`1`

#### `<</>>/<<</>>>`

带符号左移/右移，无符号左移/右移（即右移用0补位）

对于**非负数**，左移n位等同于`*2^(n)`，右移n位等同于`/2^(n)`

### 取反

`~`是取反符号，每个数的正反都等于对它取反再加1

### 打印二进制数

要打印二进制的某一位，可以将其它位与`0`做`&`操作，要打印的位与`1`做`&`操作，如果剩下的数不为0，那么打印`1`，否则打印`0`

## 三种简单排序

[code](./examples/2-simple-sort.rs)

⚠️注意边界条件，数组元素如果是`0`或`1`个，那么本身有序无需进算法步骤

### 选择排序

一句话总结：将i～n-1位置上的最小值找到，然后与i位置的数交换位置，直到`i==n-1`

### 冒泡排序

一句话总结：在0~n-1位置范围内，通过两两比较将最大值移到n-1位置上，然后缩短范围0～n-2继续

### 插入排序

一句话总结：每次都保证前i位有序，将i+1位认为无序，然后和前i位倒序比较，如果无序则交换顺序

最好情况（数列有序）时间复杂度为`O(N)`

## 对数器

[code](./examples/3-test-method.rs)

对数器是一种验证算法的方法，它的实现步骤大概为

1. 对于一个要解决的问题A
2. 实现一个不考虑复杂度的暴力解法S1，最简单的思路基本都是正确的，要保证这里正确
3. 实现几个考虑复杂度的优雅解法S2、S3...
4. 开始创建测试用例，即利用随机数生成测试数据
5. 使用生成的测试数据对几个解法（方法）进行测试，小数据量测试
6. 如果小数据量没有问题，那么逐渐增加数据，直到暴力解法达到基本无法计算的程度，如果还没有问题则基本确定后续的最优解是正确的
7. 如果过程中出现了问题，那么减少数据量，打印/debug方法，开始找出错误，这个过程可以通过打印原始测试数据，对比不同方法的结果来判断

## 二分搜索

[code](./examples/4-binary-search.rs)

### 有序数列

1. 在有序数列中找到一个指定数字，如果存在返回它的索引，否则返回`-1`
2. 找到一个大于数字`n`的最靠左的数字
3. 找到一个小于数字`n`的最靠右的数字

解决方法：一个长度为n的数列的开头总是`0`，最后一个位置是`n-1`，那么中点是`0+(n-1)/2`，另外一种计算中点的方式是`0+((n-1-0)>>1)`，这样写的作用是防止两个索引位置直接相加之后会超过索引值类型的最大值造成溢出

### 无序数列

峰值问题

前提，一个数列中，峰值的含义是，在位置i上，它的值大于左右两边的值，且相邻数不允许相同，认为在数列左端和右端的数的值为最小

找到数列中任意一个峰值的位置，如果没有则返回`-1`

按照题中的指示，先判断第一个数和最后一个数是否为峰值，如果两个数都不是峰值，那么可以判断峰值一定在中间，此时认为二分搜索的起点为`1`，终点为`n-2`，判断中点是否为峰值，如果不是，如果小于左边的数，那么终点变为左移一位的数继续，否则起点变成右移一位的数继续

启发：如果可以确定问题范围缩小的规律，就可以使用“二分”解决同类问题

### 二分搜索的时间复杂度

二分搜索的时间复杂度是`O(logN)`，N表示数列的长度，因为每一次循环会将搜索范围缩小一半，所以问题的总长度就是2的搜索次数的次方，例如一个长度为`i32.Max`的数列，它的长度为`2^31-1`，所以最慢31次搜索就可以解决问题

## 时间复杂度和空间复杂度

常数操作：常数时间内操作，和操作数大小没有关系。例如数字运算操作，因为位数固定，所以同类型运算消耗的时间差不多。例如数组寻址，由于是计算索引获取数组数值，所以读取任意位置元素时间差不多。哈希函数的访问也是常数操作

非常数操作：例如链表，由于链表在内存中不是连续存放，所以根据节点数量不同，获取不同位置的节点也是不同的

### 时间复杂度

表示运行时间和数据量的关系

使用问题规模来计算，将每一次计算的数据量/规模相加，然后去掉非最高阶的式子，留下的最高阶式子去掉常数项，就是`O(x^n)`的复杂度

常数操作是`O(1)`的时间复杂度

和数据量相关的变量的阶数对于运行时间的意义最大，低阶项和常数项相比都不重要

对于插入排序，如果是最差情况（倒序排列），那么时间复杂度就是`O(n^2)`，但是最好情况时间复杂度变成了`O(n)`，要确定时间复杂度需要用最差情况

严格**固定流程**（没有随机性）的算法必须评估在最差情况下的性能

对于随机流程的算法，即每一个运算单元可能有不确定性的执行次数，那么最差情况就是算法无法执行完成，即随机性无法满足算法向下执行的概率。所以需要使用平均复杂度或者概率上的期望复杂度来评价

### 空间复杂度

额外空间复杂度

入参和出参的空间不占空间复杂度计算项。算法流程中为了支持实现开辟的新的空间就是空间复杂度。如果没有利用额外空间，那么空间复杂度为`O(1)`

### 最优解

各个方法中哪个方法的时间复杂度更低阶就更好，这种方法下使用更低的空间复杂度

### 复杂度的均摊

以动态数组为例，如果动态数组每次扩容都是加倍，那么在向长度为1动态数组插入n个数时，在插入第2*n个数时问题规模变为2*n+1，那么插入8个数，就是`1+1+2+1+4+1+1`，小于`2*8`，推知插入n个数，扩容的时间复杂度也小于2n，那么总的时间复杂度就是说`O(n)`，均摊到n次插入数据，扩容对于插入的时间复杂度就是`O(1)`

均摊时间复杂度主要是为了好估计算法的整体时间复杂度

### 估计复杂度的误区

- ⚠️估计时间复杂度不能简单根据循环的个数/代码结构判断量级
  - 一个循环完成的冒泡排序
  - 两个循环达成的`O(nlogn)`的复杂度，`for i = 0; i < N; i++ {for j = i; j < N; j+=i}`。`1+1/2+1/3+...+1/n`的结果收敛于`O(logn)`（调和级数）

### 时间复杂度比较

`O(1)` `O(logN)` `O(N)` `O(N*logN)` `O(N^2)` `O(N^3)` ... `O(N^k)` `O(2^N)` `O(k^N)` `O(N!)`

## 算法和数据结构分类

- 硬计算类算法：精确求解
- 软计算类算法：最优解，注重逼近解决问题

- （物理）连续结构：在底层是连续存储的，只需要知道首地址和偏移量就能直接查找节点。例如数组、一个单独数字（`i32`）
- （物理）跳转结构：在底层是不连续存储的，需要保存不同节点的地址才能查找。例如链表、树、图

任何一种数据结构都是通过这两种结构组合起来

## 单双链表及其反转，堆栈诠释

[code](./examples/5-linked-list.rs)

### 按值/引用传递参数

Java除了基本类型以外都是按引用传递，但无论是按值还是按引用传递，都是对原类型的拷贝，如果是基本类型就直接拷贝值传递，而引用类型是拷贝了引用（内存地址）本身然后传递。引用类型就是值在堆上保存，栈上只保存内存地址，传递也只用地址传递

### 单链表

内存中定义的结构，一个结构，它包含一个值和指向下一个节点的指针。最后一个节点的下一个节点指向空（`null`）

```rust
struct ListNode {
    val: i32,
    next: Option<Box<ListNode>>,
}
```

### 双链表

和单链表类似，只不过除了指向下一个节点的指针还有指向上一个节点的指针

```rust
struct DoubleListNode {
    val: i32,
    last: Option<Box<DoubleListNode>>,
    next: Option<Box<DoubleListNode>>,
}
```

### 链表的反转

函数签名`fn reverse(head ListNode) -> ListNode`

## 合并两个有序链表

[code](./examples/6-merge-sorted-list.rs)

问题描述：有两个有序链表，合并两个链表为一个有序链表

解法：边界条件是两个链表任意为空则返回另一个链表，然后先找到最小的节点作为最终返回的结果，然后两个遍历节点分别为头节点的下一个和另一个链表的头节点，开始比较两个遍历节点，并使用一个头节点的引用来修改指向下一个节点的指针，等到两个遍历节点任一为空时，将剩余的节点拼到引用的指向下一个节点的指针上即完成算法

⚠️rust中，由于不能在一个节点上同时存在可变引用和不可变引用，所以利用一个dummy节点作为头节点，使用它的一个可变引用来逐次拼接两个链表中的最小值，最终拼接剩余的节点，然后范围dummy节点指向的下一个节点即可完成算法

## 两个链表相加

[code](./examples/7-add-two-list.rs)

问题描述：两个链表表示两个数字，链表头从个位开始，结果是一个新链表

解法：两个遍历指针，如果非空就是本值，否则为0，每次相加，注意保存进位，每次生成一个新节点保存到最终结果中

## 划分链表

[code](./examples/8-divide-list.rs)

问题描述：给定一个链表，再给一个特定值x，将链表重排，小于x在左，大于x在右，但是不能改变原链表元素的相对次序

解法：四个裸指针初始为null，分别表示小于子链表的头尾和大于等于子链表的头尾，然后开始遍历链表，如果当前节点小于x，那么小头赋值为当前节点，小头尾指向这一节点，如果非首次则小头尾的下一个指针指向这个节点，更新小头尾节点。对于大头相同逻辑。最后要判断，如果小头头为空，那么直接返回大头头，否则返回小头尾拼接大头头后的小头头

## 队列和栈

[code](./examples/9-queue-stack.rs)

队列和栈是一种逻辑结构，物理实现可以使用链表或者数组

- 队列：先进先出（FIFO），新来元素从尾部进，从头部出
- 栈：后进先出（LIFO）

队列实现

用链表实现，一条单链表就可以实现队列，保持两个指针，头指针总是指向头节点，尾指针指向最近被插入的数据，当移除数据的时候，头指针返回节点前移动到下一个节点

用数组实现，做题过程中元素个数确定，可以初始化一个长度为N的数组，头尾指针初始化为`(0, 0)`，队列的范围是`[0, n)`，当`l < r`时，认为队列非空，否则队列为空

```java
int peek()
int tail()
void offer()
int poll()
int size()
bool empty()
```

栈的实现

用数组实现，一个指针记录栈顶元素即可

```java
bool empty()
void push()
int pop()
int peek()
int size()
```

### 环形队列

数组实现的队列，被释放的元素（位置）可以重复利用，只要同时在队列里的元素不超过整个数组大小，就可以无限利用

不使用头尾指针来控制循环队列，而是使用一个size来控制当前的队列长度

## 栈和队列相互实现

[code](./examples/10-queue-stack-converse.rs)

### 用栈实现一个队列

问题描述：只有标准栈，实现一个队列结构

解法：使用两个栈，一个in栈，一个out栈。当取数时，只有out栈空时，把in栈的内容全部导入out栈，每次导入数据的时候需要将in栈清空

⚠️时间复杂度，对于栈实现的队列，对元素的每个操作的均摊时间复杂度是`O(1)`，因为每个元素在这个数据结构中的生命周期就是in栈的进出和out栈的进出

### 用队列实现栈

问题描述：只有标准队列，实现一个栈结构

解法：每次队列进一个元素，记录当这个元素弹出时，它之前有几个元素需要弹出再插入队列

假设队列为空，先插入1，则为1，然后插入2，那么1要先出再进变为2<-1，对于每个新进的元素，已有的元素都已经是倒序，所以只需要处理当前元素，将其放到开头即可

⚠️时间复杂度，插入元素操作是`O(N)`，其余方法是`O(1)`

## 最小栈

问题描述：设计一个栈，额外提供一个方法`getMin()`来在常数时间内获取栈中的最小值

解法：使用两个栈，数据栈之外提供给一个最小栈，如果新入元素是第一个元素或者是最小的元素，那么在两个栈同步压入元素，否则数据栈压数据，最小栈压栈顶

空间换时间

## 双端队列

定义：在队列两端都可以进出元素，且进出顺序为FIFO

实现：

- 链表实现：使用双向链表可以直接实现双端队列，只需要保证链表的长度为指定的固定值即可
- 数组实现：固定数组实现一个双端队列，头尾索引总是指向头尾元素，使用`size`来确定当前队列的总元素个数，尾部索引是`+1`后移，头部索引是`-1`前移，当达到最大/小值时要回到数组的头/尾索引继续。⚠️两个头尾索引最开始并没有指向某个值，所以插入第一个元素的时候，这两个索引不能变化，即两个索引总是指向头尾元素

⚠️这道题主要问题是对边界条件的处理

另一种解法：还可以从头尾各自插入，这样计算索引可以省去对边界条件的判断，单线程内速度更快（leetcode无区别）

## 二叉树及其三种序的遍历

简单定义：一个节点只有左右两个节点的树

- 先序遍历：中->左->右
- 中序遍历：左->中->右
- 后序遍历：左->右->中

遍历的递归序，可以派生出三种序的遍历顺序

```java
// 递归基本样子，用来理解递归序
public static void f(TreeNode head) {
  if (head == null) {
    return;
  }
  // 1
  f(head.left);
  // 2
  f(head.right);
  // 3
}
```

递归序就是每一个非空节点，在这个函数中都会有`1/2/3`个位置执行当前节点的操作，不同的遍历序就是在不同的位置去打印了节点

## 二叉树的非递归遍历及其时间复杂度

[code](./examples/14-binary-tree-noniter.rs)

用栈实现二叉树的先序遍历：先将头节点压入栈中，然后重复过程，弹出栈顶元素，然后将该节点的右子树压入栈中，再将该节点的左子树压入栈中，这是因为要先弹出左子树，再弹出右子树

用栈实现二叉树中序遍历：先将头节点压入栈中，然后将它的左边界（它自己的左子树节点和后续所有的左子树节点）压入栈中，然后重复过程，弹出一个节点之后，将右子树及其左边界压入栈中。弹出过程就是左中右的中序遍历

用栈实现二叉树后序遍历（两个栈）：由于后序遍历是左右中，所以利用先序遍历改为中右左，然后利用另一个栈保存所有遍历元素，最后再依次弹出就是正确结果

用栈实现二叉树后序遍历（一个栈）：记录当前弹出的节点，也就是下一个要弹出的节点的上一个弹出节点，第一次压入头节点，如果左右子树未处理，那么压入左子树，然后看左子树，如果左右子树为空，那么弹出并且记录此为弹出节点，开始继续查看栈顶节点，因为左子树处理过，所以压入右子树处理

时间复杂度

- 递归做法：由于每个节点在递归过程中会被访问三次，所以是`O(N)`
- 非递归做法：每个节点入栈次数可能是多次（引用），但是属于有限次数，时间复杂度也是`O(N)`

空间复杂度

都是`O(H)`，H是树的高度，因为无论是递归还是非递归（栈），它们的最大占用空间都是树的最高高度，对于递归来说，一条边界递归完成后的空间可以被回收利用，对于栈的空间也是可以在弹出之后循环利用

### Rust实现一个栈的后序遍历二叉树

![image](./picture/same-node.png)

在上图中的情况，如果使用`Rc::eq()`，会使得值相同的左右叶子节点被认为是同一个节点，所以在比较上一个弹出的节点和当前节点的左右子节点时应该使用`Rc::ptr_eq()`方法

## 算法笔试中的输入输出处理

### 填函数风格

给定一个问题，然后提供方法/类的签名（类名、方法名、参数类型/个数），只需要把解决问题的逻辑代码填充好，提交即可。后台会有两部分（测试数据和答案），它会根据测试数据生成指定类型的参数，然后调用写好的函数，最后对比答案。这种形式比较简单清晰

### ACM风格

判题后台依旧是同样的结构，但是它会要求考生自己从标准输入读取测试数据，并且在代码中将结果打印到标准输出。这里推荐使用`BufferReader`、`StreamTokenizer`、`PrintWriter`来对标准输入、输出做一层包装，目的是减少IO次数，不同的语言使用对应的API。`StreamTokenizer`可以从一个输入流中一次获取一个非空字符

⚠️除答案以外不要随便往标准输出打印东西

### 临时动态空间和全局静态空间

每个测试用例都需要分配的临时数组，当知道最大的数据规模后，可以只创建一个静态的最大空间（数组），然后每个测试用例都复用这个空间，由于后台只算累积的内存使用量，这种方式可以跳过每次动态创建内存可能会碰到的内存使用量限制

### 按行读

对于一些问题，它不告诉数据规模，只说每一个问题的数据是一行，以x分隔符划分，此时应该一次读取一行，然后自行分隔内容，再组装数据

## 递归和master公式

递归调用图：即表示为一个递归调用树，根节点就是第一次函数调用，然后分解为多次递归函数调用，每个调用可以继续往下分，区别在于它们的参数会变化，当递归函数计算完成会返回给上一层函数，任何复杂递归都可以用这种调用图来表示

系统栈表示：系统栈，函数第一次调用时，在内存上的函数声明（参数）、局部变量会在等待递归函数调用时被压入系统栈，然后开始进行递归调用，如果递归调用会返回，那么返回值会给栈顶元素，此时系统会在内存中重建上下文，并且更新递归调用的返回值进行后续的计算

> 任何递归函数都可以改成非递归函数。自己做一个栈，模拟递归过程

递归改成非递归的必要性

- 工程上一定改，因为系统栈小，代价高，所以可以在内存上自建栈实现同样的逻辑。除非问题规模可以保证无论数据量再多递归深度也不高就可以使用，**同一层的递归空间可以复用**
- 算法题能通过就不用改

### master公式

所有子问题规模相同的递归才能用master公式：`T(N) = a*T(N/b) + O(N^c)`，`a`、`b`、`c`都是常数。其中的时间复杂度是除了递归调用以外的程序的时间复杂度

对于可以用master公式表示的算法可以直接计算时间复杂度

- `logb(a)`如果大于`c`，那么时间复杂度为`O(N^(logb(a)))`
- `logb(a)`如果小于`c`，那么时间复杂度为`O(N^c)`
- `logb(a)`如果等于`c`，那么时间复杂度为`O(N^c*logN)`
- 补充，如果使用master公式表示算法的时间消耗为`T(N) = 2*T(N/2) + O(N*logN)`，那么时间复杂度为`O(N*(logN)^2)`

## 归并排序

[code1](./examples/15-merge-sort.rs)

[code2](./examples/15-merge-sort-lg.rs)

归并排序的基本逻辑是，对于一个无序数组，先对左边一半数据排好序，然后右边一半数据排好序，最后把两个有序子数组按照数据大小进行合并，排序完成

合并（merge），左右有序子数组，谁小拷贝谁，遍历完两侧数组元素，放到辅助数组中，然后将结果更新回原数组

时间复杂度：`O(N*logN)`，空间复杂度：`O(N)`（需要辅助数组）

归并排序时间复杂度低的本质原因是没有浪费比较行为的结果，每次比较/归并都会使数组更有序，而`O(N^2)`的排序方法中有大量的比较结果都被抛弃掉了

⚠️使空间复杂度降低为`O(1)`的归并排序，即不借用辅助数组的方式没必要学习，因为这种方式会让时间复杂度降低为`O(N^2)`

### 递归

### 非递归

利用步长

## 归并分治

[code1](./examples/16-merge.rs)

[code2](./examples/16-merge-minsum.rs)

原理

1. 考虑一个问题在大范围上的答案，是否可以转化为左边的答案和右边的答案和左边跨右边的答案的累加
2. 在计算跨左右的答案是，如果左右部分的答案是有序的，是否可以获取计算的便利性
3. 如果以上两点成立，那么这个问题大概率可以通过归并分治解决
4. 求解答案的过程中要加入归并排序的过程，因为在计算跨左右部分的答案是会用到

### 例题

小和问题：有一列数，小和等于每个数左边小于它的数的和，求这一列数的小和

每一列数的小和等于左半部分的小和+右半部分的小和+左半部分相对于右半部分的小和，所以可以利用归并分治的方法求解。因为每个数在小和出现的次数都取决于它相对于右边的数是更小的次数，所以左半部分的内容需要计算所有小于次数，而右半部分只需要计算自己的次数

如果在计算跨左右部分的小和时左右两部分数组是有序的，那么在`O(N)`的时间复杂度内可以计算完成，使用两个指针指向左右两部分的头部，那么左指针小于右指针一次，就会累加小和右部分的总数次，依次遍历后得到左边部分的跨左右小和结果

在实现过程中只要在每次计算完跨部分小和之后再执行归并排序过程就可以

### 补充

1. 一些用归并分治解决的问题，也可以用树状数组、线段树来解决，时间复杂度也是最优
2. 也可以解决较难的问题，例如空间中任何两点间的最短距离
3. “整块分治”

⚠️数据结构和算法中的思想传统

## 随机快速排序

[code](./examples/17-rand-quick-sort.rs)

### 经典随机快速排序流程

在一个数列中随机选取一个数，然后将整个数列中`<=`这个数的所有数移动到左边，大于这个数的所有数移动到右边，然后将这个数字移动到`<=`这个数的所有数的最右边，此时这个数列中存在一个有序的数（即选中的这个数），然后以这个数的位置为界，对前后两个子数列重复此过程

### 荷兰国旗优化过程

随机选出的某个数字在分组过程中，是可以统一处理的，即`<`这个数的在左，`>`这个数的在右，中间全部都是这个数，那么在一次分组过程中，同样的`O(N)`时间复杂度可以处理完更多的数字

### 快速排序的时间复杂度和空间复杂度

#### 选择固定位置的数字

最差情况：每次只能排好首位或者末位的数字，此时快排时间复杂度退化为`O(N^2)`，因为每个数字都需要和所有其他数字比较一遍，并且问题范围仅缩小一个，空间复杂度为`O(N)`，即递归深度为`N`

最好情况：每次都能选中处于有序数列中点的位置，那么此时可以利用master公式`T(N) = 2*T(N/2) + O(N)`，即时间复杂度为`O(N*logN)`，空间复杂度为`O(logN)`，因为这种情况代表每次递归都可以平分问题范围，即递归深度为`logN`，那么空间复杂度就是利用的栈的深度

#### 使用随机选择的数字

⚠️如[时间复杂度](#时间复杂度)部分的内容，如果一个算法中，随机过程会直接影响算法过程，那么估计时间复杂度应该使用随机的数学期望计算

结论：使用随机数作为分界点的快速排序的时间复杂度为`O(N*logN)`，空间复杂度为`O(logN)`

## 随机选择算法

[code](./examples/18-rand-select.rs)

问题描述：求无序数组中第x大/小的数，要求时间复杂度为`O(N)`，空间复杂度为`O(1)`，还有可能是不选择第x个，而是直接回到那个最大/小值是谁

解题：使用随机快排的荷兰国旗优化，将问题中的求第x大转化为求有序数列的第`len(arr)-x`位置的值即可，那么随机选择数然后划分三个区间，如果区间对则返回这个数，否则从左边或右边重复此过程

时间复杂度：最坏为`O(N^2)`，因为可能永远选择的是最远的数字，此时选一个数要遍历一次全部数组。最好为`O(N)`，即每次要么直接选中这个数，要么选中的是排在中间的数，此时会减少一半问题范围，那么时间复杂度为`N+1/2N+...`，最终收敛于`O(N)`的时间复杂度，`N`是遍历的内容

BFPRT算法可以在`O(N)`时间复杂度和`O(logN)`的空间复杂度实现在无随机选择的前提下完成这个题目

BFPRT算法描述

1. 选择一个常数c，将无序数列划分为N/c组
2. 在每组中找到中位数（由于是常数个数，所以排序时间复杂度为`O(1)`，所有组的和为`O(N)`）
3. 在所有中位数上递归调用BFPRT找中位数（时间复杂度为`T(N/c)`），此时结果为主元（*pivot*）
4. 使用主元将数组分为两部分，如果主元位置对，则返回
5. 或者在较小或较大的部分上递归调用BFPRT算法

时间复杂度为`T(N) = T(N/c) + T((c-2)/N*(c-1)) + O(N)`，计算得到时间复杂度为`O(N)`

## 堆结构和堆排序

### 完全二叉树和数组前缀的对应关系

完全二叉树（简单定义）：每个父节点都有两个子节点，树的每一层子节点满了之后才会在下一层插入节点

完全二叉树和数组前缀的对应关系：从数组的起始位置开始表示树的根节点，有以下计算规则

- 任意节点（数组索引）的父节点位置计算：`P(i) = (i - 1) / 2`
- 任意节点的左孩子位置计算：`LC(i) = 2 * i + 1`
- 任意节点的右孩子位置计算：`LC(i) = 2 * i + 2`

使用一个额外变量`size`来控制二叉树的节点数量，而不是直接使用数组的长度

### 堆结构

堆是一种规定了组织结构的完全二叉树，包括大根堆和小根堆，以下以大根堆为例

大根堆：在树的任意子结构中，根节点都是子结构的最大值

核心API

1. `heap_insert([]int, idx int)`：向堆中插入一个节点，默认在数组尾，需要重复和其父节点比较，如果大于父节点则和父节点交换，直到位置稳定
2. `heapify([]int, idx int, size int)`：改变堆中的一个节点，如果它在以它作为根节点的子结构中不是最大值，则需要和两个孩子节点比较，如果比更大的孩子节点小则需要交换位置，否则不动

#### 时间复杂度计算

堆的两个操作的时间复杂度都是`O(logN)`，因为节点的操作数量只跟树的高度有关，而树的高度和节点数量的关系是`h=logN`，空间复杂度为`O(1)`，因为不需要借助额外空间

### 堆排序

经典堆排序：对于一个无序数组，先将其建立为一个大根堆，然后将数组头和数组尾替换位置，然后堆大小减小，重复这个过程直到数组有序

建立堆的方式

- 从顶到底，即认为堆size为0，然后逐个添加节点，时间复杂度为`O(N*logN)`，因为时间为`log1+2*log2+3*log3+...+N*logN`，最终收敛于`O(N*logN)`
- 从底到顶，即认为堆size为数组长度，从后往前对数执行堆化操作，此时时间复杂度为`O(N)`，因为时间是`1/2*N*1+1/4*N*2+1/8*N*3+...+1/2^h*N*h`，最终收敛于`O(N)`

堆排序在建立好堆之后的排序（堆化）时间复杂度是`O(N*logN)`

#### 常量增倍计算时间复杂度

一般的时间复杂度的结果可以通过计算消耗时间数列的累加和得到，如果不知道计算公式可以使用常量增倍法。因为时间复杂度不会随着问题规模扩大常量倍数改变，所以如果单倍问题规模的时间复杂度上限和多倍规模的时间复杂度下限相同，那么这个上下限就是整个算法的时间复杂度

对于建堆来说，长度为`N`的数列，时间复杂度为`logN+log(N-1)+log`，则它的时间复杂度上限是`N*logN`，如果长度变为`2N`，那么它的时间复杂度至少也是`N*logN`，所以它的时间复杂度为`O(N*logN)`

求一个`n*m`的矩阵中有多少子矩阵，一般分析方法是任取两点可能构成的矩阵数，即`n*m*n*m`。由于两个点构成的矩形至少会重合四次，所以它们的时间复杂度上限为`O(n^2*m^2)`，如果将这个矩阵扩大4倍，则任取两点构成唯一矩形的时间复杂度也是`n*m*n*m`，因为将矩阵等分为四部分，要使矩形唯一，只能任选斜线两部分的点，它们的可能性就是`n*m*n*m`，那么时间复杂度下限就是`O(n^2*m^2)`，此时解决这个问题的时间复杂度就是`O(n^2*m^2)`

## 哈希表、有序表和比较器的用法

### 哈希表

哈希表可以认为是一个集合，**查询/增删改**集合中元素的时间复杂度是`O(1)`，但这是一个大常数时间，Java中以`HashSet`为例，每个元素携带伴随数据就是`HashMap`

哈希表的内元素比较是使用值进行比较而不是内存地址

如果哈希表的**key的范围是固定、可控的**，那么可以使用数组来替代哈希表。此时增删改查的时间复杂度还是`O(1)`

### 有序表

`TreeMap`是有序表的一种实现。底层是红黑树。也可以将它看为一个集合，只是它保存其中的元素是有序的。有序表的操作时间复杂度是`O(logN)`

和哈希表一样，有序表中也不会有重复数据。如果不想去重可以加入更多的比较策略（比较器定制）

### 堆

`PriorityQueue`是Java中对堆的一个实现，即优先级队列，默认构建一个小根堆，并且不会去重

### 比较器定制

比较器默认逻辑是，`o1`和`o2`比较，如果返回负数则`o1`优先级高，如果是正数则`o2`优先级高。构造一个有序表的时候需要提供一个其中元素同类型的比较器

#### 字典序

两个字符串如何比大小？一个字符串总可以看作是一个256进制的数字（ASCII），如果字符串长度相同，则直接比较两个数字，如果长度不同，那么使用`0`（256进制最小的数值）将短的字符串填到和长字符串长度相同，然后再进行比较

## 堆结构常见题

[code1](./examples/20-heap-problems.rs)

[code2](./examples/20-max-repeat.rs)

### 合并K个有序链表

 问题描述：给定一个数组，其中各项分别是有序链表的头节点，需要把这些链表合并为一整个有序链表

 解法一：将所有链表节点找一个容器装起来，然后对这个容器排序，然后再将容器内的元素组合成一个新链表。这种方式的时间复杂度是`O(N)+O(N*logN)+O(N)`，即遍历时间+排序时间+组合新链表时间，需要的空间复杂度是`O(N)`

 解法二：使用一个小根堆，先将每个链表的头节点插入，然后每次弹出一个节点，再将它的后续节点插入堆中，这样每次都可以得到一个新有序链表的节点，直到堆为空算法结束。时间复杂度为`O(N*logK)`因为堆中始终只有原始链表条数（K）个元素，所以堆调整的时间复杂度为`O(logK)`，总共需要调整`N`次。额外的空间复杂度是`O(K)`

### 线段最多重合问题

问题描述：提供一个二维数组`n*2`表示有n条线段，找出最多的线段重叠部分的个数

解法：使用一个小根堆，先将二维数组排序，按照每条线段的开始节点排序，此时每条线段可能出现在重合部分的次数只和之前线段的结束节点有关，如果之前线段结束节点大于这条线段开始节点，那么重叠次数需要累计，否则要移出。那么开始遍历二维数组，先将堆中小于等于当前线段开始节点的元素弹出，因为它们不可能再出现在后续线段的重叠部分中，然后记录弹出后堆的大小为当前这条线段可能出现次数。最后返回最大的出现次数。**每一条线段的次数都会累积到后续的次数计算中**

时间复杂度为`O(N*logN)`，因为排序是`O(N*logN)`，堆的操作是每条线段的结尾节点进出一次，所以也是`O(N*logN)`

### 让数组整体累加和减半

问题描述：对于一个数组，至少经过多少次操作（每次操作可以将其中一个元素减半，并且不丧失精度）可以让整个数组的累加和减少为小于原始累加和的一半

解法：贪心算法，即每次将数组的最大值减半，那么达成目标的次数一定是最少

优化点：由于精度原因，可以将每个元素乘`2^n`次方来变为`int64`类型，即转化精度为整数位数，并不影响问题解答。还可以自己实现堆，在建堆过程中从底向上，时间复杂度为`O(N)`。**使用转化精度的时候记得把操作的元素数据类型改为`int64`**

## 基数排序

[code](./examples/21-radix-sort.rs)

- 基于比较的排序：不关心数据特征，只要能定义元素之间的比较关系就可以执行，很通用
- 不基于比较的排序：和比较无关的排序，但是需要满足特殊的数据特征，不通用

### 计数排序

如果待排序数组的范围是整数，且元素的范围比较小，可以直接使用一个较小范围的辅助数组（桶），然后遍历一遍数组记录词频，然后从桶重新生成排好序的数组

一般来讲，计数排序要求样本是整数，且范围比较窄。因为范围如果很大辅助数组可能会非常大，且性价比很低

### 基数排序实现

对数字的各个位数依次进行计数排序，直到最高位数排好序就结束算法

一般来讲基数排序要求样本是非负数（10进制）

实现的优化项

- 前缀数量分区：每次遍历数组，记录当前位的出现次数（进制大小辅助数组），然后用累计词频覆盖原结果，则每个位置都记录着当前位在辅助数组中最后出现的位置（需要从后往前遍历，这种排序是稳定的）
- 数字提取某一位的技巧：`(num/offset)%BASE`可以取出`BASE`进制数的第`offset`位数字

注意：处理完每个位之后，**前缀数量分区的辅助数组要清空，防止后续重复计数**

时间复杂度`O(N)`，空间复杂度`O(M)`，即多于`n`的辅助数组

注：如果是一个包含负数的数组，可以通过找出数组的最小值，然后数组中每个元素减去这个最小值转化为一个非负数组，再进行排序，最后再加上这个最小值

## 排序总结

| 排序算法 | 时间复杂度  | 空间复杂度 | 稳定性 | 备注                                                 |
| -------- | ----------- | ---------- | ------ | ---------------------------------------------------- |
| 选择排序 | `O(N^2)`    | `O(1)`     | 不稳定 | 每次都需要选择最后一个最小的数放到最前面，所以不稳定 |
| 冒泡排序 | `O(N^2)`    | `O(1)`     | 稳定   | 只要每次相同两个数比较不交换就能保证稳定性           |
| 插入排序 | `O(N^2)`    | `O(1)`     | 稳定   | 只要每次插入时相同的数不插入到前面就能保持稳定性     |
| 归并排序 | `O(N*logN)` | `O(N)`     | 稳定   | 在归并时以左侧为开头进行归并就能保持稳定性           |
| 快速排序 | `O(N*logN)` | `O(logN)`  | 不稳定 | 每次随机选择的数总是在相同数的最后，无法保证稳定性   |
| 堆排序   | `O(N*logN)` | `O(1)`     | 不稳定 | 堆化过程不考虑稳定性                                 |
| 计数排序 | `O(N)`      | `O(M)`     | 稳定   | 入桶出桶严格按照次序，保证稳定性                     |
| 基数排序 | `O(N)`      | `O(M)`     | 稳定   | 入桶出桶严格按照次序，保证稳定性                     |

选择什么排序方法取决于更关心什么？

- 如果数量小，使用**插入排序**，因为它的常数操作时间小
- 数量大，需要性能优异，且可以保证稳定性，不在乎空间占用，可以使用**归并排序**
- 数量大，需要性能优异，有调整空间，可以选择**快排**，因为快排选择随机数的策略可以指定
- 数量大，需要性能优异，不在乎稳定性，且对空间占用有要求，可以使用**堆排序**

⚠️目前不存在时间复杂度是`O(N*logN)`且空间复杂度小于`O(N)`且保持稳定性的算法

### Timsort

[Timsort](https://bugs.python.org/file4451/timsort.txt)

### Shellsort

每次将一个数组划分为`k`部分，然后对每部分的每个值进行插入排序，直到`k=1`

性能和划分的`k`取值有关，这是一个in-place的排序算法

## 异或运算的骚操作

[code](./examples/22-xor.rs)

开头题目：一个袋子中有`a`个白球和`b`和黑球，每次拿出两个球，如果都是白或都是黑球，则放一个白球，否则放一个黑球，那么最终袋子只剩一个球时，这个球是白球或黑球的概率用`a`和`b`如何表示

假设白球是`0`、黑球是`1`，那么每次操作都是一个异或运算，将结果放进袋中，那么问题的结果就是所有球表示的数字的异或和，那么和白球的数量无关，当黑球数量为奇数时，一定会剩一个黑球，否则会剩一个白球。这个问题使用白黑球表示了n个一位二进制数的异或运算结果

### 异或运算的性质

1. 异或运算就是两个数的**无进位相加**
2. 异或运算满足交换律和结合律。在异或运算中，运算顺序不影响结果
3. `0^N=N`和`N^N=0`
4. 一批数字的一部分的异或和为`a`，总异或和为`b`，那么剩下一部分的异或和就是`c=a^b`

⚠️性质1最重要，其余性质可以通过性质1推出。性质4最多考题

### 异或例题

#### 交换两个数

```rust
fn exchange_2_nums(a: &mut i32, b: &mut i32) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
```

这种交换方式如果两个数在同一个内存地址，那么第一次异或操作结果就是0，无法进行交换且会将自己改为0，所以在数组中交换位置不推荐用这种方式

#### 不用任何判断和比较语句，返回两个数的最大值

主要是使用符号位转化为两个值相乘的系数`0`和`1`

#### 找到缺失的数字

问题描述：有一个数列长度为`n`，它包含`0~n`中的`n`个数，找到其中缺少的某个数

解答，根据性质4，所有数字的（索引值）的异或和当前数字的异或和做异或就是缺失的数字

> 直接用累加和公式算出总数，减去当前的数就是结果

#### 一个数列中，某个数出现奇数次，其余数出现偶数次，返回出现奇数次的数

给数列做一个异或和，结果就是那个数

#### 一个数列中，两个数出现奇数次，其余数出现偶数次，返回两个出现奇数次的数

**Brian Kernighans算法**，求一个数的二进制形式最右侧位数为1的数，步骤是先对`x`取反，再加1，再与原数做`&`运算，由于取反加一的操作是一个数的相反数，所以形式为`DigitNumber=x & (-x)`

给数列做一个异或和，然后找这个结果最右侧为1的位数，此时只要拿到仅留这个位数的数，由于A、B一定不相同（如果相同就与题目矛盾），所以A、B在那一位一定不一样，所以只要对数列中每个那一位为0的数做异或和，就可以得到A或者B的值，然后就算出了另一个的值

#### 一个数列中，一个数出现少于m次，其余数出现m次，找出出现次数少于m的数

每个数出现m次的含义就是各个位数的0、1出现m次，那么唯一出现次数少于m次的数就会让每一位上的0/1出现次数少于m的倍数，所以只要按位数统计词频，最后每一位对`k`取模就是那个数

## 位运算的骚操作

[code](./examples/23-bit-op.rs)

位运算的执行速度常数时间非常好，仅次于赋值操作

### 如何判断一个数是否为2的幂

因为2的幂表示在这个数的二进制表示中只有一个1（负数不可能是2的幂），所以只需要使用`Brian Kernighans`算法得到数字最右侧的1然后和这个数做对比即可

### 如何判断一个数是否为3的幂

3的幂一定不是不是一个负数，且3的幂一定只包含3这个唯一质数，那么判断这个数是否为3的幂只需要使用整数范围内3幂次最大的数对这个数取模，如果结果为0就是3的幂

### 已知n为非负数（非必要条件），找到大于等于n的最小的2的幂次数

如果n为负数或0，答案就是0。如果n大于0，那么只要把n二进制形式最左侧1的右侧全部改成1，然后加1就是答案，需要处理n本身是2的幂次的情况，所以先进行`n-1`处理

### 在范围`[x,y]`上,`x`和`y`都是非负数，得到所有数的`&`操作的结果

不能直接遍历，因为遍历可能会很慢。所有位上，只要有`0`出现，那么那一位的最终结果就是`0`，所以只要确定哪些位是`0`就可以快速算出结果。如果`x==y`，那么值就是y，否则有`y-1`一定在`[x,y-1]`上，`y`和`y-1`做`&`操作就会让`y`的最后一位1失效，此时就去掉了`y`上的一位1，重复此过程直到`y<=x`

### 逆序一个二进制数⭐️

原理：对一个二进制数进行分组，先每组一个，然后交换，然后每组两个，交换。最后每组16个，交换完成

### 查找一个数的二进制形式中存在几个1⭐️

原理：对一个二进制数分组，将原数字表示为每组一个，记录`1`出现的次数，然后合并，每组两个，记录`1`出现的次数，然后4个、8个、16个、32个，返回结果

⚠️rust实现时的加法要使用`wrapping_add`防止溢出报错，且不影响结果

### 总结

当模版用，不强求处处使用这种做法

## 位图

[code](./examples/24-bitset.rs)

一种集合结构，如果数据范围是**连续**且固定，那么位图可以在常数时间内执行数据的增删改查，并且只使用很少的空间（同等情况下比哈希表少）

用bit数组来存放值，`0`表示存在，`1`表示不存在，取值和存值都是用位运算。因为是用1个bit来表示一个唯一数据，所以可以极大节省空间

```text
// 构建一个位图，保存0~n-1的数字
Bitset(int n)
// 添加一个数
add(Bitset &set, int n)
// 删除一个数
remove(Bitset &set, int n)
// 存在删除，不存在保存
reverse(Bitset &set, int n)
// 查询一个数
query(Bitset &set, int n)
```

两个非负数做除法并向上取整可以使用`(a+b-1)/b`，这个式子表示，如果`a`是`b`的整数倍加一个余数，那么`(a+b-1)`就一定会多一个`b`，所以向上取整，如果`a`只是`b`的整数倍，那么`(a+b-1)`还是不会多一个`b`

## 位运算实现加减乘除

### 加法

两个数相加等同于两个数的无进位相加结果和进位信息结果相加，重复知道进位信息为0。无进位相加等同于`^`操作，进位信息是两个数做`&`操作，然后左移一位

### 减法

`(a+b)`等同于`(a+(-b))`，那么一个数的负数的二进制表示为`!a+1`，再将这个加法使用二进制加法实现，然后再使用二进制加法实现最初的减法`bit_add(a, bit_neg(b))`

### 乘法

和十进制乘法相同，即在`b`二进制上为`1`的位置上`a`需要左移的个数和累加，⚠️`b`右移后左边需要补0

### 除法

对于两个32bit的非负数除法，等同于判断`a`是否含有`b*2^30`这个数，如果包含，则结果的第`30`位就应该是1，然后判断`a-b*2^30`之后的结果是否包含`b*2^29`，直到判断`b*2^0`结束

当判断`a>=b*2^30`时，为了防止`b`左移溢出，可以改为`a/2^30>=b`

对于`i32`整数，输入参数不能是整数最小值，因为取反为`0`

## 链表高频题和必备技巧

[code-链表相交节点](./c/list-intersection.c)

[code](./examples/26-linkedlist-problems.rs)

[code-拷贝带随机指针链表](./c/list-copylist.c)

[code-回文结构](./c/list-palindrome.c)

[code-第一个入环节点](./c/list-cycle.c)

[code-链表排序](./c/list-copylist.c)

注意点

1. 如果题目的空间要求不严格，可以使用容器的方式做，很容易
2. 如果题目的空间要求严格，或者面试官要求**对空间使用做优化**，那么需要实现空间复杂度为`O(1)`的算法
3. 最常用的技巧，快慢指针
4. 链表的算法都比较简单，考察的是coding能力，尽量不使用容器讨巧实现
5. **多写多练**

### 返回两个无环链表的第一个相交节点

问题描述：给定两个链表的头指针，判断是否有相交且返回第一个相交的节点

解法：两个链表如果相交，那么遍历两个链表到结尾非空节点，这两个节点内存地址一定一样，否则不相交。然后计算出哪个链表更长，让那个更长的链表先走`(la-lb)`步，然后再同时遍历两个链表，得到第一个相同节点就是答案

解法2：使用一个哈希表来保存一个链表节点的内存地址，然后遍历第二个链表，判断是否有相同的链表节点存在

### 每k个节点一组翻转链表

问题描述：对一个链表，以k个节点为一组，组内翻转链表，如果结尾剩的节点不够k个，那么留着不动

解法：对每k个节点做链表翻转，组内原尾节点成为组内头节点，组内原头节点成为组内尾节点，并且指向下一组的头节点，最终返回头节点。第一组需要特殊处理，因为第一组原尾节点是修改后整个链表的头节点，后续每个组翻转完，前一个组的尾节点需要指向当前组翻转完的头节点

⚠️Rust实现分组翻转链表可以利用一个senital节点，然后一个可变引用实现，具体参照代码

解法2：使用一个数组保存所有节点，组内翻转数组元素，最后做一个新链表返回

### 复制带随机指针的链表

问题描述：链表节点除了值和指向下一个节点的指针以外还有一个指针，可以指向链表内或其他节点，要在不修改原链表的条件下拷贝整个链表

解法：使用容器，可以利用一个哈希表来存储原链表，每个`key`都是原链表节点的内存地址，存一条顺便新建一个节点，然后遍历哈希表，新节点参考老链表的节点关系去设置，最终返回新链表的头节点

解法1：在原链表上每一个节点后插入一个值相同的节点，然后遍历链表，新链表的随机指针内容就是原链表对应节点的随机指针的值，这里就是利用了链表的逻辑有序来得到原节点的随机指针的值

⚠️C语言实现中，局部变量在栈上分配空间，离开自己的作用域之后栈上的空间可能会被其他部分使用，所以需要在堆上分配内存（`malloc`）并且**必须初始化其中的指针内容**

### 判断链表是否为回文结构

回文结构：从左到右和从右到左遍历结果相同，空字符串是回文

快慢指针：目的是求中点

问题描述：判断一个链表是否为回文

解法：使用容器，可以将链表元素压入一个栈，然后从头遍历链表并和栈中的元素比较，因为出栈是逆序，所以如果两个遍历结果相同即为回文

解法2：使用快慢指针，得到中点，然后翻转中点后的链表，从头尾遍历链表，如果相同则返回。⚠️得到结果后要把链表恢复到原始状态

考研题：`a1->a2->a3->a4->a5->a6->a7->a8`改造为`a1->a8->a2->a7->a3->a6->a4->a5`，同样适用快慢指针，再遍历的时候重组链表结构即可

### 返回一个链表的第一个入环节点

问题描述：给定一个链表，如果无环则返回空，否则返回第一个入环的节点

解法：使用一个`hashset`，遍历链表，将每一个节点的内存地址存入哈希表中，直到碰到重复节点，那么返回

解法2：结论是快慢指针第一次碰到后，慢指针继续走，快指针从头部按慢指针遍历，直到两个指针相遇，返回结果。计算原理如下图

![image](./picture/circle-meet.png)

### 在链表上排序，要求时间复杂度`O(N*logN)`，空间复杂度为`O(1)`，且排序稳定

使用归并排序，且不借用额外空间完成排序，可以满足要求

## 数据结构设计高频题

[code-set_all哈希表](./examples/27-ds-setall-hashmap.rs)

[code-lru](./c/list-lru.cpp)

[code-insert/delete/random](./examples/27-ds-ins-del.rs)

[code-median](./examples/27-ds-median.rs)

[code-max-freq-stack](./examples/27-max-freq-stack.rs)

[code-alloone](./c/list-alloone.cpp)

### `set_all`功能的哈希表

对一个哈希表，扩展一个方法`set_all(val)`，该方法可以将当前哈希表所有的值替换为指定值

解法：为哈希表中添加的值附带一个次序（时间）信息，并且多记录一个`set_all`传递的值，那么调用`set_all`的次序之前的值在`get`的时候都返回这个值即可

### 实现LRU结构

Least Recently Used (LRU) cache，在一个有限容器中，实现读写操作`O(1)`且符合当容器满时，总是删除上一次使用时间总是距离当前时间最远的元素

解法：使用哈希表结合双向链表实现。哈希表存储key和对应的节点在链表中的地址，链表总是满足最新访问的地址在链表尾，最早访问的地址在链表头的性质

### 插入、删除和获取随机元素时间复杂度均为`O(1)`的结构 I

题目要求：不允许插入重复元素

解法：保存元素可以使用哈希表，这样在插入和删除时都是`O(1)`复杂度，然后在一个数组中连续保存数字，确保获取随机元素的时间复杂度也是`O(1)`，删除元素时保证数组的连续性即可

### 插入、删除和获取随机元素时间复杂度均为`O(1)`的结构 II

题目要求：允许插入重复元素

解法：哈希表保存重复元素的索引位置，可以使用`hashset`结构来保证删除时的时间复杂度为`O(1)`，在删除的时候，如果元素在哈希表中存在，那么删除一个索引位置，如果这是最后一个索引位置，再把整条记录删除，并且保证数组的连续性

⚠️从`hashset`中随机取出一个元素可以使用迭代器方法

### 从一个流中获取中位数

题目描述：给定一个流，对其包装一个结构体，向外暴露两个接口，分别为消费流中的数字和返回当前的中位数

中位数：将数列从小到大排序，返回中间的数（奇数返回中间的数，偶数则返回中间两数和的一半）

解法：使用两个堆始终将流中消费的数分为较大部分和较小部分，较大部分在小根堆，较小部分在大根堆，如果两个堆的大小差距超过2，那么将多的堆中的堆顶元素给另一个堆，求中位数就是两个堆定元素之和除2，如果是奇数则返回数量更多的那个堆的堆顶元素

### 最大频率栈

题目描述：实现一个栈结构，它的`pop`方法总是返回出现频率最高的元素，如果这个元素有多个，那么返回最靠近栈顶的一个

解法：使用一个哈希表来存储值和词频，在入栈时，先查找它在哪个词频，找到后在二维数组中找到对应的词频数组，把这个数放进去，增加词频。在出栈时，二维数组最后的一个元素（数组）中的最后一个元素返回即可，如果数组长度为0则删除这个数组

实现思路是，将词频组织成了一个栈，那么栈顶永远是词频最高的词，然后每个词频又是一个栈结构，保证了同样词频弹出的依旧是最靠近栈顶的元素，只需要查询时间为`O(1)`（利用哈希表），就可以实现全操作时间复杂度和栈相同`O(1)`

### 实现全操作时间复杂度为`O(1)`的数据结构

题目描述：对于一个保存字符串的数据结构，它有增加、减少、获取最大词频和最小词频的字符串四个方法，每个方法的时间复杂度都需要是`O(1)`

解法：使用一个双向链表保存词频信息，每个节点包含表示词频、该词频下有哪些字符串，增加删除时的检索字符串对应词频需要一个哈希表来保存，由于只需要词频信息，所以链表的每个节点可以是一个`hashset`

⚠️**细心**

## 二叉树高频题目

[code](./examples/28-binary-tree.rs)

### 二叉树层序遍历

二叉树层序遍历就是二叉树的BFS，需要借助队列，基本思路就是将根节点插入队列，然后弹出一个节点，将其两个子节点如果存在就插入队列，直到队列为空，实现可以借助队列和数组，后者**常数时间更好**

题目描述，将每一层作为一个单独链表返回

解法1：可以使用一个哈希表来记录每个节点的层数，通过判断层数是否有对应的子链表来决定是否创建新链表

解法2：使用数组，那么每次插入节点后，记录一个当前队列元素数量，每次只取这个数量的元素，创建一个新的子链表即可

### 二叉树锯齿状层序遍历

题目描述：和层序遍历类似，但是隔一层遍历循序相同，相邻层遍历顺序相反

解法：和普通的二叉树层序遍历相同，只需要在不同层判断是否反序遍历即可，且先遍历后移除节点

### 二叉树的最大宽度

问题描述：二叉树的最大宽度是指，二叉树的每一层最左端的节点到最右端节点（如果存在）的距离

解法：需要利用二叉树的节点的位置，即`n`位置的节点的两个子节点分别在`2*n+1`和`2*n+2`的位置，且最大宽度可以通过两个节点位置`(l2-l1)+1`得到。依旧使用层序遍历的方式，只要将每层的遍历结果的最大宽度计算起来，遍历完成后得到结果即可。在层序遍历节点的时候需要使用另一个同步变化的队列来记录各个节点的索引位置，计算最大宽度用这个队列中的数据记录

### 求二叉树的最大深度和二叉树的最小深度

求最大深度只需要递归求解根节点的左子树深度和右子树深度的最大值，然后结果加1就是最终结果

求最小深度同理，但是需要注意，如果根节点只有一棵子树，那么最小深度就是这棵子树的深度。还可以利用BfS查找第一个叶子节点出现的位置所在的深度

### 二叉树的先序序列化和反序列化

二叉树的先序遍历和后序遍历都可以做树的序列化，但是中序遍历不行，因为中序遍历的序列化结果（字符串）可能表示多个不同的树结构，所以无法反序列化

序列化过程中可以将空节点序列化为`#`符号，每个节点以`,`做分隔。反序列过程就是取一个节点，建立一个节点，然后递归创建左子树和右子树，然后返回这个节点

### 二叉树的层序遍历序列化和反序列化

层序遍历的序列化和层级遍历相同，需要把空节点用`#`表示

序列化过程中，每个节点在进入队列之前，先把自己的值打印到结果字符串内，然后根据自己的左右子节点判断，如果非空，则将值打印到字符串，插入节点，否则将占位符打印到字符串，跳过。**保证序列化字符串中始终只有非空节点，和父节点为非空节点的空节点**

反序列化过程中，从根节点开始，直接创建两个子节点，因为根节点一定存在，所以这一步不会报错，然后如果节点非空，则插入队列，否则创建空间点跳过，使用这两个节点修改当前节点，进入下一次遍历

### 利用先序和中序遍历结果来重构一棵二叉树

题目要求：**所有元素不重复**

解法：对于先序和中序的遍历结果，可以有一个函数`f(pre [i32], pre_i usize, pre_j, usize, mid [i32], mid_i usize, mid_j usize) -> Node`来返回构造的树，因为先序数组的第一个元素一定是根节点，那么找到这个点在中序数组的位置，这个位置之前的所有元素都是根节点的左子树，右侧节点都是右子树

递归遍历不需要中序数组参与，因为中序数组的意义只是在递归过程中传递当前处理的先序遍历数组的元素范围，而这个信息在开始使用map存储每个元素在中序数组中的索引时已经做完，只需要传递这个map即可

### 验证完全二叉树

解法：完全二叉树即所有节点在每一层都是从左到右依次添加形成的二叉树。可以使用层序遍历的方式，每个节点满足完全二叉树的要求有两个

1. 不存在该节点的左孩子为空，右孩子不为空的情况
2. 该节点如果左、右孩子不全，那么该节点后续的所有节点都必须是叶子节点（左右孩子为空）

### 求完全二叉树节点个数

要求：时间复杂度要小于`O(N)`

解法：对于一棵完全二叉树，先计算左子树深度，然后计算右子树的最左节点深度，如果右子树深度等于左子树深度，则左子树是一个完整二叉树，它的节点总数为`2^h-1`个节点，如果小于左子树深度表示右子树是一棵完整二叉树，两种情况下再递归求另一棵不完整二叉树的节点个数即可

时间复杂度为`O(h^2)`，因为每次循环都会选择左子树或右子树进行遍历，且高度减少1，所以序列为`h,h-1,h-2...1`，等差数列累加和时间复杂度为`O(h^2)`，有二叉树的高度为`h=log2(N)`，所以时间复杂度为`O((log2(N))^2)`，远小于`O(N)`的时间复杂度

### 普通二叉树上寻找两个节点的最近公共祖先

题目要求：两个节点不相同，且一定存在于树中

两个节点可能为两种不同情况

1. 包含关系，即两个节点可能在对方节点的子树，这种情况下返回那个父节点即可
2. 分离关系，两个节点在一个根节点的两边，那么返回这个节点

从根节点递归，如果当前节点是两个节点之一，那么这颗子树的最近公共祖先就是当前节点，如果当前节点为空，那么这棵子树没有最近公共祖先（这里相当于递归的base case），如果不是上述情况，先在左子树查找两个节点，再在右子树查找两个节点，如果两个都没找到，则无最近祖先（无关节点），如果两个都找到，那么当前节点就是最近祖先，如果任一找到，那么就是那个节点，递归得到的答案会逐层传递回根节点

### 搜索二叉树上寻找两个节点的最近公共祖先

搜索二叉树需要每个节点的左子树任意值小于当前节点，右子树任意值大于当前节点

解法：对于当前节点，如果小于两节点最小值，那么往右寻找，如果大于两节点最大值，往左寻找，如果等于任意值，则直接返回，如果大于最小值，小于最大值，则返回当前值

### 收集累加和等于aim的所有路径

题目描述：给定一棵二叉树，求出所有节点累加和为`aim`的路径，返回这些路径

解法：需要有一个遍历记录，路径的要求是从根节点到叶子节点，所以如果某个叶子节点满足，则将记录的路径添加到最终结果，每次遍历完当前节点返回时要修改遍历记录的内容，删掉当前节点

### 验证平衡二叉树

平衡二叉树就是任意节点的左子树和右子树的高度相差小于等于1的树

解法：递归遍历二叉树，如果有任意一个节点不满足要求，直接设置结果

### 验证搜索二叉树

解法1：搜索二叉树的中序遍历结果就是一个从小到大的有序数列，所以可以使用迭代方式中序遍历搜索二叉树（栈），遍历过程中如果都是升序则为搜索二叉树，否则不是

解法2：记录左子树的最大最小值，右子树的最大最小值，递归计算当前节点的左节点的最大值和右节点的最小值，然后判断当前节点是否满足大于左子树最大值，和小于右子树最小值，如果不满足则为非搜索二叉树，如果满足，则为搜索二叉树。**对于空节点，它的最大值为整数最小值，最小值为整数最大值**，这样可以满足叶子节点的判断条件

### 修剪搜索二叉树

题目描述：将一颗搜索二叉树修剪为指定范围的一颗新搜索二叉树

解法：递归遍历，如果当前节点在范围内，则保留节点，判断子树，如果当前节点不在范围内，如果小于整个范围，则它本身连同左子树去掉，检查右子树，如果大于整个范围，则它本身连同右子树去掉，检查左子树，最终返回头节点

### 二叉树打家劫舍问题

题目描述：在一颗二叉树上，小偷只能偷不相邻的节点，求解小偷能偷的最大数额是多少

解法：在任意一棵子树上，小偷能偷的最大数额是，小偷偷根节点的数额加上小偷不偷所有子树根节点的结果和小偷不偷根节点结合小偷偷/不偷子树根节点的结果的最大值

![image](./picture/binary-tree-rob.jpg)

这道题和验证搜索二叉树相同，需要记忆之前的运算结果，本章的题目是使用全局变量。可以从叶子节点向上进行分情况讨论

## 常见经典递归过程分析

[code](./examples/29-recursion.rs)

### 查找一个字符串的所有子串

子串是从一个字符串中任意取不同的字符构成的子串（顺序不变），题目要求所有子串**不重复**

解法：对于任意一个子串，都是对所有字符的选择决策树的一条路径的收集，由于每个决策分为包括此字符还是不包括此字符，所以最终所有结果是一颗完全二叉树

时间复杂度为`O(2^N*N)`，因为所有的可能性的总和是`2^N`种，且生成子串的时间平均也是`N`，所以相乘即为整个过程的时间复杂度

### 查找一个数组中的所有不重复的组合子数组

对于一个数组，其中包含的所有子数组和上一题类似，都是对任意一个元素的取舍做决策，最终结果是对二叉树的路径做去重。因为两个重复的子数组只跟各个元素的值出现的次数有关，所以我们可以先对数组排序，然后相同值的节点为一组，那么结果就变成当前组有`0...n`个时，和后面的不同元素的组合关系，这**避免了对全组合的遍历**。因为最差的情况是所有元素不同，所以时间复杂度也是`O(2^N*N)`，这里用到的技巧是**剪枝**而不是去重，后者依旧会全遍历，但是前者是直接减少遍历情况

**剪枝**是在递归过程中直接去掉明知无效的路径，这道题是通过先排序，将可能重复的情况改变为不可能重复的情况，所以结果不需要再去重

### 一个不含重复元素的数组的全排列

解法：一个数组的全排列可以通过在`i`（`i => 0..n`）位置出现任意值，递归求后续序列的全排列来得到最终答案

#### 包含重复元素的数组的不重复的全排列

解法：在交换逻辑中添加去重逻辑

#### 本题总结

可以利用原数组作为记录每个排列的路径容器，每次递归结束后要**将原数组恢复**，因为下一次递归要求不能被上一次递归的结果影响，如果用额外的空间记录路径那么不需要修改原数组，但是空间复杂度高

时间复杂度为`O(N!*N)`，因为`N`个元素的全排列的数量就是`N!`中，生成每个序列的时间为`N`

### 用递归逆序一个栈

解法：利用递归函数本身有独立的内存空间，可以暂时保存栈中的值的特点，写一个子递归函数，作用是将栈底元素重新加入栈顶，然后再写一个递归函数，重复上述过程并重新压栈，这样实现栈的逆序

时间复杂度`O(N^2)`，因为每次逆序一个元素都要移动栈`N..N-1...`，总共移动`N`个元素

### 用递归排序一个栈

解法：所有方法都是递归实现，同样利用递归函数自己的内存空间来暂时保存栈中元素的特性。首先获取栈的深度，然后搜索栈中的最大值，然后查找最大值的数量，然后将这些最大值压入栈底，并且栈深度减去压入的最大值数量，重复这个动作直到栈深度为0

### N层汉诺塔问题

问题描述：有三根杆子，最左有N个盘子，求将这N个盘子从最左移动到最右的最优路径，并且要满足1）一次只能移动杆子最上层的一个盘子，2）大盘子不能压小盘子（初始盘子从小到大放置）

解法：解决N层汉诺塔问题，只需要转化为`N-1`个盘子先移动到中间，再将唯一的盘子移动右边，最后再将中间的盘子移动到右边即可。时间复杂度为`O(2^(N-1))`，因为`f(N)=f(N-1)+1+f(N-1)=2*f(N-1)`，即消耗时间为等比为2的等比数列，根据通项公式`an = a*r^(n-1)`，a是首项，r是等比得到时间复杂度

## 嵌套类问题的递归解题思路

[code](./examples/30-embed-recursion.rs)

嵌套类问题解题套路

1. 定义**全局变量**`let where: usize = 0`
2. 定义函数`f(i)`，表示从`i`位置开始解析，遇到“字符串终止符”或者“嵌套条件终止”就返回结果
3. `f(i)`的返回结果是自己负责的这一段内的结果
4. `f(i)`在返回前要更新全局变量`where`，告诉上游函数知道自己解析到的位置

执行细节

1. 如果`f(i)`遇到“嵌套条件开始”，那么开始调用下级递归去处理嵌套内容，下级递归负责返回嵌套部分的答案
2. `f(i)`下级递归处理完成后，会更新`where`值告诉本级函数该从什么地方开始解析

本节题的时间复杂度都是`O(N)`，因为只是遍历一次数组

### 含有嵌套的表达式求值

限制表达式只有`+ | - | * | /`的**合法**表达式

如果表达式不带括号，那么只需要准备两个栈，一个是数字栈，一个是符号栈，开始解析字符串，碰到数字后，将数字及后面的符号插入对应栈中，如果是乘法和除法，那么先进行计算再插入，保证符号栈中只有计算序列无关的加减法，到终止符时再加入一个加法（随意）符号，然后开始使用两个栈计算最终的结果

如果表达式带括号，那么对于括号内的内容，可以使用递归的方式计算，每个递归计算和无括号表达式计算方式相同，但是需要一个全局变量`where`来计算下级递归的计算位置，并报告给上级函数

### 含有嵌套的字符串解码

题目描述：`aaa2[bb]c`解码为`aaabbbbc`

解法：和上题相同，碰到`[`开始进入递归

### 含有嵌套的分子式求原子数量

题目描述：对于一个分子式`H2O`，根据不同原子出现的数量打印出来`H20`，如果有圆括号，那么后面一定会跟一个数字

解法：原子符号首字母一定是大写，当碰到原子符号或者`(`时，说明历史统计需要被更新到结果中并且历史统计要被清除，对于`(`内部的原子统计使用递归方法，最终将统计表转换为结果。这里使用`TreeMap`来保证输出按字典序打印

## N皇后问题

[code](./examples/31-n-queen.rs)

题目描述：在一个`N*N`的棋盘上，放置一个皇后之后，它的同行、同列，两条对角线不能再摆放其它的皇后，问在棋盘上摆满N个皇后的可能摆法有多少种

解法时间复杂度为`N!`，因为摆放总可能性是`N*(N-1)*(N-2)...1`

### 数组记录摆放路径的方式

1. 每行摆一个皇后
2. 下一行的皇后摆之前根据之前摆的皇后的位置判断当前位置是否可以摆皇后，对角线判断为`|cur_row-last_row|==|cur_col-last_col|`
3. 如果可以摆，则放到下一列继续尝试
4. 将所有的可能次数累加

这种实现方式的常数时间慢，推荐位运算版本实现

### 位运算方式

使用位信息来记录当前已经放置的皇后和当前行不能放置的皇后的限制

- 列限制，如果位上为`1`，表示该列已经放置皇后
- 右上-左下限制，传递给下一行之前，将限制数右移一位，低位表示前`N`列
- 左上-右下限制，传递给下一行之前，将限制数左移一位，高位表示后`N`列

限制列数可以使用`(1<<N)-1`来计算
使用`N&(-N)`的`Brian Kernighans算法`可以获取可能的位置的最后一位
使用`N^lastN`可以将已经尝试选择的那一位抹去

## 最大公约数和同余原理

[code](./examples/32-gcd-lcm.rs)

### 求最大公约数

辗转相除法（欧几里得算法）计算：`gcd(a,b) = b == 0 ? a : gcd(b, a % b)`，其中`a>b`，时间复杂度是`O((loga)^3)`

`Stein`算法在更大的数的计算上更快，还有**裴蜀定理**

### 求最小公倍数

`lcm(a, b) = a / gcd(a, b) * b`

### 经典题目

题目描述：给定两个数字`a,b`，如果一个数可以被`a`整除，也可以被`b`整除，就是一个神奇数字，求第n个神奇数字

这里用到了“二分答案法”和“容斥原理”

首先这个第n个神奇的数字的范围是`1~n*a`范围内，且`b`的存在只会缩短真正第`n`个神奇数字的范围。如果直接遍历，这个数字可能会非常大，因为最终的结果要对`10^9+7`取模，所以可以用二分查找，如果这个范围内的数字个数小于`n`，那么就往右边找，否则往左边找

### 同余原理

对于大数字的计算，如果利用字符串或者`BigInteger`这种类型表示计算，那么对于`k`位数字，加减操作的时间复杂度从`O(1)`升到`O(k)`，而乘除计算从`O(1)`升到`O(k^2)`，其中固定位数的整数类型`i32`/`i64`的加减乘除模运算的时间复杂度可以认为是`O(1)`

同余原理可以将很大数字的运算最终的取模结果分解到各个子式做取模运算，提升效率，直接用最好两个数都是正数，如果有负数，它自己的模要变为正数再运算

- 加法同余原理：两个结果各自对`m`的取模的结果相加再对`m`取模的结果和两个结果相加对`m`取模相同
- 乘法同余原理：和加法相同，但是要避免溢出
- 减法同余原理：两个结果对`m`取模，做减法，结果加`m`再对`m`取模
- 除法同余原理：需要利用乘法的逆元，暂不提

## 对数器打表找规律的技巧

[code](./examples/33-matcher.rs)

使用场景：输入参数是简单类型，输出参数也是简单类型

1. 暴力解法（不关注时间复杂度）将小范围的问题解决
2. 打印出输入和输出
3. 根据输出找规律，将规律变为代码

### 使用规格8和规格6的袋子买苹果

问题描述：有一堆苹果，只能用6规格和8规格袋子装，问装满苹果至少需要几个袋子，如果没法用袋子装完返回-1

解法：先用暴力递归求解答案，然后总结规律

### 轮流吃草

问题描述：有一堆草，两只羊吃，每只羊每次只能吃4的n次方数量的草，谁先吃完谁赢，给定一个数量的草来判断谁能赢

解法：递归求解，总结规律

### 判断一个数字是否是若干数量(数量>1)的连续正整数的和

问题描述：如题所述

解法：暴力解法，从1开始计算累加和，如果超过给定数字就从2继续，直到起始数字为它自己（数量等于1）

### 好串有多少个

好串：在一个字符串中有且仅有1个长度>=2的回文子串，认为这个字符串是好串

问题描述：用r、e、d三种字符拼接字符串，返回长度为n的所有可能的字符串中，好串有多少个

解法：使用全排列方式找好串，然后找到规律重写

## 根据数据量猜解法

[code-kill-monster](./c/kill-monster.cpp)

[code](./examples/34-guess.rs)

基本事实，C/C++运行1s，python/java/go运行1～2s可以执行的常数级别指令数量级在`10^7~10^8`，那么最好不要超过这个量级的指令，比如问题中的数组长度为`10^6`，那么一个`O(N^2)`的算法明显不会满足时间要求

根据数据量猜解法的前提是

1. 各个入参的最大值和范围给定，这在比赛和笔试中都会提供，面试中需要询问面试官
2. 对于自己设计的算法，可以准确地估计出时间复杂度

数据量和时间复杂度的关系，多的不记，这里主要记录两个

1. `N<11`可以使用`N!`时间复杂度的算法，也就是全排列枚举
2. `O(N*√N)`，时间复杂度比`O(N)`差，在“莫队算法”中会涉及

此外入参不一定只有一个，有些复杂度可能是`O(N+M)`或者`O(N*M)`，要根据数据量来使用某种时间复杂度的算法做，只要卡住时间可以提交成功即可

### 最优技能释放顺序

问题描述：现在有一个打怪类型的游戏，这个游戏是这样的，你有`n`个技能，每一个技能会有一个伤害，同时若怪物低于一定的血量，则该技能可能造成双倍伤害，**每一个技能最多只能释放一次**，已知怪物有`m`点血量，现在想问你最少用几个技能能消灭掉他（血量小于等于0），`n`的范围是`[1,10]`，`m`的范围是`[0~10^6]`

解法：因为`n`的范围小于10，那么直接使用全排列的方式将所有的技能组合列出来，然后挨个测试，最终选择使用技能个数最少的情况

### 超级回文数

问题描述：对于一个正整数，如果它和它开根号后的结果都是回文，那么它就是超级回文数。给定两个数字（使用字符串表示），它们的范围在`[1~10^18-1]`，返回它们中间的超级回文数

解法：两个数字的范围都在`i64`范围内，那么最大数开平方的范围就是`10^9`，如果`10^9`这个数量级的数字是回文，那么它可以利用折半的数字拼出来`[1~10^5]`内的数字，即`1`拼接为`11`，`99999`拼接为`9999999999`，奇数长度的拼接数可以作为限制小于最大值`10^9`进行遍历

一个数字扩展为奇数长度回文：这个数字先除10，在依次模10加到原数字*10的值

一个数字扩展为偶数长度回文：这个数字*10依次加模10的结果

⚠️判断一个数字是否是回文可以认为是一个常数操作

#### 判断一个数字是否是回文

问题描述：负数不是回文

解法1：将数字转换为一个字符数组，然后判断

解法2：得到一个和数字等长的`1`开头的数字，然后这个数字除它就是首数字，模10就是尾数字，然后判断头尾是否相等，然后将原数字头尾去掉，**基本数字除100**

## 前缀树原理和代码详解

[code](./examples/35-trie.rs)

[code](./examples/35-trie-obj.rs)

前缀树也叫字典树，英文名*Trie*。前缀树是每个样本都从头节点开始，根据前缀字符或数字建出的一棵树。特征是如果节点不存在就新建，有就复用此节点

前缀树的使用场景：需要根据前缀信息查询的场景

- 优点：根据前缀信息选择树上的分支，大量节省时间
- 缺点：浪费空间（针对数组实现），因为保存的信息和字符的数量、种类有关
- 定制部分：`pass`、`end`信息

可以使用动态结构（类）实现，也可以使用静态数组实现，比赛/做题应该使用静态数组实现，节省空间

```rust
trait Tier {
    // 初始化前缀树
    fn new() -> Self;
    // 插入一个字符串
    fn insert(&mut self, str: &str);
    // 搜索字符串
    fn search(&self, str: &str) -> Self;
    // 搜索指定前缀的字符串的数量
    fn prefix_number(&self, str: &str) -> Self;
    // 删除一个字符串
    fn delete(&mut self, str: &str);
}
```

## 前缀树的相关题目

[code](./examples/36-trie-problem.rs)

### 接头密钥

题目描述：有一个二维数组，其中的每个子数组都是一个数字列表，每个列表都可以生成一个`[i1-i0, i2-i0...in-in-1]`的数组，此时有另外一个二维数组，它也可以生成这样一个数组，然后得到另一个二维数组生成的数组结果在之前的数组中出现的个数，得到一个结果数组

解法：将前一个二维数组中每个子数组生成的数组构建一棵前缀树，因为每个差值都可以转变为字符串`"number#"`的形式，在遍历第二个二维数组，每个数组生成同样形式的字符串，查看作为前缀在前缀树中出现的次数，组成结果数组

⚠️前缀树中的字符种类除了`0~9`以外，还包括`-`和`#`，此题不能使用数字作为路径是因为数字差值可能会非常大，所以数组空间无法确定

时间复杂度是`O(N*M)*2`，`N`是数组的数字个数，`M`是每个子数组中的最大值的位数。空间复杂度是`O(N*M)`这是树上的节点个数

### 查找数组中两个数的最大异或值

题目描述：对于一个数组中全部是大于等于0的整数，求这个数组中任意两个数的异或结果的最大值。允许两个数自己异或

解法一：因为所有数字都是正整数和0，所以最高为都是0，对于任何一个数，都是要在自己每一位尽量找一个让自己在高位异或结果为1的树。先查看最大数字，对前面的0不建树，然后遍历每个数字，找到和它异或的最大值，然后比较这些最大值得到答案

技巧（保留前n位，后面都变成0）：`num >> (32-n) << (32-n)`

解法二：先找最大值，知道从第几位开始处理。原理是从最高位开始，追求结果从最高位开始每一位是否能为1。

时间复杂度：`O(n*logV)`，空间复杂度：`O(n*logV)`，V是数值范围

### 在二维字符数组中搜索可能的单词

题目描述：给定一组单词（不重复），给定一个只有（有效字母）字符的二维数组，从任意一个字符出发，可以上下左右移动，但是在搜索一个单词的过程中路径中不能有重复字符，问这个二维数组中可以收集到多少单词

对于这个题目，由于单词的最大长度限制是`10`，那么单次查找一个单词是`4^10`种可能，且可以从任意起点开始查找，所以本题的时间复杂度为`O(N*M*4^10)`，这个时间复杂度无法降低，所以考察的是**剪枝**能力

使用前缀树和标记可以对搜索过程进行剪枝

1. 移动过的字符可以标记为`0`，并且回到原位置后要置回
2. 在前缀树的节点上携带字符串内容，表示此处是一个完整字符串，搜索完成后置空
3. 使用`pass`信息保存每个节点的经过数，如果搜索完成就将经过数减去搜索到的字符串，这样搜索前如果碰到`pass`为0的可以认为直接跳过

## 构建前缀信息的技巧--解决子数组相关问题

[code](./examples/37-prefix-subarray.rs)

[code-longest-subarray](./examples/37-prefix-subarray-2.rs)

本节中所有问题需要在`O(N)`时间复杂度下解决

### 快速解决子数组范围求和的问题

构建前缀和数组。在任意范围（`[L,R]`）内求和的计算方法是`S[R+1]-S[L]`，前缀和数组从1开始生效

### 无序数组中，累加和为给定值的最长子数组长度

构建前缀和，最早出现的位置

⚠️子数组一定是连续的

解法：要求最长子数组长度，只要在每个位置找到从该位置往前最长的累加和为目标值的长度即可，可以使用`(求值的累加和-当前位置的累加和)`得到在数组中出现的最早位置

需要使用哈希表来保存每个前缀和最早出现的位置。且需要在哈希表中预先录入`(0, -1)`记录，因为前缀和`0`总是存在，且出现的最早位置在真实索引`0`之前

### 无序数组中，累加和为给定值的子数组数量

和上一题是一样的，只是统计的量从位置变为出现次数

### 无序数组中，正数和负数个数相等的最长子数组长度

将问题转化，将正数转变为1，负数转变为0，那么转变后的数组中求正数和负数个数相等的最长子数组就是和为0的最长子数组，和第二题是相同的，也就是目标数字总是0

### 表现良好的最长时间段

问题描述：给定一个数组，每个元素表示当天工作时间，规定超过8小时为劳累，不超过8小时为舒适，当劳累天数大于舒适天数的时间段就是“表现良好时间段”，求最长时间段

解法：对数组进行转化，大于8小时为1，小于8小时为-1，那么最长的子数组就成为，如果某个位置的累加和大于等于1，则当前位置的最长子数组长度为`(i+1)`，如果这个位置的累加和小于1，那么应该寻找最早出现`loc[i]-1`这个累加和的位置

⚠️由于数组的累加和增减幅度都是1，所以找小于于这个数的累加和的最早位置没有意义，因为它也一定是从大数变化来的

### 移除的最短子数组长度，使得剩余元素的累加和能被p整除

在数组任意位置`i`，向前移除尽量少的元素，使得剩余元素的累加和能被p整除。先求出全部元素对p的余数`rem`，如果`0～i`的累加和对p的余数是`mod`，那么移除元素`j~i`之后`0~i`对p的余数应该是，如果`mod > rem`，`i~end`的余数是`(rem+p)-mod`，所以`0~j`的余数是`p-((rem+p)-mod)`，就是`(mod-rem)`，如果`mod < rem`，`i~end`的余数是`rem-mod`，`0~j`的余数就应该是`p-rem+mod`，这两个数都等于`(p-rem+mod)%p`

哈希表要记录累加和余数出现的最晚位置，保证删除最短数组

⚠️求余数使用同余原理（加法），同余原理求累加和的余数，**前面数字对p取余的结果加上当前的数字，结果对p取余等于当前数字累加和对p取余**

### 每个元音字符，返回达标子串最大长度

题目描述：在一个子串中，如果元音字符出现字符都是偶数个，那么这个子串为达标子串

解法：对元音字符的奇偶频率做记录，将`aeiou`出现偶数次编码为`00000`，除了这种情况外的所有情况都不是达标子串。那么在`0~i`位置，如果子串情况是一个数值，那么只要查找`0~j`范围内奇偶频率也是这个值最早出现的位置

关键在于对前缀信息的表示，可能是编码、转化等！

## 一维差分和等差数列差分

[code](./examples/38-difference.rs)

[code-difference-arithmetic-procession](./examples/38-difference-arithmetic-procession.rs)

[code-difference-arithmetic-procession-2](./examples/38-difference-arithmetic-procession-2.rs)

### 一维差分

对于一个一维数组（**所有元素为`0`**），如果有一组对此数组的操作，比如在某个范围上对数组的每个元素加一个值，如果操作数很多，那么我们希望有一种低成本方式将这些操作都应用到数组后，再经过一次统一处理得到答案。这种方法就是一维差分

将所有的操作`[L~R]`上加`v`转化为`arr[L]+=v,arr[R+1]-=v`，最终将每个元素更新为它位置的累加和，完成操作。原理是在范围开始位置加上的值在计算累加和的过程中总是会携带，直到范围结束的位置，把额外加的值减掉即可

### 等差数列差分

和一维差分类似，不同点在于`[L~R]`范围内加上一个`S,E,D`的首项、末项、公差的等差数列而不是相同的值

等差数列的差分数组处理过程如下，依旧是利用前缀和求最终结果，倒推两次得到原始的差分数组处理公式

```rust
/// 在L～R过程中加上S、E、D的等差数列
/// 最终结果 0 0 S S+D S+2D S+3D S+4D(E) 0 0
/// 中间过程 0 0 S D   D    D    D      -E 0 （比之前增量更大的增量）
/// 起始过程 0 0 S D-S 0    0    0      -E-D E  （原始差分数列）
arr[L] += S;
arr[L+1] += D-S;
arr[R+1] -= (E+D);
arr[R+2] += E;
```

在原始的差分数列求两边前缀和就是最终的结果

#### 等差数列差分数组例题

问题描述：有水平面，默认是0，每一个人都有自己的体积V，和水平位置X，当人从X掉入水中时，会形成波纹，向左向右形成波峰，问N个人落水后水平面在所有位置的值

解答：对于每个人落水的情况，都会从左到右生成4个等差数列，所有人落水的情况会叠加，使用等差数列差分数组解决问题

⚠️因为每个人落水位置都有可能接近两边，所以可以使用`OFFSET`方式来避免边界条件判断

## 二维前缀和、二维差分、离散化技巧

[code](./examples/39-two-dimensional-dif.rs)

[code-two-dimensional-mode-newcoder](./examples/39-two-dif-newcoder.rs)

[code-two-dimensional-mode-lg](./examples/39-two-dif-lg.rs)

### 二维前缀和

解决的问题：对于一个二维数组，给定左上角点和右下角点`(a,b)`和`(c,d)`，可以直接得到这个区域的累加和，并且在`O(1)`的时间复杂度实现。所以要对原数组进行处理得到一个结构

构造这个结构的方式，是将每个`(x,y)`点的元素更新成`arr[x,y-1]+arr[x-1,y]-arr[x-1,y-1]+arr[x,y]`，计算方式应用了容斥原理，因为更新顺序是从上到下、从左到右，所以每个元素左边和上边的元素已经表示了从`(0,0)`到该点的累加和，那么加两次会有一个重叠区域，减掉重叠区域就是该点以外元素的累加和

在构造好的结构上求解累加和的公式是`Sum((a,b), (c,d)) = Sum(c,d)-Sum(c,b-1)-Sum(a-1,d)+Sum(a-1,b-1)`，计算方式应用了容斥原理

实际应用中通常会将原数组包裹一层`0`，以避免边界条件判断

#### 二维前缀和例题

边框为1的最大正方形：给一个由若干0、1组成的二维网格grid，找出边界全部由1组成的最大正方形网格，返回该子网格中的元素数量，如果不存在返回0

解法**唯一**：遍历所有的点，在点上构造所有可能的正方形，然后判断这个正方形是否符合条件，它的时间复杂度是`O(N*M*min(N,M))*4`，可以优化的点在于验证过程的时间，从4条边的4次优化为1次，也就是使用前缀和的方式`Sum((a,b), (c,d)) - Sum((a+1,b+1), (c-1,d-1)) == (k-1) << 2`验证，其中还有剪枝的过程，就是如果找到了更大边长的正方形后在其他点不再查找更小边长的正方形

本题直接使用原二维数组构造前缀和数组，节省额外空间使用

### 二维差分

二维差分数组和一维差分数组解决的问题类似，在一个二维数组中，如果多次对范围左上`(a,b)`到右下`(c,d)`中所有的元素加/减一个值，得到最终结果的过程使用多次设置二维数组，最终处理为结果数组的方式

每次在`(a,b)`到`(c,d)`范围内增加一个`v`值时，对`arr[a][b]+=v`，`arr[a][d+1]-=v`，`arr[c+1][b]-=v`，`arr[c+1][d+1]+=v`，最终将二维数组更新为二维前缀和数组

直观理解：当`(a,b)`点加（减等效）一个值后，它对于到最右下位置的范围都有`+v`的影响（因为最终要求前缀和），所以在目标边界的右和下都减去`v`，此时，`(c,d)`到右下位置会被减两次（`a,b`会加一次）`v`，此时在目标边界的右下加上`v`来抵消影响，最终前缀和就会满足要求

#### 二维差分例题

题目描述：有一个二维数组，其中存在`0`和`1`，然后给定一个`h*w`大小的邮票，目标是将邮票贴满二维数组中的`0`元素位置，所有邮票可以重叠，无数量限制，但是不能翻转，问二维数组是否可以贴满

解法：遍历所有的左上角点，判断这个点能不能贴邮票，准备一个差分数组，如果可以贴邮票，就在对应范围`+1`，判断完所有点后，对差分数组求前缀和，然后比对原数组，如果原数组为`0`的位置在差分数组中的值都大于`0`，那么可以贴满邮票。判断能不能贴邮票需要一个前缀和数组来辅助

时间复杂度`O(N*M)`，空间复杂度`2*O(N*M)`

##### 离散化技巧题目

题目描述：给定一组数据`[x,y,side]`表示在`(x,y)`位置为中心，边长为`side`为正方形的范围构成一个力场，在坐标系中有若干力场，当所有力场叠加后找到力场最强位置（点）的力场强度

解法：构建一个差分数组，将所有力场转化为`+1`操作，最终看哪个坐标的值最高返回即可

⚠️离散化指的是将范围很大的多个值转化为连续的点来表示

⚠️本题坐标可能会出现小数，通过`x*2+side/y*2+side`方法可以保证坐标范围不包括小数

时间复杂度为`O(N^2)`，空间复杂度也是`O(N^2)`，`N`是力场的个数，最多有`2N*2N`个坐标，因为最后需要遍历整个差分数组，所以空间复杂度为`O(N^2)`

## 滑动窗口技巧与相关题目

[code](./examples/40-glide-window.rs)

滑动窗口：维持左右边界都不回退的一段范围，求解子数组/子串相关的问题

滑动窗口的关键：找到**范围**和**求解目标**的**单调性关系**

滑动过程：滑动窗口可以用简单变量或者结构来维护信息

求解大流程：求子数组在每个位置开头或结尾情况下的答案

### 累计和大于等于`target`的最短子数组长度

题目描述：在一个全部是**正数**的数组中，求出最短长度的子数组，要求它的和要大于等于`target`

解法：因为所有的元素都是正数，所以对于求解目标来说，子数组（连续）范围的变化是有单调性的，也就是多一个值结果就增加，少一个值结果就减小。可以使用窗口计算从任意一个位置，包括它以及之前元素的最短子数组，最小值就是结果

时间复杂度`O(N)`，因为窗口左右都是不回退的，所以只是遍历数组一次

### 最长无重复字符子串

题目描述：在一个字符串中找到不含重复字符的最长子串

解法：对于以任意一个元素为结尾，向前的最长的不含重复字符的子串，当进入下一个元素时，如果这个元素的上一个出现位置在之前的子串中，那么要更新子串长度`L=max(L, last_idx+1)`

时间复杂度`O(N)`，需要使用一张hash表来记录每个字符最晚出现的位置

### 最小覆盖子串

题目描述：有字符串`a`和`b`，求`a`中包含所有`b`出现的字符的最短的字符串，顺序无关

解法：关键在于`b`中出现的所有字符的记录方式，可以认为初始状态它们在`a`的子串中出现次数为负数，每出现一次就`+1`，直到这些字符出现次数和为`0`，表示子串包含`b`中所有的字符，此时开始移动子串左边界，但是要保持`b`中字符出现次数为`0`，修改完后就是一个求出的子串，之后每个位置都这样处理即可

时间复杂度`O(N)`

### 加油站

题目描述：有`N`个加油站，它们的路线成环，每个加油站有一些油，距离下一个加油站为`L`，问一辆无限制的油罐车是否能从任意一个点走完一圈，行走距离与需要的油为`1:1`

解法：题目给定了两个数组表示每个加油站的油量和该加油站到下一个加油站的距离，可以直接转换为到每个加油站之后还会剩的油量，那么求解内容就成为从任意一点开始到它前一个点时，油罐车的油量需要大于等于`0`

本题需要注意的点是可以扩展数组来避免环的计算。并且只是扩展数组的索引而不是真的需要扩展数组

本题利用了贪心的方式，即一旦从一个点开始无法走一圈，那么这个点开始走的所有路径都舍弃，因为如果之前的路径存储的油到停止点不能再走，那么之前的任意一点开始在停止点都不可能再走

### 替换子串得到平衡字符串

题目描述：有一个字符串，只包含`Q`、`W`、`E`、`R`四种字符，它的长度一定是4的整数倍，一个平衡字符串表示这个字符串中每个字符的出现数量相等，问需要替换最小子串的长度是多少可以让原字符串变为一个平衡字符串，替换的字符串可以这4种字符的任意组合

解法：这道题类比本章第三题，只需要找到被替换的字符串就可以，即多出来的字符所在的最短的子串中，返回这个长度即可

### K个不同整数的子数组

题目描述：在一个数组中找到不同数字种类恰好为`K`的子数组的个数

解法：如果直接找答案不好找，可以将问题转换为求数组中所有不同数字种类`<=K`的子数组的个数，然后再找到`<=K-1`的子数组个数，两个数相减就是答案。因为转换后的问题，它的求解目标和范围是有单调性关系的，即如果范围增大，数字种类更可能变多，减少更可能变少，所以可以利用窗口来解决问题

### 至少出现K个重复字符的最长子串

问题描述：给定一个数组和一个整数`K`，求出每个字符至少出现`K`次的最长子串

> 这道题有限制，字符串内容只包含小写字母，如果没有这个限制，那么可以用动态规划或者其它方法解决

解法：将问题转化为，每次求解当子串中只包含至少出现`K`次的`1~26`种字符，求解26次之后求得最大值，因为如果固定为`N`种，那么求解目标就跟子串范围有了单调性关系，即范围增大，种类会变多，范围变小，种类会变少

★看数据量猜解法

## 双指针技巧与相关题目

[code](./examples/41-double-pointer.rs)

- 有时的双指针，只是代码过程用**双指针的形式**表达出来，没有贪心方面的考虑
- 有时双指针包含**单调性（贪心）**方面的考虑，是现有的思考和优化，最终代码以双指针形式展现
- **分析题目单调性（贪心）**是最重要的

### 按奇偶排序数组II

题目描述：一个数组中只有奇数和偶数，需要将奇数放到奇数位置（索引），偶数放到偶数位置

解法：使用两个指针，一个指向奇数位置，一个指向偶数位置，然后从最后一个位置查看数字，如果是奇数，与奇数位置交换，奇数指针移动，偶数同理，直到奇数/偶数指针超出数组长度

### 寻找重复数

问题描述：给定一个包含`(N+1)`个数的数组，其中的数字范围是`[1~N]`，已知数组中一定有且只有一个重复数，找到这个重复数，要求时间复杂度为`O(N)`且额外空间复杂度为`O(1)`

解法：根据题目条件可知，从任意位置出发，类似于链表跳转，它的下一个位置就是自己存储的元素数值，那么问题转化为寻找链表环的入环点

### 接雨水

问题描述：给定一个数组表示直方图，问这个直方图可以接到多少单位的雨水（一单位就是`(1,1)`一个点）

解法：x轴上每个点可以接的雨水数量取决于它两边所有点的最大值，那么只需要两个辅助数组，记录`[0,N-1]`上从左往右的最大值和从右往左的最大值，每个点的雨水量就是`max(0, min(lmax, rmax)-arr[loc])`。时间复杂度`O(N)`，空间复杂度`O(N)`

优化解法：使用双指针指向`1`和`N-1`，那么它们各自左右的最大值已经确定，就可以直接确定当前它们自己的雨水，每次移动都更新左和右的最大值，空间复杂度为`O(1)`

本题关键在于**单调性**的确定，范围越小，求解目标就越少，双指针在这里只是一个优化手段

> 二维接雨水问题使用宽度优先遍历

### 救生艇问题

问题描述：给定一个数组，表示每个人的体重，问一艘船只能载两人，载重限制为`LIMIT`，每个人的体重都不会超过这个限制，问把这些人同时载走需要多少船

解答：需要先给数组排序，然后根据体重大的人（数组右侧），为他找船的队友（数组左侧），找到就是最优解，没找到就单独坐船，这里体现了**单调性**

扩展：要求船上的载重必须为偶数

扩展解答：因为每条船的偶数+偶数和奇数+奇数才能实现所有船载重都是偶数，所以只要将奇偶体重分开单独计算即可

### 盛最多水的容器

问题描述：给定一个数组，表示在一个坐标轴上`y`的数字。从中任选两条垂线`x`，得到一个长宽为`(x2-x1),min(y1,y2)`的容器，求这个容器的最大容量

解法：从左右开始对比，并且开始记录一个容器面积，然后判断左右哪条边更短就开始向更内侧移动

⭐️证明：思路是上面这种遍历方式不会错过最优解（反证），假设最优解为`(x1,x2)`，按照上面的遍历方式，总会先到达一个`x`点，假设先到达了`x1`点，当前`x2'`在大于`x2`的位置，如果此时`x1`需要右移，说明`x1`是小于`x2'`的，那么此时的容器面积一定是大于`(x2-x1)*y1`的，因为`(x2'-x1)>(x2-x1)`，此时假设最优解不成立，反证出上面的遍历方式一定能找到最优解

正面思考：对于最初的距离最远的左右两点，首先得到一个容量，如果想得到更大的容量，只能尝试抛弃更短的边，所以只能移动短边的位置，这里体现了**单调性**

### 供暖器

问题描述：给定两个数组表示房屋和供暖器在x轴上的位置，问供暖半径（所有供暖器共享）最小是多少可以为所有房屋供暖

解法：先对房屋和供暖器排序，对每个房屋找到距离最短的供暖器（距离就是供暖器的半径），**对每个房屋，如果多个供暖器的距离相同，那么需要不断跳到最后一个供暖器**。因为对于后面的房屋来说，更可能最优的将是后面的供暖器，且如果一个位置有多个供暖器，不跳过相同距离的供暖器会导致后面房屋无法进行最优供暖器的判断

### 第一个没有出现的正整数

问题描述：给定一个无序整数数组，找到第一个没有出现的正整数，要求时间复杂度`O(N)`，空间复杂度`O(1)`

解法：利用数组索引的连续性来转化问题，即`i`位置总是存放`i+1`，那么得到这个要求满足不了的位置`loc`，返回`loc+1`就是答案。这里使用左右两个指针，左指针表示此位置左边都是满足情况，右指针表示从该位置往右都是无效元素，同时表示当前尝试完成的任务收集`[1,R]`的数字。那么从`L`指针开始，如果当前值满足`arr[L]=L+1`，那么`L++`，如果`arr[L]>R`或者`arr[L] <= L`或者`arr[L]==arr[arr[L]-1]`，那么将这个元素移动到`R`区域，`R--`，直到`L`和`R`相遇，表示收集工作完成，返回结果

## 二分答案法与相关题目

[code](./examples/42-binary-problem.rs)

[code-robot](./examples/42-binary-problem-robot.rs)

大流程

1. 估计**最终答案可能的范围**，可以粗略，不影响二分效率
2. 分析**问题的答案**和**给定条件**之间的**单调性**
3. 建立一个`f`函数，答案**固定**（二分的中点）判断给定答案是否满足条件
4. 不断二分搜索，直到找到合适的答案

2、3步是关键点

### 爱吃香蕉的珂珂

问题描述：给定一个数组表示每个位置有一堆香蕉，koko吃香蕉的速度为`k`，在管理员离开的`N`小时中，koko会从0位置开始吃香蕉，在任意位置它吃完香蕉如果还有空余时间（如果只有6个香蕉，`k`为4，也需要2个小时），问koko的可以在管理员离开的时间吃完香蕉的最小速度

解法：最小速度这个答案的范围是可以想到的，即最慢是`0`，如果没有香蕉，那么满足条件，最快是`max(banana)`，因为速度再快，它在一堆香蕉上也至少要待1个小时。所以答案需要在`[0~max(banana)]`上寻找，满足条件判断的函数是在`k'`速度下，吃完所有香蕉的时间，如果时间够，那么记录答案，降低速度，如果时间不够，那么提高速度继续测试

时间复杂度`O(N*log(max(banana)))`，空间复杂度`O(1)`

### 分割数组的最大值（画匠问题）

问题描述：（使用画匠问题描述）有`k`个画家，有`N`幅作品，每个画家可以画连续的`x`幅画（`x>=1`），问如何划分可以让每个画家画的画消耗的染料加起来最少（每幅作品需消耗`y`份染料，`y>=0`）

解法：因为答案要求累加和的最小值，那么累加和的范围可以得到`0<=sum<=sum(paint)`，因为如果每幅作品都不需要染料，那么累加和最小就是`0`，最大也就是1个画家全部画完所需要的染料。在这个范围上，我们一定可以找到最小的累加和是多少，然后看分配的画家是否够给定的`k`，如果够，就记录答案，降低累加和（需要画家更多），如果不够，不记录答案，提高累加和（画家更少）

时间复杂度`O(N*log(sum(N)))`，空间复杂度`O(1)`

### 机器人跳跃问题

问题描述：机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为`i`的建筑的高度为`H(i)`个单位。起初，机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第`k`个建筑，且它现在的能量值是E, 下一步它将跳到第个`k+1`建筑。它将会**得到或者失去**正比于与H(k+1)与E之差的能量。如果`H(k+1) > E`那么机器人就失去`H(k+1) - E`的能量值，否则它将得到`E - H(k+1)`的能量值。游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏

解法：答案要求的是需要多少能量值才能成功走完所有建筑，那么这个答案的范围是`[0, max(build)]`，因为它自己的能量如果越少，它每经过一个建筑就回扣能量越多，回能量越少，而它能量越多，就会扣能量越少，回能量越多，如果它的初始能量就是建筑高度最大值，它一定能经过所有建筑，所以我们只需要在这个范围内寻找机器人最少需要的初始能量即可

⚠️因为能量累计的速度非常快（`2^N`），所以要注意，如果机器人在某个建筑前它的能量已经达到或者超过建筑最高高度，那么直接返回可以完成游戏即可

时间复杂度`O(N*log(max(height)))`，空间复杂度`O(1)`

### 找出第K小的数对距离

问题描述：给定一个数组，定义数对距离是任意两数差值的绝对值，然后求第K小的数对距离

解法：本题答案求的是数对距离，那么数对距离的范围是`[0, max-min]`，因为是绝对值，所以最小值不可能小于0，最大值也不可能大于`max-min`。在这个范围上，给定一个值，要求一个验证函数返回小于等于这个值有多少个数对，如果这个值大于要求数对数，那么缩小范围，否则增加范围

验证函数的实现需要对数组进行排序，由于数对距离是后数减去前数，那么排序后数组后数减前数一旦超过限制，前数就不需要再进行后续计算，这里使用一个窗口实现

时间复杂度`O(N*log(N) + log(max-min)*N)`，空间复杂度`O(1)`

### 同时运行N台电脑的最长时间

问题描述：给定一个数组表示电池电量，给定一个电脑台数`N`，问这些电池最多能供这些电脑同时最长运行多长时间

解法：最长运行的时间是有范围的，即`[0,sum(battries)]`，那么在这个范围上，给定任意一个时间，需要一个函数来判断电池是否能满足这些电脑同时供电这么长时间，这里有一个“碎片电池”的结论，即如果电池电量小于需供电的分钟数，那么它就是碎片电池，且如果电池数组中全部都是碎片电池的话，如果它们的累加和是大于等于*供电分钟数✖️电脑台数*，那么它们可以完成供电。单调性体现在，如果长的分钟数可以满足，那么短的分钟数一定可以满足（更容易），那么找更长的分钟数即可

优化方案：初始情况下，如果*所有电池的累加和 > 所有电池的最大值✖️电脑台数*，那么可供给的最大时间`t >= max`，这个时间就是`t = sum/num`，因为时间一旦超过最大值，所有电池都成为了碎片电池，有`sum(batteries)=t*num`，否则，可供给的最大时间也不会超过`max`，可以缩减二分范围

### 计算等位时间

> 谷歌面试题

问题描述：给定一个数组，表示`N`个服务员的接待一个客人所需的时间，然后给定`M`个客人，问当M个客人接待完后多长时间开始接待自己。服务员为`10^5`级别，客人为`10^9`次方级别

关键点：虽然服务员的接待效率各不相同，但是因为他们是空了立马接待顾客，所以自己被接待的时间点与之前的客人选哪个服务员进行服务无关

解法1：使用小根堆解决，每个服务员变为`(a,b)`的形式存入堆中，`a`表示自己的服务时间点，`b`表示自己的服务效率，那么只需要遍历完所有的客人，下一个弹出的服务员的服务时间点就是自己接受服务的时间。每次弹出后都是当前时间点更新为服务后的时间点再重新进堆。这种方式的时间复杂度为`O(M*logN)`，并不优秀，适合对数器验证

解法2：答案要求自己何时被接待，那么这个答案的范围是`[0, min(efficacy)*M]`，如果没人或者直接有空闲服务员，那么自己可以直接被接待，如果只有那个效率最高的服务员工作，那么自己在`min(efficacy)*M`之后也可以被接待。除此之外还需要定义一个函数，求给定时间内，M个人是否能被服务完，如果可以，那么记录答案，缩短时间，否则增大时间。这个函数的定义是，给定时间每个服务员的工作效率都是可以接待`t/efficacy+1`，因为可以整除也会再多来一个人。时间复杂度`O(N*logM)`

### 刀砍毒杀怪兽

> 大厂笔试真题

问题描述：一个怪兽有`M`点血量，给定两个数组为两种攻击方式，刀砍为直伤，当前回合收到伤害，毒伤为buff，下回合开始受到无限期累计伤害，问最少多少个回合将怪兽杀死

解法：这道题正面做决策很难，因为每次做决策都没有预期，所以可以先将答案的范围定出来使用二分，答案的范围就是`[1,M+1]`，因为怪兽至少需要一回合杀掉，如果刀砍伤害够即可，或者至少`M+1`回合，只要每回合掉1血，最多也就是`M+1`回合怪兽死。那么只要定义一个函数，判断给定任意回合，是否可以将怪兽打死，如果可以，记录答案减少回合数，如果不可以，增大回合数。判断的方式就是，因为已经给定了回合数，那么只要判断当前回合哪种伤害高就选用哪种攻击方式。时间复杂度为`O(N*log(M+1))`，其中`N`是回合数

## 单调栈

[code](./examples/43-monotonic-stack-problem.rs)

[code-monotonic-stack](./examples/43-monotonic-stack.rs)

[code-monotonic-stack-lg](./examples/43-monotonic-stack-lg.rs)

[code-eat-fish](./c/eat-fish.c)

使用数组实现的栈的操作的常数时间比语言（标准库）中实现的常数时间更好

### 单调栈经典用法解决的问题

在一个**无重复元素**的数组中找到任意位置元素它左右两边的小于/大于该元素且离它最近的元素，正常遍历的时间复杂度是`O(N^2)`，使用单调栈可以在`O(N)`复杂度完成

构造单调栈的流程（数组中无重复值，且以寻找左右两边小于值并且距离最近为例）：

1. 创建一个栈，规定栈顶元素一定大于栈底元素
2. 遍历原数组，插入第一个元素（进栈的是索引）
3. 从第二个元素开始，如果这个元素值比栈顶元素大则直接入栈
4. 如果元素值比栈顶元素小，那么栈顶元素的左右两端值可以计算
   1. 弹出元素，比它小且在左边离它最近的是下一个栈顶元素（索引）
   2. 比它小且右边离它最近的是准备入栈的元素
5. 重复3-4过程直到遍历完成原数组
6. 清空栈，过程中栈顶元素的左边离它最近且小于它的元素是下一个栈顶元素，如果没有为`-1`，右边离它最短且比它小的元素不存在记为`-1`

如果要寻找左右两边大于值且距离最近只要制作一个栈顶元素比栈底元素小的栈即可

简单证明过程：

1. 左边距离当前栈顶元素最短且小于它的值一定是下一个栈顶元素
   1. 对于`a->b`，如果中间还存在元素，它的取值范围有三个
   2. 如果`x<a`，那么`x`一定不存在，因为`x`会使得`a`已经被弹出
   3. 如果`x>b`，那么`b`会让`x`弹出，`x`不会存在
   4. 如果`a<x<b`，那么`x`这个数一定存在于栈中，也不可能
2. 综上`b`的下一个栈顶元素`a`就是距离它最近且小于它的元素
3. 右边距离当前栈顶元素最短且大于它的值一定是待入栈元素
   1. 栈顶元素被弹出的唯一可能就是碰到比它小的元素，所以当栈顶元素要被弹出时，待入栈元素一定是右边第一个比它小的元素

求解过程中，单调栈所有调整的总代价为`O(N)`，单次操作均摊为`O(1)`，因为原数组所有元素均只出入栈1次

如果数组中存在重复元素，寻找左右**严格大于/小于**任意位置元素，构建单调栈的流程：

和无重复元素的构建栈方式类似，只是当待入栈元素和栈顶元素的值相同时，需要弹出栈顶元素，并且弹出的栈顶元素的右边距离它最近且小于它的数暂时记为待入栈元素，然后将待入栈元素入栈

在处理完所有元素之后（包括清空栈的过程），逆序遍历结果数组，如果每个位置元素的右边距离它最近的小于它的数等于自己，那么根据记录的这个元素的位置去结果中找到对应结果更新到自己的结果中

#### 单调栈模版题

把逻辑实现一遍

⚠️问题可能会出现在值的比较和索引与值的映射关系上，细心为主

#### 每日温度

问题描述：给定一个数组表示每天的温度，问在每天最少隔多少天温度升高，如果不升高就是`0`

解法：构造一个求距离最短的大值的小压大的单调栈。这道题对于相等元素可以直接进栈，因为它只关心右边的值。可以省略清算阶段，因为最后剩下的温度都是右边没有更大值的，默认为`0`即可

#### 子数组的最小值之和

问题描述：给定一个数组，求每个子数组的最小值的和

解法：如果直接把所有的子数组得到找最小值再相加时间复杂度会爆炸。因为题目要求每个子数组的最小值，那么可以求任意位置，以该位置为基点，两边距离最近的最小值，这样就得到了一个`[left-cur-right]`的范围，其中的`cur`是最小值，并且`(cur-left)*(right-cur)`个子数组的最小值都是`cur`，计算当前结果即可。对于相等的数可以弹出栈，虽然被弹出的元素可能会少算右边比它小的部分，但是当后面的相同元素被弹出的时候，这部分计算都会被修正

题目要求数据量很大，要使用**同余原理**！！

#### 柱状图中最大的矩形

问题描述：给定一个数组，每个元素表示在坐标轴上的一条垂线，问可以组成的最大矩形面积是多少

解法：对于任意一点，包含它的最大矩形面积是找到两边距离最短比它小的值，那么中间部分就是它的面积。本题中对于相同高度的元素，也可以直接弹出栈顶元素，因为栈顶元素少算的部分（当前元素之后可能的较小的值）在弹出最后一个相同值元素的时候一样会算到，最终计算结果会被修正

#### 最大矩形

问题描述：给定一个二维数组，其中的元素值只为`0`和`1`，问只包含1的最大矩形的面积是多少

解法：需要掌握一个**数组压缩技巧**，对于任意一行，以它为底的矩形面积是可以通过类似上一道题的直方图面积求出来，当到达下一行，只需要把上一行的非`0`数累加下来，继续计算即可

对于`N*M`大小的二维数组，时间复杂度是`O(N*M)`

### 单调性更宽泛的用法

在很多问题中单调栈还可以**维持求解答案的可能性**

1. 单调栈的对象按照**固定好的单调性**来组织
2. 当某个对象进入单调栈时，会从栈顶依次**淘汰对后续求解答案没有帮助的对象**
3. 每个对象从栈顶弹出时，**结算当前对象参与的答案**，随后这个对象不再参与后续求解答案的过程
4. 实际上是**先分析题目**，**发现单调性**，再**利用单调栈的特征**来实现

#### 最大宽度坡

问题描述：给定一个数组表示当前位置高度，对于任意两个不同位置`(i, j)`，如果`h[j] >= h[i]`就认为这两个位置构成一个坡，求最大的坡的宽度

解法：所有可能的答案的左边界以从大到小的顺序入栈（需要维护所有答案的可能性），然后从右到左遍历数组，如果当前位置高度大于等于栈顶元素，那么弹出栈顶元素并结算其答案，因为这种情况一定是栈顶元素可能构成的坡的最大宽度，以后它也不用再参与计算

#### 去除重复字符的最小字典序

问题描述：给定一个字符数组，问如何去除重复字符（每种字符至少保留一个）之后得到的字符串的字典序最小

解法：答案要求字典序最小，所以栈底的字符应该更小（栈的顺序是大压小，方便最后直接返回），那么当新的字符进栈的时候，如果它大于栈顶字符可以直接进栈，如果等于栈顶字符可以直接忽略（替换无意义，其实只要栈里存在此字符就可以忽略，因为即便它入栈，也还是会替换到同一个字符在栈中的位置，且还需要把之前所有的字符弹出，所以还需要一个记录字符是否入栈的表），如果小于栈顶元素，那么要判断判定元素能不能被移除，这里就需要一个词频表来记录每种字符后面还剩多少个，如果值为`0`，那么不能移除，当前字符入栈，否则可以移除后再入栈当前字符，因为被移除的字符后面还可能再进栈

#### 大鱼吃小鱼

> b站笔试题

问题描述：给定一个数组表示鱼的重量，并且规定每条鱼可以吃它右边重量比它小的最近的鱼，问几轮后鱼的数量会稳定。一条鱼可以被重复吃，且每一轮所有的吃鱼行为是同时进行的

解法：从右往左遍历鱼的重量，入栈时如果是第一条或者比栈顶鱼的重量小，那么以`(weigh, turns=0)`入栈，这里的`turns`表示当自己被吃的时候，还需要几轮才能把自己的吃鱼过程走完。那么当自己比栈顶鱼的重量大时，栈顶鱼出栈，吃栈顶鱼要1轮，栈顶鱼自己的工作时间`x`轮，那么入栈的鱼的轮数就是`max(0+1,x)`，直到没有鱼可吃，最终栈顶鱼的轮数就是答案，因为此时鱼的数量稳定。**每条鱼的工作轮数（吃其它鱼）都会累积**，所以统计的是同时进行的吃鱼行为的轮次

#### ⭐️全是1的矩形个数

问题描述：给定一个二维数组，其中只包含`0`或`1`，求仅包含`1`的矩形的个数

解法：和上面求最大矩形面积类似，这道题也可以通过求一维数组（直方图）来扩展求二维数组的情况。如果只是求一个直方图中所有的矩形个数，可以利用上面的解答方式，对于任意位置，找到它左右两边距离最短的最小值，然后只需要计算出它当前位置在两个最小值的最大值之上部分构成的矩形数量，这里注意，低于这个值的矩形个数是不需要计算的，因为在更低的位置，会计算这些矩形，计算矩形个数的公式有（以`x`为底且高为`h`的矩形有几个矩形）`x*(x+1)/2`，这个公式表示的是高固定后，底边长度的可能范围。如果碰到相等高度的位置，那么弹出的位置不计算，因为弹出部分涉及到的矩形在最后一个相同位置一定会被计算。对于二维数组的计算方式，只要以每一行做底求出所有的矩形个数即可

这道题的单调性是任意位置的高计算它包含的矩形只需要找到左右距离它最近且最短的高的两个位置，并且更低的位置不需要在当前位置计算，当前位置只需要计算和它关系唯一的矩形即可

时间复杂度`O(N*M)`

## 单调队列

[code](./examples/44-monotonic-queue-problem.rs)

[code](./examples/44-flowerpot.rs)

### 单调队列经典用法解决的问题

单调队列是用来维持窗口中的**最大值/最小值**，具体流程如下（以最大值为例）

1. 准备一个双端队列，窗口从`[0, 0)`开始
2. 窗口右边进入新元素时，该元素从队列尾部进入，此时窗口`r++`，队列头部开始维持窗口最大值
3. 如果新元素比队尾元素小，那么将小于（等于）新元素的所有队尾元素全部从尾部出队，然后尾部入队新元素
4. 如果窗口左边弹出元素`l++`，如果弹出元素是队头元素，那么弹出队头元素，否则不动

原理：单调队列中总是存储所有可能成为窗口的最大值，因为队列在增加元素的时候，如果后面的更大值进去，那么前面的更早过期的更小值不可能成为窗口的最大值，所以都出队，左边弹出的时候，如果不是更靠前的最大值被弹出队列就不变更，所以队列中永远都是在窗口滑动过程中最大值的可能性，并且这个值是**队头元素**

如果是最小值，那么队列应该是从小到大排列，新增元素如果小于队尾元素就弹出所有大于（等于）该元素的队尾元素弹出

总的时间复杂度是`O(N)`，均摊时间复杂度（队列）是`O(1)`，因为所有元素进出队列都只有一次

#### 单调队列模版题

问题描述：给定一个数组，有一个`k`长度的窗口从头开始滑动，一次移动一个单位，把所有的窗口最大值返回

解法：利用单调队列的基本实现可以得到答案。注意索引的对应，以及答案数组的长度`len-k+1`

#### 绝对差不超过限制的最长连续子数组

问题描述：给定一个数组，给定一个限制，问在数组中所有子数组中最大值和最小值的差不超过限制的最长子数组的长度是多长

解法：首先确定答案的单调性，对于任意一个子数组，它的最大值和最小值之差在右边进入新值时，只可能扩大不可能减小，因为最大值和最小值只可能更大和更小（如果新数的值在中间不会影响原来的最大最小值），所以从任意位置开始，到绝对值超过限制（单调增加）的位置为止，就是该位置开头的满足条件的最长子数组，此时将最左边的值移出窗口。对于窗口的最大最小值使用两个单调队列维护，窗口左指针遍历完原数组即得到答案

#### 接取落水的最小花盆

问题描述：给定N滴水的坐标`(x,y)`，表示水滴落下在`x`轴的位置和它的高度。水滴每秒下降1单位，问有一个花盆要放在`x`轴上，使得这个范围的水滴最早落下和最晚落下的时间差**至少**为D的话，花盆最小需要的宽度，如果不存在返回`-1`

解法：和上一道题一样，需要注意的是利用离散化技巧，将所有水滴按照`x`轴位置排序，而不是维护所有`x`的位置。之后只需要从起始位置找出所有的花盆位置以及长度，即可得到答案

### 单调队列更宽泛的用法

和单调栈类似，单调队列可以**维持求解答案的可能性**

1. 单调队列的元素按照某种单调性组织
2. 当某个元素从队尾进入队列时，会从队首或队尾**移除对后续求解答案没有帮助的元素**
3. 每个一旦从单调队列弹出，可以结算有此元素参与的答案，随后这个元素不再参与后续求解过程
4. 仍然是**先对题目进行分析**，继而发现**单调性**，随后用**单调队列的特征**去实现

#### 和至少为K的最短子数组

问题描述：给定一个数组，问所有累加和至少为`K`的子数组的最短长度是多少

解法：利用[构建前缀信息](#构建前缀信息的技巧--解决子数组相关问题)的方式，构建一个前缀和数组表示各个位置的累加和，那么在任意位置，只要可以得到向左扩展最短距离就能满足限制的子数组就是该位置的答案。比如`i`位置前缀和`Sum(i)`，它之前的累加和至少需要小于等于`Sum(i)-k`，那个位置才能满足限制。如果有一个单调队列（从小到大），在前缀和在尾部入队的时候，如果队首元素满足条件，那么应该弹出并记录答案，直到不满足条件，然后判断队尾元素是否小于此元素，因为如果大于该元素，后面的答案到该元素位置如果不符合条件，那么到队尾元素（更靠前且前缀和更大）就更不可能符合条件，所以要将队尾大于该元素的元素都弹出，随后该元素入队

需要注意的是`(0,0)`在0个元素的情况下前缀和为0的元素要入队，可以方便计算，因为在队列空的情况下，如果只有一个元素那么直接入队，就不会被计算了

#### 满足不等式的最大值

问题描述：给定一个数组包含二维平面上的点，根据它们的`x`值排序，给定一个值`k`，返回`yi+yj+|xi-xj|`的最大值且`|xi-xj| <= k`

解法：要求最大值的公式实际上是`yj+xj+(yi-xi)`，那么在任意一点上，往前只需要找`yi-xi`的最大值即可，此时可以使用从大到小的单调队列维护这个值，且新值进入队列的时候如果队首元素过期（`x`的差值超出了范围），那么直接弹出队首元素

#### 你可以安排的最多任务数

问题描述：有一个任务数组，表示每一个任务需要的能力，还有一个工人数组，表示每个工人具有的能力，工人要做任务要求工人能力大于等于任务所需能力，每个工人只能做1个任务。并且额外给了`pills`颗药丸，每颗药丸可以增强1个工人`s`能力，且一颗药丸只能用一次。问在这个条件下最多能完成多少任务

解法：这道题关键在于任务如何做，需要利用贪心分析，即用能力最高的工人去做能力需求最低的工作能做完多少。先将任务和工人数组排序，然后使用一个双端队列，从能力最小的工人开始，查看他能做多少任务，任务进队列，如果队列不为空，那么做一个任务，开始找下一个工人，如果队列为空，那么用一颗药丸，继续让任务入队，此时为了**让药丸物尽其用**，如果队列不为空，这个工人要做能力需求最高的任务，直到工人在任何条件下都做不了任务结束

注意：**这道题直接在整个范围用贪心不行！**因为在尝试过程中很可能前面能力低的工人直接把整个过程停掉，导致后面能力高的工人无法尝试，所以在大问题上应该使用[二分答案法](#二分答案法与相关题目)的方式来寻找可能的任务最大完成数

## 并查集

[code](./examples/45-union-find-problem.rs)

[code](./examples/45-union-find.rs)

[code](./examples/45-union-find-lg.rs)

> 带权并查集，大厂笔试/面试冷门
>
> 可持久并查集、可撤销并查集，比赛级别

并查集是一种数据结构，它由一些小的集合组成，并且提供以下操作接口

```rust
/// 查找ele元素所在集合的代表元素
fn find(ele: &Element) -> Element;
/// 判断ele1和ele2是否属于同一个集合
fn is_same_set(ele1: &Element, ele2: &Element) -> bool;
/// 将ele1和ele2所在的集合联合起来
fn union(ele1: &Element, ele2: &Element);
```

并查集的性质：提供的操作的时间复杂度均摊之后为`O(1)`

每个集合都是一个单链表，尾节点会指向自己

1. `find`：从参数指定的元素遍历查找，直到尾元素，最终返回尾元素
2. `is_same_set`：从两个参数指定的元素遍历查找，如果它们的尾元素相同，则属于同一个集合，否则不属于
3. `union`：将长度更短的链表的尾节点指向更长的链表的尾节点

实现方式

使用两个数组`fathers`和`size`，表示初始情况下每个元素属于只包含自己的集合和集合大小，对于`union`方法，相同大小的集合默认前一个集合连接到后一个集合，即将前一个元素的尾元素（`fathers`数组中`i`位置的元素）改为后一个集合的代表位置（`j`位置），然后修改后一个集合的`size`大小，此时前一个集合的`size`成为脏数据，不再使用

优化点，都在`find`过程中进行

1. 总是长度小的集合往长度大的集合上连接（可以不做，论文中的秩的概念）
2. 在`find`的过程中，如果寻找链路很长，查找到之后需要把链路上元素的指向全部更新为指向最终的尾元素。即“扁平化优化”（必须做）

时间复杂度的理解，感性理解所有的操作时间复杂度都是`O(1)`，因为即便合并出一个很长的集合链，在查找时，更长时间也只需要一次，因为有路径合并的优化，后续就会缩短为`O(1)`。实际上时间复杂度为`a(N)`，阿克曼函数，当`N`足够大（10^80），返回值不超过6

小挂大的优化粗略想，我们认为长度更长的集合链高度会更高，长度短的集合链高度更低，所以小挂大是为了尽量不再增长集合链的高度

### 情侣座位分配问题

问题描述：已知有`N`对情侣，它们会随机坐在一个数组中，如果要让所有的情侣都坐在一起（相邻），至少需要移动几次（每次移动一对人）

解法：有一个前提是，如果在一组情侣中，有`K`对情侣，他们不坐在一起，那么调整好需要`K-1`步，那么解题只需要遍历一遍情侣，如果他们属于一对情侣，则不做处理，否则将他们所属的情侣对数合并，最终查看有几个组，每个组减1相加就是结果

优化点：因为结果是`Sum(GroupN-1)`，且`Sum(Group)`就是总情侣对数，则答案直接使用总情侣对数减去组合出的组数

时间复杂度`O(N)`，只需要遍历一次情侣数组

### 相似字符串

问题描述：给定一个字符串数组，里面都是相同字母的异序词（anagram），即相同数量的字符排列构成的字符串。如果两个字符串只需要调整两个（不同）字符的位置就完全一样，那么认为这两个字符串相似，而相似的字符串应该放到一组中，并且相似有传递性，那么最终会分几组

解法：这道题将总的组数构造成一个并查集，然后遍历所有字符串的组合，判断是否相似，如果相似就分组，最后将组数返回即可。判断两个字符串是否相似的函数，只需要判断两个字符串相同位置的不同字符数量不超过2即可

时间复杂度`O(N^2*M)`，因为需要遍历任意两个的字符串的组合，判断是否相似需要遍历字符串本身（长度为`M`）

### 岛屿数量

问题描述：给定一个二维数组，只包含`0`和`1`，已知任意一点的上下左右包括自己都是`1`，那么可以组成岛屿，问这个数组可以组成几个岛屿

解法：本章使用并查集的方式解题。即遍历所有点，将每个点并入它上下左右为`1`的点的集合，直接忽略所有的`0`点，最后查看有多少个集合。这里需要对二维数组中的点编码成线形点，即`[x,y]`处的点转化为`x*col+col`

优化点：每个点只需要遍历上方和左边即可，因为下方和右边的点在后续遍历中会处理

时间复杂度为`O(N*M)`，遍历完所有的点即可

### 移除最多的同行或同列石头

问题描述：给定一个石头数组，表示每个石头的二维坐标，如果两块石头属于同一行或者同一列，那么可以移除一块石头，问最多可以移除多少块石头

解法：这道题中有一个结论，即同行同列的所有石头集合中，通过从边缘到中心的消除顺序，最终一定只会剩下1个石头。那么只需要把所有的石头集合找出来，然后用总石头数减去集合数量就是要被移除的石头数。因为整个坐标系比较大，而石头比较小，在合并集合的时候可以利用两个哈希表来保存石头的`x`和`y`坐标，如果每个`x`或`y`坐标出现了其它的石头，那么就进行合并

时间复杂度为`O(N)`

### 找出知晓秘密的所有专家

问题描述：初始状态下有`N`名专家，其中第`0`名专家知晓一个秘密，并且最开始会将这个秘密告诉一个指定专家，之后每个时间点会开`groupm`场会议，如果会议有知道秘密的专家参与，那么参加会议的另一个专家也会知道。每个专家同一时间可以参加无限场会议，如果某个时间点开完会议后，专家不知道秘密，那么之后仍旧不知道秘密，如果知道秘密，之后就一直知道秘密，问最终有多少专家知道秘密

#### 经典并查集的扩展用法

类似于小挂大时使用的`size`数组，可以保存每个集合的大小，还可以定义其它类似的标签数组来表示某个集合携带的额外信息，这个信息一般在`union`过程中需要被更新

本题解法：先对会议根据时间排序，每次处理一个时间点上的多个会议，参与会议的两名专家需要合并成一个集合，并且如果任意一名专家知道秘密，应该更新两名专家都知道秘密。处理完会议后，所有不知道秘密的专家需要将自己的所属集合撤销，即自己为单一集合。最终统计所有知道秘密的专家即可

时间复杂度为`O(M*logM + M + N)`

⚠️最终统计哪些专家知道秘密的时候，应该用`find`查找专家所属集合的代表专家是否知晓，而不能直接统计秘密数组，因为秘密数组里有大量的**脏数据**，这种标签信息数组都是类似的

### 好路径的数目

问题描述：给定一棵树，每个节点都有一个值，定义好路径的概念，即任意两点如果它们的值相同，且它们之间的节点全部都是小于等于两个端点的值，则这条路径为好路径。每个点本身都是一条好路径。问一棵树总共多少条好路径

解法：最关键的点在于对边处理顺序的排序，每条边的值取决于它两个端点的值的最大值，然后按从小到大顺序对边进行排序，排序后每条边的处理方式是，如果两个点各自所在的集合的最大值相等，那么两个点各自集合最大值的个数相乘就是生成的好路径的条数，然后合并两个集合，且**最大值小的要挂到最大值大的上面**，直到所有的边处理完，再加上节点个数就是答案

因为先处理的是值比较小的边，所以到后面处理最大值较大的边时就不需要考虑这些值更小的边，而值小的边也会被中间值更大的边隔开而不会算重复

时间复杂度为`O(N)`

### 尽量减少恶意软件的传播II

问题描述：给定一个图（使用邻接矩阵的方式表示）和一些被感染的点的位置，问去掉哪个感染点可以拯救更多的普通点，题目中是一个无向图，即一个点可以感染整个图，可能会有额外的点

解法：这道题的前提是，如果一组普通点构成的图外接了两个感染点，那么这个子图一定不可能被拯救

1. 将所有的普通点合并成子图，并且需要记录每个子图的外接感染点和集合大小（当前步骤不设置），这是并查集的标签信息
2. 遍历所有感染点，每个感染点找接触的普通点子图，并更新子图的外接感染点信息
   1. 初始感染点为`-1`
   2. 如果之前没有感染过，设置感染点为当前值
   3. 如果感染过，判断是否与当前值相同（因为一个普通子图集可能有多个点跟感染点接触）
      1. 如果相同，忽略
      2. 如果不相同，设置为`-2`，即这个子图外接超过1个感染点
   4. 如果感染过，且已经为`-2`，那么直接忽略
3. 将所有感染点去掉可能拯救的节点数统计起来
4. 排序感染节点，并开始遍历，返回索引更小且拯救节点更多的感染节点

时间复杂度为`O(N*N)`，即遍历图的时间

## 洪水填充

[code](./examples/46-flood-fill.rs)

洪水填充是一个简单的技巧，设置路径信息进行**剪枝**和**统计**，类似感染过程

**路径信息**不撤销，保证每一片感染区域可以被区分

虽然是暴力递归，但是洪水填充的时间复杂度很优秀，遍历次数和样本数量规模一致

### 岛屿问题

问题描述：跟[岛屿问题（并查集）](#岛屿数量)相同

解法：对于任意一个可能成为岛屿的点，使用一个函数去查看它的上下左右点，在查看前将它本身设置为其它数值并且统计岛屿数，直到所有点遍历一遍

时间复杂度依旧是`O(N*M)`，因为遍历每个点需要单位时间，且每个点最多被查看函数访问4次（上下左右），即每个点的遍历次数跟问题规模无关，所以不影响整个时间复杂度

### 被围绕的区域

问题描述：整个区域包括`X`和`O`两种格子，如果`O`是被`X`包围的格子（上下左右），那么可以被改为`X`，问改完之后的区域是什么情况

解法：如果`O`构成的区域没有被`X`包围，那么表示在区域边缘一定有一个`O`，所以可以从边缘的`O`开始将所有连接的`O`感染成其它字符（例如`F`），那么剩下的`O`就都是被`X`包围的`O`，将它们全部修改，最后再把未被包围的`F`修改为`O`即可

时间复杂度是`O(N*M)`

### 最大人工岛

问题描述：给定一个二维矩阵只包含`0`和`1`，相互连接的`1`（上下左右）构成岛屿，问将哪个`0`修改为`1`之后整片区域的最大面积的岛屿最大，最后返回最大面积

解法：这道题最后还是要遍历所有的海水区域，所以要先将岛屿分区编号，然后看每个海水格的上下左右是哪几个区块，统计每个海水格构成的最大岛屿，最终返回最大值。编号过程使用洪水填充，记录新的岛屿ID

时间复杂度是`O(N*M) + O(N*M) + O(N*M)`

### 打砖块

问题描述：给定一个二维数组，其中包含`0`和`1`，`1`表示砖块，本题的设定是第一行的砖块是稳定的，或者某个砖块的四个方向（上下左右）是稳定砖块，它也是稳定砖块。然后给定一个打击序列，每次打掉一个砖块（如果有），当这个砖块消失后有`x`块砖块掉落，求每次打击掉落的砖块数量

解法：首先假设所有的打击点的砖块都消失，然后从天花板开始洪水填充，此时从后往前复原（时光倒流技巧，最后的变更先处理，之前的被打掉的砖块的影响会被累积，且之前被打掉的砖块不会被计算）被打击的砖块，并统计当此打击影响的掉落砖块。统计过程也是一个洪水填充，即如果打击砖块存在，且它或者是天花板的砖块或者它的附近有稳定砖块，那么需要开始填充
