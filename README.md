# zuo-algo

跟着左程云学算法，练习使我变强

[课程主页](https://space.bilibili.com/8888480)

[课程笔记](https://xuanlee-healer.github.io/zuo-algo-book/)

## 代码目录

- 二进制 [code](./examples/1-bit.rs)
- 三种简单排序 [code](./examples/2-simple-sort.rs)
- 对数器 [code](./examples/3-test-method.rs)
- 二分搜索 [code](./examples/4-binary-search.rs)
- 单双链表和堆栈以及链表题目讲解
  - [code](./examples/5-linked-list.rs)
  - [code](./examples/6-merge-sorted-list.rs)
  - [code](./examples/7-add-two-list.rs)
  - [code](./examples/8-divide-list.rs)
  - [code](./examples/9-queue-stack.rs)
  - [code](./examples/10-queue-stack-converse.rs)
  - [code](./examples/11-min-stack.rs)
  - [code](./examples/12-deque.rs)
- 二叉树及其三种序的遍历
  - [code](./examples/13-binary-tree-iter.rs)
  - [code](./examples/14-binary-tree-noniter.rs)
- 算法笔试中的输入输出处理
- 递归和master公式
- 归并排序
  - [code1](./examples/15-merge-sort.rs)
  - [code2](./examples/15-merge-sort-lg.rs)
- 归并分治
  - [code1](./examples/16-merge.rs)
  - [code2](./examples/16-merge-minsum.rs)
- 随机快速排序 [code](./examples/17-rand-quick-sort.rs)
- 随机选择算法 [code](./examples/18-rand-select.rs)
- 堆结构和堆排序
  - [code](./examples/19-heap-sort.rs)
  - [code1](./examples/20-heap-problems.rs)
  - [code2](./examples/20-max-repeat.rs)
- 哈希表、有序表和比较器的用法
- 基数排序 [code](./examples/21-radix-sort.rs)
- 异或运算的骚操作 [code](./examples/22-xor.rs)
- 位运算的骚操作 [code](./examples/23-bit-op.rs)
- 位图 [code](./examples/24-bitset.rs)
- 位运算实现加减乘除 [code](./examples/25-bit-arithmetic.rs)
- 链表高频题和必备技巧
  - [code](./examples/26-linkedlist-problems.rs)
  - [code-链表相交节点](./c/list-intersection.c)
  - [code-回文结构](./c/list-palindrome.c)
  - [code-拷贝带随机指针链表](./c/list-copylist.c)
  - [code-第一个入环节点](./c/list-cycle.c)
  - [code-链表排序](./c/list-copylist.c)
- 数据结构设计高频题
  - [code-set_all哈希表](./examples/27-ds-setall-hashmap.rs)
  - [code-lru](./c/list-lru.cpp)
  - [code-insert/delete/random](./examples/27-ds-ins-del.rs)
  - [code-median](./examples/27-ds-median.rs)
  - [code-max-freq-stack](./examples/27-max-freq-stack.rs)
  - [code-alloone](./c/list-alloone.cpp)
- 二叉树高频题目 [code](./examples/28-binary-tree.rs)

## 常见经典递归过程分析

[code](./examples/29-recursion.rs)

### 查找一个字符串的所有子串

子串是从一个字符串中任意取不同的字符构成的子串（顺序不变），题目要求所有子串**不重复**

解法：对于任意一个子串，都是对所有字符的选择决策树的一条路径的收集，由于每个决策分为包括此字符还是不包括此字符，所以最终所有结果是一颗完全二叉树

时间复杂度为`O(2^N*N)`，因为所有的可能性的总和是`2^N`种，且生成子串的时间平均也是`N`，所以相乘即为整个过程的时间复杂度

### 查找一个数组中的所有不重复的组合子数组

对于一个数组，其中包含的所有子数组和上一题类似，都是对任意一个元素的取舍做决策，最终结果是对二叉树的路径做去重。因为两个重复的子数组只跟各个元素的值出现的次数有关，所以我们可以先对数组排序，然后相同值的节点为一组，那么结果就变成当前组有`0...n`个时，和后面的不同元素的组合关系，这**避免了对全组合的遍历**。因为最差的情况是所有元素不同，所以时间复杂度也是`O(2^N*N)`，这里用到的技巧是**剪枝**而不是去重，后者依旧会全遍历，但是前者是直接减少遍历情况

**剪枝**是在递归过程中直接去掉明知无效的路径，这道题是通过先排序，将可能重复的情况改变为不可能重复的情况，所以结果不需要再去重

### 一个不含重复元素的数组的全排列

解法：一个数组的全排列可以通过在`i`（`i => 0..n`）位置出现任意值，递归求后续序列的全排列来得到最终答案

#### 包含重复元素的数组的不重复的全排列

解法：在交换逻辑中添加去重逻辑

#### 本题总结

可以利用原数组作为记录每个排列的路径容器，每次递归结束后要**将原数组恢复**，因为下一次递归要求不能被上一次递归的结果影响，如果用额外的空间记录路径那么不需要修改原数组，但是空间复杂度高

时间复杂度为`O(N!*N)`，因为`N`个元素的全排列的数量就是`N!`中，生成每个序列的时间为`N`

### 用递归逆序一个栈

解法：利用递归函数本身有独立的内存空间，可以暂时保存栈中的值的特点，写一个子递归函数，作用是将栈底元素重新加入栈顶，然后再写一个递归函数，重复上述过程并重新压栈，这样实现栈的逆序

时间复杂度`O(N^2)`，因为每次逆序一个元素都要移动栈`N..N-1...`，总共移动`N`个元素

### 用递归排序一个栈

解法：所有方法都是递归实现，同样利用递归函数自己的内存空间来暂时保存栈中元素的特性。首先获取栈的深度，然后搜索栈中的最大值，然后查找最大值的数量，然后将这些最大值压入栈底，并且栈深度减去压入的最大值数量，重复这个动作直到栈深度为0

### N层汉诺塔问题

问题描述：有三根杆子，最左有N个盘子，求将这N个盘子从最左移动到最右的最优路径，并且要满足1）一次只能移动杆子最上层的一个盘子，2）大盘子不能压小盘子（初始盘子从小到大放置）

解法：解决N层汉诺塔问题，只需要转化为`N-1`个盘子先移动到中间，再将唯一的盘子移动右边，最后再将中间的盘子移动到右边即可。时间复杂度为`O(2^(N-1))`，因为`f(N)=f(N-1)+1+f(N-1)=2*f(N-1)`，即消耗时间为等比为2的等比数列，根据通项公式`an = a*r^(n-1)`，a是首项，r是等比得到时间复杂度

## 嵌套类问题的递归解题思路

[code](./examples/30-embed-recursion.rs)

嵌套类问题解题套路

1. 定义**全局变量**`let where: usize = 0`
2. 定义函数`f(i)`，表示从`i`位置开始解析，遇到“字符串终止符”或者“嵌套条件终止”就返回结果
3. `f(i)`的返回结果是自己负责的这一段内的结果
4. `f(i)`在返回前要更新全局变量`where`，告诉上游函数知道自己解析到的位置

执行细节

1. 如果`f(i)`遇到“嵌套条件开始”，那么开始调用下级递归去处理嵌套内容，下级递归负责返回嵌套部分的答案
2. `f(i)`下级递归处理完成后，会更新`where`值告诉本级函数该从什么地方开始解析

本节题的时间复杂度都是`O(N)`，因为只是遍历一次数组

### 含有嵌套的表达式求值

限制表达式只有`+ | - | * | /`的**合法**表达式

如果表达式不带括号，那么只需要准备两个栈，一个是数字栈，一个是符号栈，开始解析字符串，碰到数字后，将数字及后面的符号插入对应栈中，如果是乘法和除法，那么先进行计算再插入，保证符号栈中只有计算序列无关的加减法，到终止符时再加入一个加法（随意）符号，然后开始使用两个栈计算最终的结果

如果表达式带括号，那么对于括号内的内容，可以使用递归的方式计算，每个递归计算和无括号表达式计算方式相同，但是需要一个全局变量`where`来计算下级递归的计算位置，并报告给上级函数

### 含有嵌套的字符串解码

题目描述：`aaa2[bb]c`解码为`aaabbbbc`

解法：和上题相同，碰到`[`开始进入递归

### 含有嵌套的分子式求原子数量

题目描述：对于一个分子式`H2O`，根据不同原子出现的数量打印出来`H20`，如果有圆括号，那么后面一定会跟一个数字

解法：原子符号首字母一定是大写，当碰到原子符号或者`(`时，说明历史统计需要被更新到结果中并且历史统计要被清除，对于`(`内部的原子统计使用递归方法，最终将统计表转换为结果。这里使用`TreeMap`来保证输出按字典序打印

## N皇后问题

[code](./examples/31-n-queen.rs)

题目描述：在一个`N*N`的棋盘上，放置一个皇后之后，它的同行、同列，两条对角线不能再摆放其它的皇后，问在棋盘上摆满N个皇后的可能摆法有多少种

解法时间复杂度为`N!`，因为摆放总可能性是`N*(N-1)*(N-2)...1`

### 数组记录摆放路径的方式

1. 每行摆一个皇后
2. 下一行的皇后摆之前根据之前摆的皇后的位置判断当前位置是否可以摆皇后，对角线判断为`|cur_row-last_row|==|cur_col-last_col|`
3. 如果可以摆，则放到下一列继续尝试
4. 将所有的可能次数累加

这种实现方式的常数时间慢，推荐位运算版本实现

### 位运算方式

使用位信息来记录当前已经放置的皇后和当前行不能放置的皇后的限制

- 列限制，如果位上为`1`，表示该列已经放置皇后
- 右上-左下限制，传递给下一行之前，将限制数右移一位，低位表示前`N`列
- 左上-右下限制，传递给下一行之前，将限制数左移一位，高位表示后`N`列

限制列数可以使用`(1<<N)-1`来计算
使用`N&(-N)`的`Brian Kernighans算法`可以获取可能的位置的最后一位
使用`N^lastN`可以将已经尝试选择的那一位抹去

## 最大公约数和同余原理

[code](./examples/32-gcd-lcm.rs)

### 求最大公约数

辗转相除法（欧几里得算法）计算：`gcd(a,b) = b == 0 ? a : gcd(b, a % b)`，其中`a>b`，时间复杂度是`O((loga)^3)`

`Stein`算法在更大的数的计算上更快，还有**裴蜀定理**

### 求最小公倍数

`lcm(a, b) = a / gcd(a, b) * b`

### 经典题目

题目描述：给定两个数字`a,b`，如果一个数可以被`a`整除，也可以被`b`整除，就是一个神奇数字，求第n个神奇数字

这里用到了“二分答案法”和“容斥原理”

首先这个第n个神奇的数字的范围是`1~n*a`范围内，且`b`的存在只会缩短真正第`n`个神奇数字的范围。如果直接遍历，这个数字可能会非常大，因为最终的结果要对`10^9+7`取模，所以可以用二分查找，如果这个范围内的数字个数小于`n`，那么就往右边找，否则往左边找

### 同余原理

对于大数字的计算，如果利用字符串或者`BigInteger`这种类型表示计算，那么对于`k`位数字，加减操作的时间复杂度从`O(1)`升到`O(k)`，而乘除计算从`O(1)`升到`O(k^2)`，其中固定位数的整数类型`i32`/`i64`的加减乘除模运算的时间复杂度可以认为是`O(1)`

同余原理可以将很大数字的运算最终的取模结果分解到各个子式做取模运算，提升效率，直接用最好两个数都是正数，如果有负数，它自己的模要变为正数再运算

- 加法同余原理：两个结果各自对`m`的取模的结果相加再对`m`取模的结果和两个结果相加对`m`取模相同
- 乘法同余原理：和加法相同，但是要避免溢出
- 减法同余原理：两个结果对`m`取模，做减法，结果加`m`再对`m`取模
- 除法同余原理：需要利用乘法的逆元，暂不提

## 对数器打表找规律的技巧

[code](./examples/33-matcher.rs)

使用场景：输入参数是简单类型，输出参数也是简单类型

1. 暴力解法（不关注时间复杂度）将小范围的问题解决
2. 打印出输入和输出
3. 根据输出找规律，将规律变为代码

### 使用规格8和规格6的袋子买苹果

问题描述：有一堆苹果，只能用6规格和8规格袋子装，问装满苹果至少需要几个袋子，如果没法用袋子装完返回-1

解法：先用暴力递归求解答案，然后总结规律

### 轮流吃草

问题描述：有一堆草，两只羊吃，每只羊每次只能吃4的n次方数量的草，谁先吃完谁赢，给定一个数量的草来判断谁能赢

解法：递归求解，总结规律

### 判断一个数字是否是若干数量(数量>1)的连续正整数的和

问题描述：如题所述

解法：暴力解法，从1开始计算累加和，如果超过给定数字就从2继续，直到起始数字为它自己（数量等于1）

### 好串有多少个

好串：在一个字符串中有且仅有1个长度>=2的回文子串，认为这个字符串是好串

问题描述：用r、e、d三种字符拼接字符串，返回长度为n的所有可能的字符串中，好串有多少个

解法：使用全排列方式找好串，然后找到规律重写

## 根据数据量猜解法

[code-kill-monster](./c/kill-monster.cpp)

[code](./examples/34-guess.rs)

基本事实，C/C++运行1s，python/java/go运行1～2s可以执行的常数级别指令数量级在`10^7~10^8`，那么最好不要超过这个量级的指令，比如问题中的数组长度为`10^6`，那么一个`O(N^2)`的算法明显不会满足时间要求

根据数据量猜解法的前提是

1. 各个入参的最大值和范围给定，这在比赛和笔试中都会提供，面试中需要询问面试官
2. 对于自己设计的算法，可以准确地估计出时间复杂度

数据量和时间复杂度的关系，多的不记，这里主要记录两个

1. `N<11`可以使用`N!`时间复杂度的算法，也就是全排列枚举
2. `O(N*√N)`，时间复杂度比`O(N)`差，在“莫队算法”中会涉及

此外入参不一定只有一个，有些复杂度可能是`O(N+M)`或者`O(N*M)`，要根据数据量来使用某种时间复杂度的算法做，只要卡住时间可以提交成功即可

### 最优技能释放顺序

问题描述：现在有一个打怪类型的游戏，这个游戏是这样的，你有`n`个技能，每一个技能会有一个伤害，同时若怪物低于一定的血量，则该技能可能造成双倍伤害，**每一个技能最多只能释放一次**，已知怪物有`m`点血量，现在想问你最少用几个技能能消灭掉他（血量小于等于0），`n`的范围是`[1,10]`，`m`的范围是`[0~10^6]`

解法：因为`n`的范围小于10，那么直接使用全排列的方式将所有的技能组合列出来，然后挨个测试，最终选择使用技能个数最少的情况

### 超级回文数

问题描述：对于一个正整数，如果它和它开根号后的结果都是回文，那么它就是超级回文数。给定两个数字（使用字符串表示），它们的范围在`[1~10^18-1]`，返回它们中间的超级回文数

解法：两个数字的范围都在`i64`范围内，那么最大数开平方的范围就是`10^9`，如果`10^9`这个数量级的数字是回文，那么它可以利用折半的数字拼出来`[1~10^5]`内的数字，即`1`拼接为`11`，`99999`拼接为`9999999999`，奇数长度的拼接数可以作为限制小于最大值`10^9`进行遍历

一个数字扩展为奇数长度回文：这个数字先除10，在依次模10加到原数字*10的值

一个数字扩展为偶数长度回文：这个数字*10依次加模10的结果

⚠️判断一个数字是否是回文可以认为是一个常数操作

#### 判断一个数字是否是回文

问题描述：负数不是回文

解法1：将数字转换为一个字符数组，然后判断

解法2：得到一个和数字等长的`1`开头的数字，然后这个数字除它就是首数字，模10就是尾数字，然后判断头尾是否相等，然后将原数字头尾去掉，**基本数字除100**

## 前缀树原理和代码详解

[code](./examples/35-trie.rs)

[code](./examples/35-trie-obj.rs)

前缀树也叫字典树，英文名*Trie*。前缀树是每个样本都从头节点开始，根据前缀字符或数字建出的一棵树。特征是如果节点不存在就新建，有就复用此节点

前缀树的使用场景：需要根据前缀信息查询的场景

- 优点：根据前缀信息选择树上的分支，大量节省时间
- 缺点：浪费空间（相对数组实现），因为保存的信息和字符的数量、种类有关
- 定制部分：`pass`、`end`信息

可以使用动态结构（类）实现，也可以使用静态数组实现，比赛/做题应该使用静态数组实现，节省空间

```rust
trait Tier {
    // 初始化前缀树
    fn new() -> Self;
    // 插入一个字符串
    fn insert(&mut self, str: &str);
    // 搜索字符串
    fn search(&self, str: &str) -> Self;
    // 搜索指定前缀的字符串的数量
    fn prefix_number(&self, str: &str) -> Self;
    // 删除一个字符串
    fn delete(&mut self, str: &str);
}
```

## 前缀树的相关题目

[code](./examples/36-trie-problem.rs)

### 接头密钥

题目描述：有一个二维数组，其中的每个子数组都是一个数字列表，每个列表都可以生成一个`[i1-i0, i2-i0...in-in-1]`的数组，此时有另外一个二维数组，它也可以生成这样一个数组，然后得到另一个二维数组生成的数组结果在之前的数组中出现的个数，得到一个结果数组

解法：将前一个二维数组中每个子数组生成的数组构建一棵前缀树，因为每个差值都可以转变为字符串`"number#"`的形式，在遍历第二个二维数组，每个数组生成同样形式的字符串，查看作为前缀在前缀树中出现的次数，组成结果数组

⚠️前缀树中的字符种类除了`0~9`以外，还包括`-`和`#`，此题不能使用数字作为路径是因为数字差值可能会非常大，所以数组空间无法确定

时间复杂度是`O(N*M)*2`，`N`是数组的数字个数，`M`是每个子数组中的最大值的位数。空间复杂度是`O(N*M)`这是树上的节点个数

### 查找数组中两个数的最大异或值

题目描述：对于一个数组中全部是大于等于0的整数，求这个数组中任意两个数的异或结果的最大值。允许两个数自己异或

解法一：因为所有数字都是正整数和0，所以最高为都是0，对于任何一个数，都是要在自己每一位尽量找一个让自己在高位异或结果为1的树。先查看最大数字，对前面的0不建树，然后遍历每个数字，找到和它异或的最大值，然后比较这些最大值得到答案

技巧（保留前n位，后面都变成0）：`num >> (32-n) << (32-n)`

解法二：先找最大值，知道从第几位开始处理。原理是从最高位开始，追求结果从最高位开始每一位是否能为1。

时间复杂度：`O(n*logV)`，空间复杂度：`O(n*logV)`，V是数值范围

### 在二维字符数组中搜索可能的单词

题目描述：给定一组单词（不重复），给定一个只有（有效字母）字符的二维数组，从任意一个字符出发，可以上下左右移动，但是在搜索一个单词的过程中路径中不能有重复字符，问这个二维数组中可以收集到多少单词

对于这个题目，由于单词的最大长度限制是`10`，那么单次查找一个单词是`4^10`种可能，且可以从任意起点开始查找，所以本题的时间复杂度为`O(N*M*4^10)`，这个时间复杂度无法降低，所以考察的是**剪枝**能力

使用前缀树和标记可以对搜索过程进行剪枝

1. 移动过的字符可以标记为`0`，并且回到原位置后要置回
2. 在前缀树的节点上携带字符串内容，表示此处是一个完整字符串，搜索完成后置空
3. 使用`pass`信息保存每个节点的经过数，如果搜索完成就将经过数减去搜索到的字符串，这样搜索前如果碰到`pass`为0的可以认为直接跳过

## 构建前缀信息的技巧--解决子数组相关问题

[code](./examples/37-prefix-subarray.rs)

[code-longest-subarray](./examples/37-prefix-subarray-2.rs)

本节中所有问题需要在`O(N)`时间复杂度下解决

### 快速解决子数组范围求和的问题

构建前缀和数组。在任意范围（`[L,R]`）内求和的计算方法是`S[R+1]-S[L]`，前缀和数组从1开始生效

### 无序数组中，累加和为给定值的最长子数组长度

构建前缀和，最早出现的位置

⚠️子数组一定是连续的

解法：要求最长子数组长度，只要在每个位置找到从该位置往前最长的累加和为目标值的长度即可，可以使用`(求值的累加和-当前位置的累加和)`得到在数组中出现的最早位置

需要使用哈希表来保存每个前缀和最早出现的位置。且需要在哈希表中预先录入`(0, -1)`记录，因为前缀和`0`总是存在，且出现的最早位置在真实索引`0`之前

### 无序数组中，累加和为给定值的子数组数量

和上一题是一样的，只是统计的量从位置变为出现次数

### 无序数组中，正数和负数个数相等的最长子数组长度

将问题转化，将正数转变为1，负数转变为0，那么转变后的数组中求正数和负数个数相等的最长子数组就是和为0的最长子数组，和第二题是相同的，也就是目标数字总是0

### 表现良好的最长时间段

问题描述：给定一个数组，每个元素表示当天工作时间，规定超过8小时为劳累，不超过8小时为舒适，当劳累天数大于舒适天数的时间段就是“表现良好时间段”，求最长时间段

解法：对数组进行转化，大于8小时为1，小于8小时为-1，那么最长的子数组就成为，如果某个位置的累加和大于等于1，则当前位置的最长子数组长度为`(i+1)`，如果这个位置的累加和小于1，那么应该寻找最早出现`loc[i]-1`这个累加和的位置

⚠️由于数组的累加和增减幅度都是1，所以找小于于这个数的累加和的最早位置没有意义，因为它也一定是从大数变化来的

### 移除的最短子数组长度，使得剩余元素的累加和能被p整除

在数组任意位置`i`，向前移除尽量少的元素，使得剩余元素的累加和能被p整除。先求出全部元素对p的余数`rem`，如果`0～i`的累加和对p的余数是`mod`，那么移除元素`j~i`之后`0~i`对p的余数应该是，如果`mod > rem`，`i~end`的余数是`(rem+p)-mod`，所以`0~j`的余数是`p-((rem+p)-mod)`，就是`(mod-rem)`，如果`mod < rem`，`i~end`的余数是`rem-mod`，`0~j`的余数就应该是`p-rem+mod`，这两个数都等于`(p-rem+mod)%p`

哈希表要记录累加和余数出现的最晚位置，保证删除最短数组

⚠️求余数使用同余原理（加法），同余原理求累加和的余数，**前面数字对p取余的结果加上当前的数字，结果对p取余等于当前数字累加和对p取余**

### 每个元音字符，返回达标子串最大长度

题目描述：在一个子串中，如果元音字符出现字符都是偶数个，那么这个子串为达标子串

解法：对元音字符的奇偶频率做记录，将`aeiou`出现偶数次编码为`00000`，除了这种情况外的所有情况都不是达标子串。那么在`0~i`位置，如果子串情况是一个数值，那么只要查找`0~j`范围内奇偶频率也是这个值最早出现的位置

关键在于对前缀信息的表示，可能是编码、转化等！

## 一维差分和等差数列差分

[code](./examples/38-difference.rs)

[code-difference-arithmetic-procession](./examples/38-difference-arithmetic-procession.rs)

[code-difference-arithmetic-procession-2](./examples/38-difference-arithmetic-procession-2.rs)

### 一维差分

对于一个一维数组（**所有元素为`0`**），如果有一组对此数组的操作，比如在某个范围上对数组的每个元素加一个值，如果操作数很多，那么我们希望有一种低成本方式将这些操作都应用到数组后，再经过一次统一处理得到答案。这种方法就是一维差分

将所有的操作`[L~R]`上加`v`转化为`arr[L]+=v,arr[R+1]-=v`，最终将每个元素更新为它位置的累加和，完成操作。原理是在范围开始位置加上的值在计算累加和的过程中总是会携带，直到范围结束的位置，把额外加的值减掉即可

### 等差数列差分

和一维差分类似，不同点在于`[L~R]`范围内加上一个`S,E,D`的首项、末项、公差的等差数列而不是相同的值

等差数列的差分数组处理过程如下，依旧是利用前缀和求最终结果，倒推两次得到原始的差分数组处理公式

```rust
/// 在L～R过程中加上S、E、D的等差数列
/// 最终结果 0 0 S S+D S+2D S+3D S+4D(E) 0 0
/// 中间过程 0 0 S D   D    D    D      -E 0 （比之前增量更大的增量）
/// 起始过程 0 0 S D-S 0    0    0      -E-D E  （原始差分数列）
arr[L] += S;
arr[L+1] += D-S;
arr[R+1] -= (E+D);
arr[R+2] += E;
```

在原始的差分数列求两边前缀和就是最终的结果

#### 等差数列差分数组例题

问题描述：有水平面，默认是0，每一个人都有自己的体积V，和水平位置X，当人从X掉入水中时，会形成波纹，向左向右形成波峰，问N个人落水后水平面在所有位置的值

解答：对于每个人落水的情况，都会从左到右生成4个等差数列，所有人落水的情况会叠加，使用等差数列差分数组解决问题

⚠️因为每个人落水位置都有可能接近两边，所以可以使用`OFFSET`方式来避免边界条件判断

## 二维前缀和、二维差分、离散化技巧

[code](./examples/39-two-dimensional-dif.rs)

[code-two-dimensional-mode-newcoder](./examples/39-two-dif-newcoder.rs)

[code-two-dimensional-mode-lg](./examples/39-two-dif-lg.rs)

### 二维前缀和

解决的问题：对于一个二维数组，给定左上角点和右下角点`(a,b)`和`(c,d)`，可以直接得到这个区域的累加和，并且在`O(1)`的时间复杂度实现。所以要对原数组进行处理得到一个结构

构造这个结构的方式，是将每个`(x,y)`点的元素更新成`arr[x,y-1]+arr[x-1,y]-arr[x-1,y-1]+arr[x,y]`，计算方式应用了容斥原理，因为更新顺序是从上到下、从左到右，所以每个元素左边和上边的元素已经表示了从`(0,0)`到该点的累加和，那么加两次会有一个重叠区域，减掉重叠区域就是该点以外元素的累加和

在构造好的结构上求解累加和的公式是`Sum((a,b), (c,d)) = Sum(c,d)-Sum(c,b-1)-Sum(a-1,d)+Sum(a-1,b-1)`，计算方式应用了容斥原理

实际应用中通常会将原数组包裹一层`0`，以避免边界条件判断

#### 二维前缀和例题

边框为1的最大正方形：给一个由若干0、1组成的二维网格grid，找出边界全部由1组成的最大正方形网格，返回该子网格中的元素数量，如果不存在返回0

解法**唯一**：遍历所有的点，在点上构造所有可能的正方形，然后判断这个正方形是否符合条件，它的时间复杂度是`O(N*M*min(N,M))*4`，可以优化的点在于验证过程的时间，从4条边的4次优化为1次，也就是使用前缀和的方式`Sum((a,b), (c,d)) - Sum((a+1,b+1), (c-1,d-1)) == (k-1) << 2`验证，其中还有剪枝的过程，就是如果找到了更大边长的正方形后在其他点不再查找更小边长的正方形

本题直接使用原二维数组构造前缀和数组，节省额外空间使用

### 二维差分

二维差分数组和一维差分数组解决的问题类似，在一个二维数组中，如果多次对范围左上`(a,b)`到右下`(c,d)`中所有的元素加/减一个值，得到最终结果的过程使用多次设置二维数组，最终处理为结果数组的方式

每次在`(a,b)`到`(c,d)`范围内增加一个`v`值时，对`arr[a][b]+=v`，`arr[a][d+1]-=v`，`arr[c+1][b]-=v`，`arr[c+1][d+1]+=v`，最终将二维数组更新为二维前缀和数组

直观理解：当`(a,b)`点加（减等效）一个值后，它对于到最右下位置的范围都有`+v`的影响（因为最终要求前缀和），所以在目标边界的右和下都减去`v`，此时，`(c,d)`到右下位置会被减两次（`a,b`会加一次）`v`，此时在目标边界的右下加上`v`来抵消影响，最终前缀和就会满足要求

#### 二维差分例题

题目描述：有一个二维数组，其中存在`0`和`1`，然后给定一个`h*w`大小的邮票，目标是将邮票贴满二维数组中的`0`元素位置，所有邮票可以重叠，无数量限制，但是不能翻转，问二维数组是否可以贴满

解法：遍历所有的左上角点，判断这个点能不能贴邮票，准备一个差分数组，如果可以贴邮票，就在对应范围`+1`，判断完所有点后，对差分数组求前缀和，然后比对原数组，如果原数组为`0`的位置在差分数组中的值都大于`0`，那么可以贴满邮票。判断能不能贴邮票需要一个前缀和数组来辅助

时间复杂度`O(N*M)`，空间复杂度`2*O(N*M)`

##### 离散化技巧题目

题目描述：给定一组数据`[x,y,side]`表示在`(x,y)`位置为中心，边长为`side`为正方形的范围构成一个力场，在坐标系中有若干力场，当所有力场叠加后找到力场最强位置（点）的力场强度

解法：构建一个差分数组，将所有力场转化为`+1`操作，最终看哪个坐标的值最高返回即可

⚠️离散化指的是将范围很大的多个值转化为连续的点来表示

⚠️本题坐标可能会出现小数，通过`x*2+side/y*2+side`方法可以保证坐标范围不包括小数

时间复杂度为`O(N^2)`，空间复杂度也是`O(N^2)`，`N`是力场的个数，最多有`2N*2N`个坐标，因为最后需要遍历整个差分数组，所以空间复杂度为`O(N^2)`

## 滑动窗口技巧与相关题目

[code](./examples/40-glide-window.rs)

滑动窗口：维持左右边界都不回退的一段范围，求解子数组/子串相关的问题

滑动窗口的关键：找到**范围**和**求解目标**的**单调性关系**

滑动过程：滑动窗口可以用简单变量或者结构来维护信息

求解大流程：求子数组在每个位置开头或结尾情况下的答案

### 累计和大于等于`target`的最短子数组长度

题目描述：在一个全部是**正数**的数组中，求出最短长度的子数组，要求它的和要大于等于`target`

解法：因为所有的元素都是正数，所以对于求解目标来说，子数组（连续）范围的变化是有单调性的，也就是多一个值结果就增加，少一个值结果就减小。可以使用窗口计算从任意一个位置，包括它以及之前元素的最短子数组，最小值就是结果

时间复杂度`O(N)`，因为窗口左右都是不回退的，所以只是遍历数组一次

### 最长无重复字符子串

题目描述：在一个字符串中找到不含重复字符的最长子串

解法：对于以任意一个元素为结尾，向前的最长的不含重复字符的子串，当进入下一个元素时，如果这个元素的上一个出现位置在之前的子串中，那么要更新子串长度`L=max(L, last_idx+1)`

时间复杂度`O(N)`，需要使用一张hash表来记录每个字符最晚出现的位置

### 最小覆盖子串

题目描述：有字符串`a`和`b`，求`a`中包含所有`b`出现的字符的最短的字符串，顺序无关

解法：关键在于`b`中出现的所有字符的记录方式，可以认为初始状态它们在`a`的子串中出现次数为负数，每出现一次就`+1`，直到这些字符出现次数和为`0`，表示子串包含`b`中所有的字符，此时开始移动子串左边界，但是要保持`b`中字符出现次数为`0`，修改完后就是一个求出的子串，之后每个位置都这样处理即可

时间复杂度`O(N)`

### 加油站

题目描述：有`N`个加油站，它们的路线成环，每个加油站有一些油，距离下一个加油站为`L`，问一辆无限制的油罐车是否能从任意一个点走完一圈，行走距离与需要的油为`1:1`

解法：题目给定了两个数组表示每个加油站的油量和该加油站到下一个加油站的距离，可以直接转换为到每个加油站之后还会剩的油量，那么求解内容就成为从任意一点开始到它前一个点时，油罐车的油量需要大于等于`0`

本题需要注意的点是可以扩展数组来避免环的计算。并且只是扩展数组的索引而不是真的需要扩展数组

本题利用了贪心的方式，即一旦从一个点开始无法走一圈，那么这个点开始走的所有路径都舍弃，因为如果之前的路径存储的油到停止点不能再走，那么之前的任意一点开始在停止点都不可能再走

### 替换子串得到平衡字符串

题目描述：有一个字符串，只包含`Q`、`W`、`E`、`R`四种字符，它的长度一定是4的整数倍，一个平衡字符串表示这个字符串中每个字符的出现数量相等，问需要替换最小子串的长度是多少可以让原字符串变为一个平衡字符串，替换的字符串可以这4种字符的任意组合

解法：这道题类比本章第三题，只需要找到被替换的字符串就可以，即多出来的字符所在的最短的子串中，返回这个长度即可

### K个不同整数的子数组

题目描述：在一个数组中找到不同数字种类恰好为`K`的子数组的个数

解法：如果直接找答案不好找，可以将问题转换为求数组中所有不同数字种类`<=K`的子数组的个数，然后再找到`<=K-1`的子数组个数，两个数相减就是答案。因为转换后的问题，它的求解目标和范围是有单调性关系的，即如果范围增大，数字种类更可能变多，减少更可能变少，所以可以利用窗口来解决问题

### 至少出现K个重复字符的最长子串

问题描述：给定一个数组和一个整数`K`，求出每个字符至少出现`K`次的最长子串

> 这道题有限制，字符串内容只包含小写字母，如果没有这个限制，那么可以用动态规划或者其它方法解决

解法：将问题转化为，每次求解当子串中只包含至少出现`K`次的`1~26`种字符，求解26次之后求得最大值，因为如果固定为`N`种，那么求解目标就跟子串范围有了单调性关系，即范围增大，种类会变多，范围变小，种类会变少

★看数据量猜解法

## 双指针技巧与相关题目

[code](./examples/41-double-pointer.rs)

- 有时的双指针，只是代码过程用**双指针的形式**表达出来，没有贪心方面的考虑
- 有时双指针包含**单调性（贪心）**方面的考虑，是现有的思考和优化，最终代码以双指针形式展现
- **分析题目单调性（贪心）**是最重要的

### 按奇偶排序数组II

题目描述：一个数组中只有奇数和偶数，需要将奇数放到奇数位置（索引），偶数放到偶数位置

解法：使用两个指针，一个指向奇数位置，一个指向偶数位置，然后从最后一个位置查看数字，如果是奇数，与奇数位置交换，奇数指针移动，偶数同理，直到奇数/偶数指针超出数组长度

### 寻找重复数

问题描述：给定一个包含`(N+1)`个数的数组，其中的数字范围是`[1~N]`，已知数组中一定有且只有一个重复数，找到这个重复数，要求时间复杂度为`O(N)`且额外空间复杂度为`O(1)`

解法：根据题目条件可知，从任意位置出发，类似于链表跳转，它的下一个位置就是自己存储的元素数值，那么问题转化为寻找链表环的入环点

### 接雨水

问题描述：给定一个数组表示直方图，问这个直方图可以接到多少单位的雨水（一单位就是`(1,1)`一个点）

解法：x轴上每个点可以接的雨水数量取决于它两边所有点的最大值，那么只需要两个辅助数组，记录`[0,N-1]`上从左往右的最大值和从右往左的最大值，每个点的雨水量就是`max(0, min(lmax, rmax)-arr[loc])`。时间复杂度`O(N)`，空间复杂度`O(N)`

优化解法：使用双指针指向`1`和`N-1`，那么它们各自左右的最大值已经确定，就可以直接确定当前它们自己的雨水，每次移动都更新左和右的最大值，空间复杂度为`O(1)`

本题关键在于**单调性**的确定，范围越小，求解目标就越少，双指针在这里只是一个优化手段

> 二维接雨水问题使用宽度优先遍历

### 救生艇问题

问题描述：给定一个数组，表示每个人的体重，问一艘船只能载两人，载重限制为`LIMIT`，每个人的体重都不会超过这个限制，问把这些人同时载走需要多少船

解答：需要先给数组排序，然后根据体重大的人（数组右侧），为他找船的队友（数组左侧），找到就是最优解，没找到就单独坐船，这里体现了**单调性**

扩展：要求船上的载重必须为偶数

扩展解答：因为每条船的偶数+偶数和奇数+奇数才能实现所有船载重都是偶数，所以只要将奇偶体重分开单独计算即可

### 盛最多水的容器

问题描述：给定一个数组，表示在一个坐标轴上`y`的数字。从中任选两条垂线`x`，得到一个长宽为`(x2-x1),min(y1,y2)`的容器，求这个容器的最大容量

解法：从左右开始对比，并且开始记录一个容器面积，然后判断左右哪条边更短就开始向更内侧移动

⭐️证明：思路是上面这种遍历方式不会错过最优解（反证），假设最优解为`(x1,x2)`，按照上面的遍历方式，总会先到达一个`x`点，假设先到达了`x1`点，当前`x2'`在大于`x2`的位置，如果此时`x1`需要右移，说明`x1`是小于`x2'`的，那么此时的容器面积一定是大于`(x2-x1)*y1`的，因为`(x2'-x1)>(x2-x1)`，此时假设最优解不成立，反证出上面的遍历方式一定能找到最优解

正面思考：对于最初的距离最远的左右两点，首先得到一个容量，如果想得到更大的容量，只能尝试抛弃更短的边，所以只能移动短边的位置，这里体现了**单调性**

### 供暖器

问题描述：给定两个数组表示房屋和供暖器在x轴上的位置，问供暖半径（所有供暖器共享）最小是多少可以为所有房屋供暖

解法：先对房屋和供暖器排序，对每个房屋找到距离最短的供暖器（距离就是供暖器的半径），**对每个房屋，如果多个供暖器的距离相同，那么需要不断跳到最后一个供暖器**。因为对于后面的房屋来说，更可能最优的将是后面的供暖器，且如果一个位置有多个供暖器，不跳过相同距离的供暖器会导致后面房屋无法进行最优供暖器的判断

### 第一个没有出现的正整数

问题描述：给定一个无序整数数组，找到第一个没有出现的正整数，要求时间复杂度`O(N)`，空间复杂度`O(1)`

解法：利用数组索引的连续性来转化问题，即`i`位置总是存放`i+1`，那么得到这个要求满足不了的位置`loc`，返回`loc+1`就是答案。这里使用左右两个指针，左指针表示此位置左边都是满足情况，右指针表示从该位置往右都是无效元素，同时表示当前尝试完成的任务收集`[1,R]`的数字。那么从`L`指针开始，如果当前值满足`arr[L]=L+1`，那么`L++`，如果`arr[L]>R`或者`arr[L] <= L`或者`arr[L]==arr[arr[L]-1]`，那么将这个元素移动到`R`区域，`R--`，直到`L`和`R`相遇，表示收集工作完成，返回结果

## 二分答案法与相关题目

[code](./examples/42-binary-problem.rs)

[code-robot](./examples/42-binary-problem-robot.rs)

大流程

1. 估计**最终答案可能的范围**，可以粗略，不影响二分效率
2. 分析**问题的答案**和**给定条件**之间的**单调性**
3. 建立一个`f`函数，答案**固定**（二分的中点）判断给定答案是否满足条件
4. 不断二分搜索，直到找到合适的答案

2、3步是关键点

### 爱吃香蕉的珂珂

问题描述：给定一个数组表示每个位置有一堆香蕉，koko吃香蕉的速度为`k`，在管理员离开的`N`小时中，koko会从0位置开始吃香蕉，在任意位置它吃完香蕉如果还有空余时间（如果只有6个香蕉，`k`为4，也需要2个小时），问koko的可以在管理员离开的时间吃完香蕉的最小速度

解法：最小速度这个答案的范围是可以想到的，即最慢是`0`，如果没有香蕉，那么满足条件，最快是`max(banana)`，因为速度再快，它在一堆香蕉上也至少要待1个小时。所以答案需要在`[0~max(banana)]`上寻找，满足条件判断的函数是在`k'`速度下，吃完所有香蕉的时间，如果时间够，那么记录答案，降低速度，如果时间不够，那么提高速度继续测试

时间复杂度`O(N*log(max(banana)))`，空间复杂度`O(1)`

### 分割数组的最大值（画匠问题）

问题描述：（使用画匠问题描述）有`k`个画家，有`N`幅作品，每个画家可以画连续的`x`幅画（`x>=1`），问如何划分可以让每个画家画的画消耗的染料加起来最少（每幅作品需消耗`y`份染料，`y>=0`）

解法：因为答案要求累加和的最小值，那么累加和的范围可以得到`0<=sum<=sum(paint)`，因为如果每幅作品都不需要染料，那么累加和最小就是`0`，最大也就是1个画家全部画完所需要的染料。在这个范围上，我们一定可以找到最小的累加和是多少，然后看分配的画家是否够给定的`k`，如果够，就记录答案，降低累加和（需要画家更多），如果不够，不记录答案，提高累加和（画家更少）

时间复杂度`O(N*log(sum(N)))`，空间复杂度`O(1)`

### 机器人跳跃问题

问题描述：机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为`i`的建筑的高度为`H(i)`个单位。起初，机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第`k`个建筑，且它现在的能量值是E, 下一步它将跳到第个`k+1`建筑。它将会**得到或者失去**正比于与H(k+1)与E之差的能量。如果`H(k+1) > E`那么机器人就失去`H(k+1) - E`的能量值，否则它将得到`E - H(k+1)`的能量值。游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏

解法：答案要求的是需要多少能量值才能成功走完所有建筑，那么这个答案的范围是`[0, max(build)]`，因为它自己的能量如果越少，它每经过一个建筑就回扣能量越多，回能量越少，而它能量越多，就会扣能量越少，回能量越多，如果它的初始能量就是建筑高度最大值，它一定能经过所有建筑，所以我们只需要在这个范围内寻找机器人最少需要的初始能量即可

⚠️因为能量累计的速度非常快（`2^N`），所以要注意，如果机器人在某个建筑前它的能量已经达到或者超过建筑最高高度，那么直接返回可以完成游戏即可

时间复杂度`O(N*log(max(height)))`，空间复杂度`O(1)`

### 找出第K小的数对距离

问题描述：给定一个数组，定义数对距离是任意两数差值的绝对值，然后求第K小的数对距离

解法：本题答案求的是数对距离，那么数对距离的范围是`[0, max-min]`，因为是绝对值，所以最小值不可能小于0，最大值也不可能大于`max-min`。在这个范围上，给定一个值，要求一个验证函数返回小于等于这个值有多少个数对，如果这个值大于要求数对数，那么缩小范围，否则增加范围

验证函数的实现需要对数组进行排序，由于数对距离是后数减去前数，那么排序后数组后数减前数一旦超过限制，前数就不需要再进行后续计算，这里使用一个窗口实现

时间复杂度`O(N*log(N) + log(max-min)*N)`，空间复杂度`O(1)`

### 同时运行N台电脑的最长时间

问题描述：给定一个数组表示电池电量，给定一个电脑台数`N`，问这些电池最多能供这些电脑同时最长运行多长时间

解法：最长运行的时间是有范围的，即`[0,sum(battries)]`，那么在这个范围上，给定任意一个时间，需要一个函数来判断电池是否能满足这些电脑同时供电这么长时间，这里有一个“碎片电池”的结论，即如果电池电量小于需供电的分钟数，那么它就是碎片电池，且如果电池数组中全部都是碎片电池的话，如果它们的累加和是大于等于*供电分钟数✖️电脑台数*，那么它们可以完成供电。单调性体现在，如果长的分钟数可以满足，那么短的分钟数一定可以满足（更容易），那么找更长的分钟数即可

优化方案：初始情况下，如果*所有电池的累加和 > 所有电池的最大值✖️电脑台数*，那么可供给的最大时间`t >= max`，这个时间就是`t = sum/num`，因为时间一旦超过最大值，所有电池都成为了碎片电池，有`sum(batteries)=t*num`，否则，可供给的最大时间也不会超过`max`，可以缩减二分范围

### 计算等位时间

> 谷歌面试题

问题描述：给定一个数组，表示`N`个服务员的接待一个客人所需的时间，然后给定`M`个客人，问当M个客人接待完后多长时间开始接待自己。服务员为`10^5`级别，客人为`10^9`次方级别

关键点：虽然服务员的接待效率各不相同，但是因为他们是空了立马接待顾客，所以自己被接待的时间点与之前的客人选哪个服务员进行服务无关

解法1：使用小根堆解决，每个服务员变为`(a,b)`的形式存入堆中，`a`表示自己的服务时间点，`b`表示自己的服务效率，那么只需要遍历完所有的客人，下一个弹出的服务员的服务时间点就是自己接受服务的时间。每次弹出后都是当前时间点更新为服务后的时间点再重新进堆。这种方式的时间复杂度为`O(M*logN)`，并不优秀，适合对数器验证

解法2：答案要求自己何时被接待，那么这个答案的范围是`[0, min(efficacy)*M]`，如果没人或者直接有空闲服务员，那么自己可以直接被接待，如果只有那个效率最高的服务员工作，那么自己在`min(efficacy)*M`之后也可以被接待。除此之外还需要定义一个函数，求给定时间内，M个人是否能被服务完，如果可以，那么记录答案，缩短时间，否则增大时间。这个函数的定义是，给定时间每个服务员的工作效率都是可以接待`t/efficacy+1`，因为可以整除也会再多来一个人。时间复杂度`O(N*logM)`

### 刀砍毒杀怪兽

> 大厂笔试真题

问题描述：一个怪兽有`M`点血量，给定两个数组为两种攻击方式，刀砍为直伤，当前回合收到伤害，毒伤为buff，下回合开始受到无限期累计伤害，问最少多少个回合将怪兽杀死

解法：这道题正面做决策很难，因为每次做决策都没有预期，所以可以先将答案的范围定出来使用二分，答案的范围就是`[1,M+1]`，因为怪兽至少需要一回合杀掉，如果刀砍伤害够即可，或者至少`M+1`回合，只要每回合掉1血，最多也就是`M+1`回合怪兽死。那么只要定义一个函数，判断给定任意回合，是否可以将怪兽打死，如果可以，记录答案减少回合数，如果不可以，增大回合数。判断的方式就是，因为已经给定了回合数，那么只要判断当前回合哪种伤害高就选用哪种攻击方式。时间复杂度为`O(N*log(M+1))`，其中`N`是回合数

## 单调栈

[code](./examples/43-monotonic-stack-problem.rs)

[code-monotonic-stack](./examples/43-monotonic-stack.rs)

[code-monotonic-stack-lg](./examples/43-monotonic-stack-lg.rs)

[code-eat-fish](./c/eat-fish.c)

使用数组实现的栈的操作的常数时间比语言（标准库）中实现的常数时间更好

### 单调栈经典用法解决的问题

在一个**无重复元素**的数组中找到任意位置元素它左右两边的小于/大于该元素且离它最近的元素，正常遍历的时间复杂度是`O(N^2)`，使用单调栈可以在`O(N)`复杂度完成

构造单调栈的流程（数组中无重复值，且以寻找左右两边小于值并且距离最近为例）：

1. 创建一个栈，规定栈顶元素一定大于栈底元素
2. 遍历原数组，插入第一个元素（进栈的是索引）
3. 从第二个元素开始，如果这个元素值比栈顶元素大则直接入栈
4. 如果元素值比栈顶元素小，那么栈顶元素的左右两端值可以计算
   1. 弹出元素，比它小且在左边离它最近的是下一个栈顶元素（索引）
   2. 比它小且右边离它最近的是准备入栈的元素
5. 重复3-4过程直到遍历完成原数组
6. 清空栈，过程中栈顶元素的左边离它最近且小于它的元素是下一个栈顶元素，如果没有为`-1`，右边离它最短且比它小的元素不存在记为`-1`

如果要寻找左右两边大于值且距离最近只要制作一个栈顶元素比栈底元素小的栈即可

简单证明过程：

1. 左边距离当前栈顶元素最短且小于它的值一定是下一个栈顶元素
   1. 对于`a->b`，如果中间还存在元素，它的取值范围有三个
   2. 如果`x<a`，那么`x`一定不存在，因为`x`会使得`a`已经被弹出
   3. 如果`x>b`，那么`b`会让`x`弹出，`x`不会存在
   4. 如果`a<x<b`，那么`x`这个数一定存在于栈中，也不可能
2. 综上`b`的下一个栈顶元素`a`就是距离它最近且小于它的元素
3. 右边距离当前栈顶元素最短且大于它的值一定是待入栈元素
   1. 栈顶元素被弹出的唯一可能就是碰到比它小的元素，所以当栈顶元素要被弹出时，待入栈元素一定是右边第一个比它小的元素

求解过程中，单调栈所有调整的总代价为`O(N)`，单次操作均摊为`O(1)`，因为原数组所有元素均只出入栈1次

如果数组中存在重复元素，寻找左右**严格大于/小于**任意位置元素，构建单调栈的流程：

和无重复元素的构建栈方式类似，只是当待入栈元素和栈顶元素的值相同时，需要弹出栈顶元素，并且弹出的栈顶元素的右边距离它最近且小于它的数暂时记为待入栈元素，然后将待入栈元素入栈

在处理完所有元素之后（包括清空栈的过程），逆序遍历结果数组，如果每个位置元素的右边距离它最近的小于它的数等于自己，那么根据记录的这个元素的位置去结果中找到对应结果更新到自己的结果中

#### 单调栈模版题

把逻辑实现一遍

⚠️问题可能会出现在值的比较和索引与值的映射关系上，细心为主

#### 每日温度

问题描述：给定一个数组表示每天的温度，问在每天最少隔多少天温度升高，如果不升高就是`0`

解法：构造一个求距离最短的大值的小压大的单调栈。这道题对于相等元素可以直接进栈，因为它只关心右边的值。可以省略清算阶段，因为最后剩下的温度都是右边没有更大值的，默认为`0`即可

#### 子数组的最小值之和

问题描述：给定一个数组，求每个子数组的最小值的和

解法：如果直接把所有的子数组得到找最小值再相加时间复杂度会爆炸。因为题目要求每个子数组的最小值，那么可以求任意位置，以该位置为基点，两边距离最近的最小值，这样就得到了一个`[left-cur-right]`的范围，其中的`cur`是最小值，并且`(cur-left)*(right-cur)`个子数组的最小值都是`cur`，计算当前结果即可。对于相等的数可以弹出栈，虽然被弹出的元素可能会少算右边比它小的部分，但是当后面的相同元素被弹出的时候，这部分计算都会被修正

题目要求数据量很大，要使用**同余原理**！！

#### 柱状图中最大的矩形

问题描述：给定一个数组，每个元素表示在坐标轴上的一条垂线，问可以组成的最大矩形面积是多少

解法：对于任意一点，包含它的最大矩形面积是找到两边距离最短比它小的值，那么中间部分就是它的面积。本题中对于相同高度的元素，也可以直接弹出栈顶元素，因为栈顶元素少算的部分（当前元素之后可能的较小的值）在弹出最后一个相同值元素的时候一样会算到，最终计算结果会被修正

#### 最大矩形

问题描述：给定一个二维数组，其中的元素值只为`0`和`1`，问只包含1的最大矩形的面积是多少

解法：需要掌握一个**数组压缩技巧**，对于任意一行，以它为底的矩形面积是可以通过类似上一道题的直方图面积求出来，当到达下一行，只需要把上一行的非`0`数累加下来，继续计算即可

对于`N*M`大小的二维数组，时间复杂度是`O(N*M)`

### 单调性更宽泛的用法

在很多问题中单调栈还可以**维持求解答案的可能性**

1. 单调栈的对象按照**固定好的单调性**来组织
2. 当某个对象进入单调栈时，会从栈顶依次**淘汰对后续求解答案没有帮助的对象**
3. 每个对象从栈顶弹出时，**结算当前对象参与的答案**，随后这个对象不再参与后续求解答案的过程
4. 实际上是**先分析题目**，**发现单调性**，再**利用单调栈的特征**来实现

#### 最大宽度坡

问题描述：给定一个数组表示当前位置高度，对于任意两个不同位置`(i, j)`，如果`h[j] >= h[i]`就认为这两个位置构成一个坡，求最大的坡的宽度

解法：所有可能的答案的左边界以从大到小的顺序入栈（需要维护所有答案的可能性），然后从右到左遍历数组，如果当前位置高度大于等于栈顶元素，那么弹出栈顶元素并结算其答案，因为这种情况一定是栈顶元素可能构成的坡的最大宽度，以后它也不用再参与计算

#### 去除重复字符的最小字典序

问题描述：给定一个字符数组，问如何去除重复字符（每种字符至少保留一个）之后得到的字符串的字典序最小

解法：答案要求字典序最小，所以栈底的字符应该更小（栈的顺序是大压小，方便最后直接返回），那么当新的字符进栈的时候，如果它大于栈顶字符可以直接进栈，如果等于栈顶字符可以直接忽略（替换无意义，其实只要栈里存在此字符就可以忽略，因为即便它入栈，也还是会替换到同一个字符在栈中的位置，且还需要把之前所有的字符弹出，所以还需要一个记录字符是否入栈的表），如果小于栈顶元素，那么要判断判定元素能不能被移除，这里就需要一个词频表来记录每种字符后面还剩多少个，如果值为`0`，那么不能移除，当前字符入栈，否则可以移除后再入栈当前字符，因为被移除的字符后面还可能再进栈

#### 大鱼吃小鱼

> b站笔试题

问题描述：给定一个数组表示鱼的重量，并且规定每条鱼可以吃它右边重量比它小的最近的鱼，问几轮后鱼的数量会稳定。一条鱼可以被重复吃，且每一轮所有的吃鱼行为是同时进行的

解法：从右往左遍历鱼的重量，入栈时如果是第一条或者比栈顶鱼的重量小，那么以`(weigh, turns=0)`入栈，这里的`turns`表示当自己被吃的时候，还需要几轮才能把自己的吃鱼过程走完。那么当自己比栈顶鱼的重量大时，栈顶鱼出栈，吃栈顶鱼要1轮，栈顶鱼自己的工作时间`x`轮，那么入栈的鱼的轮数就是`max(0+1,x)`，直到没有鱼可吃，最终栈顶鱼的轮数就是答案，因为此时鱼的数量稳定。**每条鱼的工作轮数（吃其它鱼）都会累积**，所以统计的是同时进行的吃鱼行为的轮次

#### ⭐️全是1的矩形个数

问题描述：给定一个二维数组，其中只包含`0`或`1`，求仅包含`1`的矩形的个数

解法：和上面求最大矩形面积类似，这道题也可以通过求一维数组（直方图）来扩展求二维数组的情况。如果只是求一个直方图中所有的矩形个数，可以利用上面的解答方式，对于任意位置，找到它左右两边距离最短的最小值，然后只需要计算出它当前位置在两个最小值的最大值之上部分构成的矩形数量，这里注意，低于这个值的矩形个数是不需要计算的，因为在更低的位置，会计算这些矩形，计算矩形个数的公式有（以`x`为底且高为`h`的矩形有几个矩形）`x*(x+1)/2`，这个公式表示的是高固定后，底边长度的可能范围。如果碰到相等高度的位置，那么弹出的位置不计算，因为弹出部分涉及到的矩形在最后一个相同位置一定会被计算。对于二维数组的计算方式，只要以每一行做底求出所有的矩形个数即可

这道题的单调性是任意位置的高计算它包含的矩形只需要找到左右距离它最近且最短的高的两个位置，并且更低的位置不需要在当前位置计算，当前位置只需要计算和它关系唯一的矩形即可

时间复杂度`O(N*M)`

## 单调队列

[code](./examples/44-monotonic-queue-problem.rs)

[code](./examples/44-flowerpot.rs)

### 单调队列经典用法解决的问题

单调队列是用来维持窗口中的**最大值/最小值**，具体流程如下（以最大值为例）

1. 准备一个双端队列，窗口从`[0, 0)`开始
2. 窗口右边进入新元素时，该元素从队列尾部进入，此时窗口`r++`，队列头部开始维持窗口最大值
3. 如果新元素比队尾元素小，那么将小于（等于）新元素的所有队尾元素全部从尾部出队，然后尾部入队新元素
4. 如果窗口左边弹出元素`l++`，如果弹出元素是队头元素，那么弹出队头元素，否则不动

原理：单调队列中总是存储所有可能成为窗口的最大值，因为队列在增加元素的时候，如果后面的更大值进去，那么前面的更早过期的更小值不可能成为窗口的最大值，所以都出队，左边弹出的时候，如果不是更靠前的最大值被弹出队列就不变更，所以队列中永远都是在窗口滑动过程中最大值的可能性，并且这个值是**队头元素**

如果是最小值，那么队列应该是从小到大排列，新增元素如果小于队尾元素就弹出所有大于（等于）该元素的队尾元素弹出

总的时间复杂度是`O(N)`，均摊时间复杂度（队列）是`O(1)`，因为所有元素进出队列都只有一次

#### 单调队列模版题

问题描述：给定一个数组，有一个`k`长度的窗口从头开始滑动，一次移动一个单位，把所有的窗口最大值返回

解法：利用单调队列的基本实现可以得到答案。注意索引的对应，以及答案数组的长度`len-k+1`

#### 绝对差不超过限制的最长连续子数组

问题描述：给定一个数组，给定一个限制，问在数组中所有子数组中最大值和最小值的差不超过限制的最长子数组的长度是多长

解法：首先确定答案的单调性，对于任意一个子数组，它的最大值和最小值之差在右边进入新值时，只可能扩大不可能减小，因为最大值和最小值只可能更大和更小（如果新数的值在中间不会影响原来的最大最小值），所以从任意位置开始，到绝对值超过限制（单调增加）的位置为止，就是该位置开头的满足条件的最长子数组，此时将最左边的值移出窗口。对于窗口的最大最小值使用两个单调队列维护，窗口左指针遍历完原数组即得到答案

#### 接取落水的最小花盆

问题描述：给定N滴水的坐标`(x,y)`，表示水滴落下在`x`轴的位置和它的高度。水滴每秒下降1单位，问有一个花盆要放在`x`轴上，使得这个范围的水滴最早落下和最晚落下的时间差**至少**为D的话，花盆最小需要的宽度，如果不存在返回`-1`

解法：和上一道题一样，需要注意的是利用离散化技巧，将所有水滴按照`x`轴位置排序，而不是维护所有`x`的位置。之后只需要从起始位置找出所有的花盆位置以及长度，即可得到答案

### 单调队列更宽泛的用法

和单调栈类似，单调队列可以**维持求解答案的可能性**

1. 单调队列的元素按照某种单调性组织
2. 当某个元素从队尾进入队列时，会从队首或队尾**移除对后续求解答案没有帮助的元素**
3. 每个一旦从单调队列弹出，可以结算有此元素参与的答案，随后这个元素不再参与后续求解过程
4. 仍然是**先对题目进行分析**，继而发现**单调性**，随后用**单调队列的特征**去实现

#### 和至少为K的最短子数组

问题描述：给定一个数组，问所有累加和至少为`K`的子数组的最短长度是多少

解法：利用[构建前缀信息](#构建前缀信息的技巧--解决子数组相关问题)的方式，构建一个前缀和数组表示各个位置的累加和，那么在任意位置，只要可以得到向左扩展最短距离就能满足限制的子数组就是该位置的答案。比如`i`位置前缀和`Sum(i)`，它之前的累加和至少需要小于等于`Sum(i)-k`，那个位置才能满足限制。如果有一个单调队列（从小到大），在前缀和在尾部入队的时候，如果队首元素满足条件，那么应该弹出并记录答案，直到不满足条件，然后判断队尾元素是否小于此元素，因为如果大于该元素，后面的答案到该元素位置如果不符合条件，那么到队尾元素（更靠前且前缀和更大）就更不可能符合条件，所以要将队尾大于该元素的元素都弹出，随后该元素入队

需要注意的是`(0,0)`在0个元素的情况下前缀和为0的元素要入队，可以方便计算，因为在队列空的情况下，如果只有一个元素那么直接入队，就不会被计算了

#### 满足不等式的最大值

问题描述：给定一个数组包含二维平面上的点，根据它们的`x`值排序，给定一个值`k`，返回`yi+yj+|xi-xj|`的最大值且`|xi-xj| <= k`

解法：要求最大值的公式实际上是`yj+xj+(yi-xi)`，那么在任意一点上，往前只需要找`yi-xi`的最大值即可，此时可以使用从大到小的单调队列维护这个值，且新值进入队列的时候如果队首元素过期（`x`的差值超出了范围），那么直接弹出队首元素

#### 你可以安排的最多任务数

问题描述：有一个任务数组，表示每一个任务需要的能力，还有一个工人数组，表示每个工人具有的能力，工人要做任务要求工人能力大于等于任务所需能力，每个工人只能做1个任务。并且额外给了`pills`颗药丸，每颗药丸可以增强1个工人`s`能力，且一颗药丸只能用一次。问在这个条件下最多能完成多少任务

解法：这道题关键在于任务如何做，需要利用贪心分析，即用能力最高的工人去做能力需求最低的工作能做完多少。先将任务和工人数组排序，然后使用一个双端队列，从能力最小的工人开始，查看他能做多少任务，任务进队列，如果队列不为空，那么做一个任务，开始找下一个工人，如果队列为空，那么用一颗药丸，继续让任务入队，此时为了**让药丸物尽其用**，如果队列不为空，这个工人要做能力需求最高的任务，直到工人在任何条件下都做不了任务结束

注意：**这道题直接在整个范围用贪心不行！**因为在尝试过程中很可能前面能力低的工人直接把整个过程停掉，导致后面能力高的工人无法尝试，所以在大问题上应该使用[二分答案法](#二分答案法与相关题目)的方式来寻找可能的任务最大完成数

## 并查集

[code](./examples/45-union-find-problem.rs)

[code](./examples/45-union-find.rs)

[code](./examples/45-union-find-lg.rs)

> 带权并查集，大厂笔试/面试冷门
>
> 可持久并查集、可撤销并查集，比赛级别

并查集是一种数据结构，它由一些小的集合组成，并且提供以下操作接口

```rust
/// 查找ele元素所在集合的代表元素
fn find(ele: &Element) -> Element;
/// 判断ele1和ele2是否属于同一个集合
fn is_same_set(ele1: &Element, ele2: &Element) -> bool;
/// 将ele1和ele2所在的集合联合起来
fn union(ele1: &Element, ele2: &Element);
```

并查集的性质：提供的操作的时间复杂度均摊之后为`O(1)`

每个集合都是一个单链表，尾节点会指向自己

1. `find`：从参数指定的元素遍历查找，直到尾元素，最终返回尾元素
2. `is_same_set`：从两个参数指定的元素遍历查找，如果它们的尾元素相同，则属于同一个集合，否则不属于
3. `union`：将长度更短的链表的尾节点指向更长的链表的尾节点

实现方式

使用两个数组`fathers`和`size`，表示初始情况下每个元素属于只包含自己的集合和集合大小，对于`union`方法，相同大小的集合默认前一个集合连接到后一个集合，即将前一个元素的尾元素（`fathers`数组中`i`位置的元素）改为后一个集合的代表位置（`j`位置），然后修改后一个集合的`size`大小，此时前一个集合的`size`成为脏数据，不再使用

优化点，都在`find`过程中进行

1. 总是长度小的集合往长度大的集合上连接（可以不做，论文中的秩的概念）
2. 在`find`的过程中，如果寻找链路很长，查找到之后需要把链路上元素的指向全部更新为指向最终的尾元素。即“扁平化优化”（必须做）

时间复杂度的理解，感性理解所有的操作时间复杂度都是`O(1)`，因为即便合并出一个很长的集合链，在查找时，更长时间也只需要一次，因为有路径合并的优化，后续就会缩短为`O(1)`。实际上时间复杂度为`a(N)`，阿克曼函数，当`N`足够大（10^80），返回值不超过6

小挂大的优化粗略想，我们认为长度更长的集合链高度会更高，长度短的集合链高度更低，所以小挂大是为了尽量不再增长集合链的高度

### 情侣座位分配问题

问题描述：已知有`N`对情侣，它们会随机坐在一个数组中，如果要让所有的情侣都坐在一起（相邻），至少需要移动几次（每次移动一对人）

解法：有一个前提是，如果在一组情侣中，有`K`对情侣，他们不坐在一起，那么调整好需要`K-1`步，那么解题只需要遍历一遍情侣，如果他们属于一对情侣，则不做处理，否则将他们所属的情侣对数合并，最终查看有几个组，每个组减1相加就是结果

优化点：因为结果是`Sum(GroupN-1)`，且`Sum(Group)`就是总情侣对数，则答案直接使用总情侣对数减去组合出的组数

时间复杂度`O(N)`，只需要遍历一次情侣数组

### 相似字符串

问题描述：给定一个字符串数组，里面都是相同字母的异序词（anagram），即相同数量的字符排列构成的字符串。如果两个字符串只需要调整两个（不同）字符的位置就完全一样，那么认为这两个字符串相似，而相似的字符串应该放到一组中，并且相似有传递性，那么最终会分几组

解法：这道题将总的组数构造成一个并查集，然后遍历所有字符串的组合，判断是否相似，如果相似就分组，最后将组数返回即可。判断两个字符串是否相似的函数，只需要判断两个字符串相同位置的不同字符数量不超过2即可

时间复杂度`O(N^2*M)`，因为需要遍历任意两个的字符串的组合，判断是否相似需要遍历字符串本身（长度为`M`）

### 岛屿数量

问题描述：给定一个二维数组，只包含`0`和`1`，已知任意一点的上下左右包括自己都是`1`，那么可以组成岛屿，问这个数组可以组成几个岛屿

解法：本章使用并查集的方式解题。即遍历所有点，将每个点并入它上下左右为`1`的点的集合，直接忽略所有的`0`点，最后查看有多少个集合。这里需要对二维数组中的点编码成线形点，即`[x,y]`处的点转化为`x*col+y`

优化点：每个点只需要遍历上方和左边即可，因为下方和右边的点在后续遍历中会处理

时间复杂度为`O(N*M)`，遍历完所有的点即可

### 移除最多的同行或同列石头

问题描述：给定一个石头数组，表示每个石头的二维坐标，如果两块石头属于同一行或者同一列，那么可以移除一块石头，问最多可以移除多少块石头

解法：这道题中有一个结论，即同行同列的所有石头集合中，通过从边缘到中心的消除顺序，最终一定只会剩下1个石头。那么只需要把所有的石头集合找出来，然后用总石头数减去集合数量就是要被移除的石头数。因为整个坐标系比较大，而石头比较小，在合并集合的时候可以利用两个哈希表来保存石头的`x`和`y`坐标，如果每个`x`或`y`坐标出现了其它的石头，那么就进行合并

时间复杂度为`O(N)`

### 找出知晓秘密的所有专家

问题描述：初始状态下有`N`名专家，其中第`0`名专家知晓一个秘密，并且最开始会将这个秘密告诉一个指定专家，之后每个时间点会开`groupm`场会议，如果会议有知道秘密的专家参与，那么参加会议的另一个专家也会知道。每个专家同一时间可以参加无限场会议，如果某个时间点开完会议后，专家不知道秘密，那么之后仍旧不知道秘密，如果知道秘密，之后就一直知道秘密，问最终有多少专家知道秘密

#### 经典并查集的扩展用法

类似于小挂大时使用的`size`数组，可以保存每个集合的大小，还可以定义其它类似的标签数组来表示某个集合携带的额外信息，这个信息一般在`union`过程中需要被更新

本题解法：先对会议根据时间排序，每次处理一个时间点上的多个会议，参与会议的两名专家需要合并成一个集合，并且如果任意一名专家知道秘密，应该更新两名专家都知道秘密。处理完会议后，所有不知道秘密的专家需要将自己的所属集合撤销，即自己为单一集合。最终统计所有知道秘密的专家即可

时间复杂度为`O(M*logM + M + N)`

⚠️最终统计哪些专家知道秘密的时候，应该用`find`查找专家所属集合的代表专家是否知晓，而不能直接统计秘密数组，因为秘密数组里有大量的**脏数据**，这种标签信息数组都是类似的

### 好路径的数目

问题描述：给定一棵树，每个节点都有一个值，定义好路径的概念，即任意两点如果它们的值相同，且它们之间的节点全部都是小于等于两个端点的值，则这条路径为好路径。每个点本身都是一条好路径。问一棵树总共多少条好路径

解法：最关键的点在于对边处理顺序的排序，每条边的值取决于它两个端点的值的最大值，然后按从小到大顺序对边进行排序，排序后每条边的处理方式是，如果两个点各自所在的集合的最大值相等，那么两个点各自集合最大值的个数相乘就是生成的好路径的条数，然后合并两个集合，且**最大值小的要挂到最大值大的上面**，直到所有的边处理完，再加上节点个数就是答案

因为先处理的是值比较小的边，所以到后面处理最大值较大的边时就不需要考虑这些值更小的边，而值小的边也会被中间值更大的边隔开而不会算重复

时间复杂度为`O(N)`

### 尽量减少恶意软件的传播II

问题描述：给定一个图（使用邻接矩阵的方式表示）和一些被感染的点的位置，问去掉哪个感染点可以拯救更多的普通点，题目中是一个无向图，即一个点可以感染整个图，可能会有额外的点

解法：这道题的前提是，如果一组普通点构成的图外接了两个感染点，那么这个子图一定不可能被拯救

1. 将所有的普通点合并成子图，并且需要记录每个子图的外接感染点和集合大小（当前步骤不设置），这是并查集的标签信息
2. 遍历所有感染点，每个感染点找接触的普通点子图，并更新子图的外接感染点信息
   1. 初始感染点为`-1`
   2. 如果之前没有感染过，设置感染点为当前值
   3. 如果感染过，判断是否与当前值相同（因为一个普通子图集可能有多个点跟感染点接触）
      1. 如果相同，忽略
      2. 如果不相同，设置为`-2`，即这个子图外接超过1个感染点
   4. 如果感染过，且已经为`-2`，那么直接忽略
3. 将所有感染点去掉可能拯救的节点数统计起来
4. 排序感染节点，并开始遍历，返回索引更小且拯救节点更多的感染节点

时间复杂度为`O(N*N)`，即遍历图的时间

## 洪水填充

[code](./examples/46-flood-fill.rs)

洪水填充是一个简单的技巧，设置路径信息进行**剪枝**和**统计**，类似感染过程

**路径信息**不撤销，保证每一片感染区域可以被区分

虽然是暴力递归，但是洪水填充的时间复杂度很优秀，遍历次数和样本数量规模一致

### 岛屿问题

问题描述：跟[岛屿问题（并查集）](#岛屿数量)相同

解法：对于任意一个可能成为岛屿的点，使用一个函数去查看它的上下左右点，在查看前将它本身设置为其它数值并且统计岛屿数，直到所有点遍历一遍

时间复杂度依旧是`O(N*M)`，因为遍历每个点需要单位时间，且每个点最多被查看函数访问4次（上下左右），即每个点的遍历次数跟问题规模无关，所以不影响整个时间复杂度

### 被围绕的区域

问题描述：整个区域包括`X`和`O`两种格子，如果`O`是被`X`包围的格子（上下左右），那么可以被改为`X`，问改完之后的区域是什么情况

解法：如果`O`构成的区域没有被`X`包围，那么表示在区域边缘一定有一个`O`，所以可以从边缘的`O`开始将所有连接的`O`感染成其它字符（例如`F`），那么剩下的`O`就都是被`X`包围的`O`，将它们全部修改，最后再把未被包围的`F`修改为`O`即可

时间复杂度是`O(N*M)`

### 最大人工岛

问题描述：给定一个二维矩阵只包含`0`和`1`，相互连接的`1`（上下左右）构成岛屿，问将哪个`0`修改为`1`之后整片区域的最大面积的岛屿最大，最后返回最大面积

解法：这道题最后还是要遍历所有的海水区域，所以要先将岛屿分区编号，然后看每个海水格的上下左右是哪几个区块，统计每个海水格构成的最大岛屿，最终返回最大值。编号过程使用洪水填充，记录新的岛屿ID

时间复杂度是`O(N*M) + O(N*M) + O(N*M)`

### 打砖块

问题描述：给定一个二维数组，其中包含`0`和`1`，`1`表示砖块，本题的设定是第一行的砖块是稳定的，或者某个砖块的四个方向（上下左右）是稳定砖块，它也是稳定砖块。然后给定一个打击序列，每次打掉一个砖块（如果有），当这个砖块消失后有`x`块砖块掉落，求每次打击掉落的砖块数量

解法：首先假设所有的打击点的砖块都消失，然后从天花板开始洪水填充，此时从后往前复原（时光倒流技巧，最后的变更先处理，之前的被打掉的砖块的影响会被累积，且之前被打掉的砖块不会被计算）被打击的砖块，并统计当此打击影响的掉落砖块。统计过程也是一个洪水填充，即如果打击砖块存在，且它或者是天花板的砖块或者它的附近有稳定砖块，那么需要开始填充

应用所有的打击更新后，天花板洪水填充会将当前所有的稳定砖块标记出来。此时从后往前恢复打击效果不会出现统计错误的情况，因为从前往后计算会导致后面打击的砖块会将之前被击碎的砖块计算进来（因为每次恢复会将当前的砖块恢复，然而到下一次其实这个砖块已经被击碎），恢复完打击效果前的砖块状态，填充的意义在于它如果作为稳定砖块（或者是天花板砖块或者周围有稳定砖块）可以影响多少非稳定砖块，也就是答案

## 建图、链式前向星、拓扑排序

[code](./examples/47-graph.rs)

[code](./examples/47-topo-problem.rs)

[code](./examples/47-topo-dyn-newcoder.rs)

[code](./examples/47-topo-static-newcoder.rs)

[code](./examples/47-topo-lg.rs)

[code](./examples/47-topo-progeny-lg.rs)

图分为有向图 vs 无向图，带权图 vs 不带权图

### 建图

#### 邻接矩阵建图

给定点的位置（索引），如果点的数量为`N`，那么构建一个`N*N`的二维矩阵，每行表示每个点与其它点的连接关系，在不带权图中，`1`表示连通，`0`表示不连通。如果是带权图，那么`1`的位置修改为边的权值

如果权值为0的话，无连接需要用`∞`表示

缺点是点的个数不能太多，在2000左右还可以（笔试）。因为点的个数多了邻接矩阵占用空间太大

⚠️无向图的邻接矩阵的所有连接点相对于矩阵对角线对称

#### 邻接表建图

不带权有向图：使用类似`Vec<Vec<usize>>`的形式，每个点创建一个空的动态数组，碰到一条边，就在起始点索引的动态数组里添加它的终点索引

带权有向图：使用`Vec<Vec<(usize, i32)>>`，其中的元组表示终点索引和权值

无向图的处理：无向图可以认为是特殊的有向图，即每条边都表示了两条有向边（邻接矩阵也一样）

#### 链式前向星

因为邻接表属于动态结构，因为每个点的边的数量未知，所以空间占用无法预估，在空间要求严苛的情况下会超出限制。而链式前向星可以在固定空间大小下表示任意数量的边

实现关键概念

- `cnt`：表示正在处理的边的编号，从1开始
- `head`：索引表示点，值表示它指向的头（链表）号边的编号，默认为0
- `next`：索引表示边，值表示它的下一条边，即`head`上的值
- `to`：索引表示边，值表示边指向的值
- `weight`：如果是带权图，它表示每条边的权值

添加一条边的时候，`next`中`cnt`边指向`head`中起始点的旧值，然后这条边的起始点`head`值指向这条边`cnt`，然后`to`的`cnt`值修改为这条边的指向点，如果有权值也更新这条边的权值

> 如果是无向图，`next`/`to`/`weight`的长度都应该是两倍，因为边的长度会翻倍

### 拓扑排序

拓扑排序要求被排序的是**有向无环图**，所以拓扑排序也可以用来判断图中是否有环

拓扑排序的结果是图中所有节点按照每个点之前出现的点一定都是它的前置节点的规则进行排列，所以拓扑排序的结果不一定唯一。拓扑排序可以用来对项目流程做排序，在处理程序编译顺序中也有应用

拓扑排序的过程

1. 准备一个长度为节点数量的队列（数组实现）
2. 将所有入度（有向边指向本节点则本节点入度加1，本节点指向外部节点则出度加1）为0的点进入队列
3. 移除所有队列中的节点，并且对移除的节点所影响的其它节点的入度做修改，如果修改后入度也成为0那么将那个节点入队
4. 直到队列为空

需要统计出队的节点数量，如果数量等于节点数则返回拓扑排序结果，否则表示图有环，无法排序

时间复杂度是`O(N+M)`，`N`是点的数量，`M`是边的数量

#### 带字典序的拓扑排序

解法：使用小根堆代替队列

时间复杂度是`O(N+M) + O(N*logN)`，因为每个点都需要进出小根堆一次

#### 火星词典

问题描述

给定一个字符串列表，作为这门语言的词典，其中的字符串已经按这门新语言的字母顺序进行了排序。请你根据该词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。若不存在合法字母顺序，返回空字符串。若存在多种可能的合法字母顺序，返回其中任意一种顺序即可

字符串`s`字典顺序小于字符串`t`有两种情况：

1. 第一个不同字母处，如果`s`中的字母在这门外星语言的字母顺序中位于`t`中字母之前，那么`s`的字典顺序小于`t`
2. 如果前面`min(s.length, t.length)`字母都相同，那么`s.length < t.length`时，`s`的字典顺序也小于`t`

解法

对于任意两个字符串，从头开始比较，碰到第一对不同的字符，就得到一条边`a->b`，因为最终答案要求按升序排列，所以边的关系是小指大。要特别注意，如果所有的字符都相等，但是前一个字符串的长度比后一个长，那么给定的字典顺序也是不对的，直接返回空字符串

对得到的图进行拓扑排序，因为入度数组不一定包括所有的字符，所以首先初始化为`-1`，要遍历所有的字符串，如果点存在，就事先加1来更新入度数组。并且不需要特判，因为每个字符本身是入度为1的点

时间复杂度是`O(N*M)`，`N`是单词数量，`M`是单词长度

#### 戳印序列

问题描述：给定一个印章字符串和一个目标字符串，假设初始状态目标字符串所有字符为空，印章必须完全在目标字符串范围内盖，每次盖章都可以用印章字符更新目标字符串，要求在`10*target.len()`次盖章内得到目标字符串，如果超过这个次数，则返回空数组，否则返回每次盖章的初始索引数组

解法：印章可能的开始位置是目标字符串前`M-N+1`个（`M`是目标字符串长度，`N`是印章长度），每个位置盖一次印章相对于最后的结果来说会错`x`个位置，这个值可以作为每个点的入度（点就是印章的有效开始索引），如果有入度为0的点，那么它一定是最后一次盖章的位置，而每次盖章都可能修正其它点的入度，这里就是等效为一个拓扑排序，直到所有点的入度为0，最后将排序结果倒序就是题目答案。构建图使用的边是遍历印章所有的可能位置时，如果任意字符对不上，则添加一个错误字符位置指向当前印章索引的边，表示这个位置印章需要其它位置来减少它的入度，每个位置离开队列的时候，从印章开头到印章结尾均是被移除的点，更新一次入度表，且这些点之后都不能再次被更新（**重复更新是错误的，因为每个点只能被修正一次**，因为每个点只能在某一次被处理）

每个印章可以盖的位置只能盖一次，它可以修正印章个数的字符，所以最后一次盖章的位置是全部正确，即最后一组的盖章点无入度，并且其中的所有点对于其它盖章位置的组的入度影响要应用一次，此时如果还有入度为0的盖章点，那么需要在该位置盖章，而这一次盖章对后续的影响只能是它正确的点，其它错误的点不是它影响的，所以不能对那个点影响的其它组的入度减1，**所以要设置一个被影响的点的记录数组**

这道题只是应用了拓扑排序，图只是辅助应用排序的，入度计算是节点（组）中所有单独点对于其它组的有影响的点

时间复杂度是`O(N*M)`，`N`是印章字符串长度，`M`是目标字符串长度

## 拓扑排序的扩展技巧

[code](./examples/48-topo-extend.rs)

[code](./examples/48-foodline.rs)

重要技巧：利用拓扑排序的过程，将一些信息从上游节点推送到下游节点

### 最大食物链计数

问题描述：给定N个点表示动物，边表示动物间的捕食关系，问整个图中有几条低端到顶端的食物链

解法：对给定数据做图后，以每个动物为顶端捕食者的食物链是它可以捕食的下端动物以各自为顶端捕食者的食物链的和。那么可以初始对于低端捕食者设置为1，然后在拓扑排序的过程中，当前动物如果有捕食者，那么将自己的食物链条数加到捕食者身上，如果没有则统计食物链条数即可

注意答案需要取模，可以利用同余原理，在每一步相加时操作都取模

### 喧闹和富有

问题描述：给定一个数组表示每个人的安静程度，然后给定任意两个人的富有关系，`[a,b]`表示`a`比`b`更富有，前提是富有关系不会矛盾。求每个人比他更富有且包括他自己的人中最安静的人是谁

解法：最终要的是初始化答案数组的时候，先让每个人的答案是他自己，然后在拓扑排序的过程中修改自己的答案，并且当自己被排序完成的时候更新比自己穷的人的答案，也是信息传递，因为最富有的人中最安静的就是自己，到更穷的人只需要拿自己的值依次比较，最终留下最小的安静值即可

### 并行课程III

问题描述：给定一些课程的关系`[a,b]`，要完成`b`必须先做完成`a`。然后给定每门课程的完成时间，最后返回完成所有课程的最短时间。课程可以并行上

解法：建图之后可以发现，每个课程完成的最快时间取决于它之前要完成的所有课程时间的最小值，那么需要一个辅助数组表示每节课完成的最短时间。对图进行拓扑排序的时候，这节课要先加上自己的时间，然后和它的下一节课所需的最短时间比较，并且用较大值更新下节课的时间，然后判断自己跟完成当前所有课程最短时间的时间比较，将较大值更新，拓扑排序完成即可得到答案

### 参加会议的最多员工数

问题描述：总共有`N`名员工，每名员工都有自己喜欢的一名员工，且不能喜欢自己。有一张会议桌可以坐无限人，如果员工必须和自己喜欢的员工坐在一起才会开会，问如何安排能让最多的员工一起开会

解法：这道题给定的每名员工喜欢的员工的数组就是一张图，每个点的出度都为1。最终图中会有多个环，**并且必须有环才能开会**。如果环的大小为2（小环），那么这个环中的员工和各自的最长链可以被安排进会议，此时不影响后续安排，所以所有的小环容纳的人数都加起来是一种情况，如果环的大小大于2（大环），那么只有仅将环中的人安排到会议桌才能开会，且后续不再能安排其它人开会，这种情况应该统计大环的最大长度，最终将两种情况的最大人数取最大值就是结果

遍历环的时候可以将点的入度减1，因为每个环只需要统计一次，统计过的点不参与后面的统计

## 最小生成树

[code](./examples/49-minimum-tree-problem.rs)

[code-kruskal](./examples/49-kruskal-lg.rs)

[code-prim](./examples/49-prim-lg.rs)

[code-prim-pro](./examples/49-prim-pro-lg.rs)

[code-busy-city](./examples/49-busy-city-lg.rs)

在无向带权图中选择一些边，在保证**所有点**的连通性的情况下得到的总权值最小

`N`个点至少需要`N-1`条边来保证连通性。最小生成树的方案不止一种。最小生成树的算法设计都是基于贪心制定的遍历策略，以下算法证明略

> 最小生成树一定是最小瓶颈树

### Kruskal算法

1. 所有边按照权值排序，从小到大
2. 如果选择当前边不会连成环，就选择
3. 如果选择当前边会连成环，就不选择
4. 当选择的边数达到了`N-1`，选择完成

使用并查集来判断正在处理的边是否会造成环，开始每个节点是一个集合，连接的节点会并入同一个集合，如果后续处理边的时候两个节点已经在一个集合，那么表示当前这条边会成环，不处理即可

时间复杂度是`O(M*logM) + O(N) + O(M)`，是对边的排序复杂度加上构建并查集的时间加上最终遍历边的时间

### Prim算法

1. 建图，因为是无向图，所以一条边要转化成两条有向边
2. 创建解锁的点的哈希表（数组/`HashSet`）和解锁的边（小根堆，按照边的权值排序）
3. 从任意点开始，点进入哈希表，然后将它的指向边全部进入堆
4. 从堆中弹出边
   1. 如果这条边的指向点已经在集合中，跳过
   2. 如果这条边的指向点不在集合中，**记录此权值**，将它的指向边进入堆，然后自己进入集合，重复4
5. 直到堆为空，算法结束
6. 如果集合点的个数为总个数，那么返回最小生成树的权值

时间复杂度是`O(N+M) + O(M*logM)`

### Prim算法的优化

1. 选取一个点，将它去往的所有节点和花费（权重）进入小根堆
2. 从小根堆中弹出一个点，记录花费，**判断这个点去往的其它点**
   1. 如果这个点在堆中，那么比较当前的花费和堆中记录的花费
      1. 如果当前花费大，那么忽略
      2. 如果当前花费小，那么更新堆中该点的花费
   2. 如果这个点已经弹出过，那么忽略这个点
   3. 如果这个点没有进入过堆（初始状态），将它和花费加入堆中
3. 直到堆中没有元素，如果记录节点数为节点总数，那么返回结果

时间复杂度是`O(N+M) + O((N+M)*logN)`，前面是建图的时间复杂度，堆中始终保持节点数，即全部节点会进堆一次、出堆一次，然后每个点的边都需要遍历一次并且根据情况会调整边，所以后面的时间复杂度跟堆与点的个数有关

这里对于小根堆的值更新后重新调整堆需要提供一个反向索引，即根据堆中节点的内容来找到节点在堆中的位置

⚠️在第一个节点弹出的时候一定也要对其节点进行判断，因为数据可能会包含两个节点中有多条不同权值的线

### 水资源分配优化

问题描述：有N个村庄，每个村庄打一口井的需要`X`花费，任意两个村庄修路需要`Y`花费，如果一个村庄有水，那么任意和它相连的村庄就也有水，问所有村庄都有水所需要的最少花费是多少

解法：这道题的关键在于将村庄打一口井的花费转化为该村庄到一个**虚拟水源**修路的花费，此时所有的村庄和虚拟水源就构成了一个无向图，通过求一颗最小生成树的权值即为答案

### 检查边长度限制的路径是否存在

问题描述：给定一些边，并且给定一些问题，每个问题包含两个点和一个权值，问这两点之间是否存在每条边都小于这个值的路径，如果有则返回`true`，否则返回`false`

解法：这道题需要将解题转化为在最小生成树的过程中，先对问题根据判断值从小到大排序，然后遍历问题，开始执行最小生成树的生成过程，如果当前的边小于问题值就继续加边，直到边大于这个值，判断这个问题的两个点是否在树中，如果在则该问题是`true`，否则是`false`

### 繁忙的都市

问题描述：城市中有`N`个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接，这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了，每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：

1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来
2. 在满足要求1的情况下，改造的道路尽量少
3. 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小

作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建，返回选出了几条道路以及分值最大的那条道路的分值是多少

解法：每个交叉路口就是一个点，连接交叉路口的道路就是边，题目要求改造的道路要能把所有交叉路口直接或间接联通起来，然后改造的道路要尽量少（无意义，因为要连接所有交叉路口至少需要`N-1`条道路），最后要求分值最大的道路分分值尽量少。本质是求一颗最小瓶颈树（最小瓶颈树就是在所有点都连通的情况下（连通图）包含满足条件的权值最小的边），最小生成树就是最小瓶颈树（⚠️最小瓶颈树不一定是最小生成树），所以只要求出最小生成树，然后在求的过程中返回权值最大的边即可

## 宽度优先遍历及其扩展

[code](./examples/50-bfs-problem.rs)

- bfs的特点是逐层扩散，从源头点到目标点扩散了几层，最短路就是几
- bfs可以使用的特征是，任意两个节点的**相互距离**相同（无向图），即任意两点的边双向距离是一样的
- bfs开始可以是单源，也可以是多源。多源就是多个起始点一起开始遍历，但是同样要保证进过队列的节点被标记，不能重复进入队列
- bfs频繁使用队列，可以是**单点弹出**或者**整层弹出**
  - 对于单点弹出，进入队列的节点需要携带层数标记，即`(node, layer)`的元组
  - 对于整层弹出，需要记录当前层数，当前队列节点数，每次只进行当前节点数次弹出操作，然后更新前两个值
- bfs进入队列的节点需要**标记状态**，防止同一个节点重复进入队列
- bfs进行时可能会包含**剪枝策略**的设计

难点在于**节点如何找到路**，路的展开以及剪枝设计

### 地图分析

> 曼哈顿距离，`(a0, b0)`到`(a1, b1)`的距离是`|a0-a1| + |b0-b1|`

问题描述：给定一个二维数组，`1`表示陆地，`0`表示海洋，找到一个海洋位置，距离它最近的陆地的距离是所有海洋中最长的。如果全部是海洋或者全部是陆地，返回`-1`。题目的距离是曼哈顿距离，即两个点的位置只能通过上下左右移动得到

解法：可以以所有的陆地点为起始点向外寻找海洋，找到最远的海洋点就是答案。这是一个多源bfs

时间复杂度是`O(N*M)`

### 贴纸拼词

问题描述：给定一个字符串，并且给了一些贴纸，贴纸上是一些单词，每个贴纸都有无限张，贴纸也可以任意裁剪，求解使用最少的贴纸拼成目标字符串的贴纸数量

> 这道题也可以使用动态规划求解

解法：每次可以选择任意一张贴纸来减少目标字符串的长度，这样构成一个起点为目标字符串，目标为空字符串的决策树，可以利用bfs来求解空字符串的层高。先对目标字符串和每张贴纸进行排序，不影响结果。这道题的剪枝过程是每一层都按顺序进行遍历，即每一层只处理当前目标字符串的最开头字符，直到处理完成

### 0-1bfs

0-1bfs应用于权值只有`0`和`1`两种情况的图的bfs遍历，求解从起始点到目标点的最短距离

这种图之所以不能用普通的bfs是因为每隔一层并不代表两个点的距离加1，如果用普通bfs就需要先对所有边的权值排序，保证每个点距离（权值）为0要先进入队列，这样时间复杂度就达不到`O(N+M)`，会带一个`M*log(M)`的时间复杂度

实现流程：

1. 准备一个`distance`数组，表示每个位置距离起始点的最短距离，默认为∞
2. 准备一个双端队列，首先头部入队起始点，起始点的最短距离为0
3. **头部节点**出队
   1. 如果节点是目标节点，那么返回`distance[head]`的值即可
   2. 遍历它的下一个节点，它的距离是`distance[head]+w`，如果该距离小于当前距离，处理这条边，否则不处理
      1. 如果`w`是0，将这个点从头部入队
      2. 如果`w`是1，将这个点从尾部入队
4. 直到队列为空

正确性证明：

任何时间，队列中的所有点距离当前弹出的点的距离都不会大于1，由于后续如果相同的点，如果它能让这个距离更小，它会从队头入队，此时会覆盖掉原先可能距离更大的点，而导致距离更大的相同的点永远不可能再进队，因为距离已经被更新了，只能变得更小而不会更大

在实现过程中`distance`数组替代了`visited`的功能，即最短距离只会被更短的更新一次，且是否允许更新本身也阻止了同一个点重复进入队列，一个点最多进出入队列两次

时间复杂度为`O(N+M)`

#### 01bfs模版题

问题描述：给定一个二维数组，每个点只能是`0`和`1`，`0`表示自由行动的空间，`1`表示障碍。问从`(0, 0)`走到`(N-1, M-1)`位置最少需要打破几个障碍

解法：这道题可以等效为从`(0, 0)`节点到`(N-1, M-1)`节点的最短路径的权值，到自由行动空间权值为0，到障碍权值为1，应用01bfs即可

#### 网格图至少有一条有效路径的最小代价

问题描述：给定一个二维数组，每个点上都有上下左右四个方向，表示可以从指定方向移动，每个点的方向可以改变为任意其它方向一次，改变一次代价要加1，问从`(0, 0)`点到`(N-1, M-1)`点所需要的最小代价是多少

解法：这道题也是一个01bfs的模版题，因为每个点对于其它点的边的权值判断，当它自己的方向是对应的下一个点时权值为0，否则权值为1，当从起始点到目标点的最短距离求到，就是最终需要花费的代价

### 宽度优先遍历和优先级队列的结合

#### 二维接雨水

问题描述：有一个二维数组，每个点的值表示柱子的高度，问这个二维数组构成的池子最多能接多少单位的水

解法：和一维接雨水问题相同，每个二维点位置能接的雨水数量取决于它的上下左右柱子的高度，这里使用宽度优先遍历加上优先级队列（小根堆）来处理每个点，开始将最外圈的点按照它们的高度进入优先级队列，并且需要有一个标记二维数组来表示哪些点被遍历过，然后开始弹出点，每次弹出的点都可以结算接的雨水数`height[p]-grid[p]`，然后将它的上下左右点拿到，如果没有进过堆，就将`(nx,ny,max(p, np))`进入堆，之所以使用最大值，是因为这个点如果高度更低，则可以继承将它带进来的点的高度，如果它高度更高，则自己不可能存水，但是有可能帮助其它点存水。堆中所有点遍历完成即可得到答案

时间复杂度是`O(N*M*log(N*M))`

### 宽度优先遍历和深度优先遍历的结合

#### 单词接龙II

问题描述：给定一个单词，给定一堆待选单词，给定一个目标单词，每次可以修改给定单词的一个字符，使其转换为待选单词中的一个，直到转换成目标单词，问所有的最短转换路径有哪些

解法：单词转换过程使用bfs处理，即初始字符串每次将所有可能转换成的下一轮字符串作为下一次遍历的对象，如果这些对象中包括目标字符串，那么遍历结束，收集答案。每次得到下一轮字符串都要建一个反向图来保存路径，即`a-> b,c,d`表示从`b,c,d`都可以转化为`a`，最后在这个图上应用dfs来收集答案

这道题中的一个技巧是，如果给定字符串很多，每次判断当前字符串可以转化成哪些字符串的时间复杂度会跟给定字符串的数量有关，因为题目中单词只包含小写英文字母，所以转换为每位只有26种可能的排列，可以减少时间

⚠️这道题在每层变化字符串的时候，要将本层的所有字符串都从待选单词中去掉，否则会造成循环，且也不可能是最短路径

## 双向广搜

[code](./examples/51-two-side-bfs.rs)

[code](./examples/51-two-side-bfs-lg-newcoder.rs)

### 常见用途1：bfs的小优化

剪枝优化，因为bfs应用于两点相互距离一样的无向图，那么从起始点到目标点和从目标点到起始点所经过的路程是一样的，如果总是从扩展出更少节点的一次开始遍历直到目标点，所用时间相比总是从一侧遍历节点（可能这一侧节点更多）所用的时间会更短

#### 单词接龙I

问题描述：和[单词接龙II](#单词接龙ii)的问题描述一样，区别是只要返回最短路径长度即可

解法：使用双向广搜，从起始单词和目标单词一起搜索，哪边扩展出来的节点少，下一次就从哪边开始扩展，如果扩展出的几点在另一侧中存在，那么直接返回结果即可

### 重要用途2

对于一些必须对所有可能全展开的问题，例如在一个长度为40的数组中，每个元素都有选择/不选择两种可能性，那么所有的情况数量就是`2^40`，这个时间复杂度不可能接受，但是如果可以将数组划分为两部分，对各自展开后，结果可以通过`O(2^(N/2))`的时间复杂度的**整合策略**得到结果，那么时间复杂度可以维持在`3*10^6`级别，问题变得可解

类似数据量的情况，用动态规划的方式也是无法求解的，因为空间不允许

#### 零食问题 & 世界冰球锦标赛

问题描述：以零食问题为例，有一个背包容量为`K`，给定一组零食，每个零食都有自己的体积，问在不超过背包容量的情况下有多少种放零食的方式

解法：题目要求的数据量零食最多40包，但是零食体积和背包体积非常大，所以不能使用动态规划求解。可以将零食分为两个子数组，然后对左右数组各自全展开，在过程中筛选掉在子数组展开过程中就超过背包体积的可能性，然后对各自的结果排序。在两个结果数组上使用双指针判断，左边固定，看右边有几种可能性，累加结果，直到左右指针碰到，返回结果

#### 最接近目标值的子序列和

问题描述：给定一个数组和一个目标值，可以选取一个子序列（不要求连续）的累加和与目标值的差的绝对值最小，求这个最小值

解法：这道题的数据量依然是数组有40个元素，每个元素的值都很大。可以用双向广搜的方法先分为两组，做选择的全展开，然后双指针左头右尾开始遍历，直到找到最小的绝对值

常数优化1：因为数组长度很小，找出整个数组的最大值（所有非负数）和整个数组的最小值（所有负数），如果目标值大于最大值或者目标值小于最小值，那么直接返回最大值和最小值与目标的差的绝对值即可

常数优化2：在递归收集所有展开结果的时候，可以通过事先对数组进行排序，每个选择展开按照组来进行，即每组的元素值相同，可以分为`0~k`种可能，这样会压缩选择树的高度，减少递归层数

## Dijkstra算法、分层图最短路

[code](./examples/52-dj-problem.rs)

[code](./examples/52-dijkstra-tmpl-lg.rs)

[code](./examples/52-dijkstra-flight-lg.rs)

[code](./examples/45-union-find-problem.rs)

### Dijkstra算法

目标：给定一个源点，求解它到所有点的最短路径长度。单源最短路径算法

适用范围：有向图（无向图也可以），**边的权值不能有负数**

暴力遍历实现的Dijkstra算法时间复杂度是`O(N^2)`，不使用

普通堆实现的Dijkstra算法（常规实现）

1. 准备一个距离数组表示源点到其他点的最短距离和一个`visited`数组表示某个点是否从小根堆弹出过
2. 准备一个长度和边数相等的小根堆
3. 假设源点是`a`，设置距离`distance[a]=0`，将`(a, distance[a])`入堆
4. 堆弹出一个节点
   1. 如果`visited[a] == true`，那么不处理
   2. 否则，设置`visited[a] = true`，⚠️弹出的节点距离源点的最短距离这里就已经确定了
      1. 查看它指向的所有边，假设它指向`u`，边的权重为`w`，如果`distance[a] + w < distance[u]`，那么更新`distance[u] = distance[a] + w`，并且将`(u, distance[u])`插入堆中
      2. 否则不处理这条边
5. 重复4直到堆中没有元素

时间复杂度为`O(M*logM)`，处理M条边，堆中最多可能将所有边的记录插入

反向索引堆实现的Dijkstra算法（最快）

1. 反向索引堆需要实现的功能
   1. 插入记录（和普通堆类似）
   2. 更新记录（需要同步更新索引）
   3. 弹出记录（和普通堆类似）
   4. 索引额外记录节点是否弹出过堆的状态（节点不在堆中的两种可能性）
      1. 节点没有进过堆，使用`-1`
      2. 节点已经出堆，使用`-2`
2. 准备一个反向索引堆，大小为节点个数，初始将`(a, distance[a])`入堆
3. 从堆中弹出节点，确定弹出节点到源点的最短距离，处理它的边
   1. 如果边指向的节点已经出过堆，那么不处理
   2. 如果边指向节点没有进过堆，那么将记录入堆，更新距离
   3. 如果边指向节点在堆中，那么判断`distance[a]+w < distance[u]`，如果成立则更新堆该节点的记录
4. 重复3直到堆中节点为空

时间复杂度`O(M*logN)`，依旧需要遍历所有边，但是堆的大小仅跟节点有关

#### 最小体力消耗路径

问题描述：给定一个二维数组，每个点表示高度，问从`(0, 0)`到`(N-1, M-1)`位置，最小体力消耗的路径的消耗是多少，每条路径的消耗是任意两个点的高度差绝对值的最大值

解法：直接应用Dijkstra算法即可。两点之间的权值是路径上所有边的最大值

时间复杂度是`O(N*M*log(N*M))`，因为每个点的边是固定的，所以是点的规模

#### 水位上升的泳池中游泳

问题描述：给定一个二维数组表示每个泳池的深度，在`t`时间，每个泳池会达到`t`深度水，仅当当前泳池水的深度四周都达到`t`，才能开始往四周游，问从`(0, 0)`到`(N-1, M-1)`最少需要多长时间

解法1：Dijkstra算法，每个点开始能游所需要的时间是自己的深度，可以游到其他位置的时间是两者的最大值，和上一题类似，求到右下节点即可。时间复杂度是`O(N*M*log(N*M))`

解法2：使用并查集，初始集合需要将二维点压缩成一维点（压缩方法见[二维点转换为一维点](#岛屿数量)），因为题目中水的深度为`N*N`，可以用二分答案法，每次使用一个并查集来判断头尾节点是否相连（dfs遍历）且在一个集合中，直到找到答案

⚠️二分答案法的rust实现中，如果`m`为0，且修改`r`时要直接退出循环，否则会索引计算溢出无限循环

### 分层图最短路

又叫扩点最短路

不把实际的位置作为点，而是把实际位置和某些状态信息结合作为点，进行bfs或者Dijkstra算法，扩点就是所谓分层。**如何扩点、如何到达以及如何算距离**是重点

#### 获取所有钥匙的最短路径

所谓分层是因为，每个点都携带了状态信息，类似于每一套点在不同的状态都是一个图，就像有很多层的图，每层的图都在做遍历

问题描述：给定一个二维数组，每个元素有5种字符，解释如下。从起始点开始移动，只有对应钥匙可以打开对应锁，返回获取到所有钥匙的最短路径长度，如果无法取得所有钥匙返回-1

- `.`：空房间
- `@`：起始点
- `#`：墙
- lowerletter：钥匙
- upperletter：锁

解法：每个点是`(i, j, key)`，`key`是持有钥匙的状态，即遍历的过程中，当得到钥匙之后，进入该钥匙状态的图继续进行bfs，判断一个点是否存在也需要使用此状态。时间复杂度为`O(N*M*2^MaxKey)`，可以用位信息表示某个钥匙是否持有，`(0011) => (dcba)`表示持有`a`和`b`钥匙

#### 电动车游城市

问题描述：小明的电动车电量充满时可行驶距离为`cnt`，每行驶1单位距离消耗1单位电量，且花费1单位时间。小明想选择电动车作为代步工具。地图上共有`N`个景点，景点编号为`0 ~ N-1`。他将地图信息以`[城市A编号, 城市B编号, 两城市间距离]`格式整理在在二维数组`paths`，表示城市A、B间存在**双向通路**。初始状态，电动车电量为0。每个城市都设有充电桩，`charge[i]`表示第`i`个城市每充1单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市抵达终点城市

解法：电动车从任意城市移动时，电量最多可能有`cnt`种状态，所以每个点就扩展成为`(p, battery)`，所以初始点进入堆后，要判断它下次有哪些状态，一种就是充一格电（没必要尝试多充，因为这个点会扩展出去），另一种就是不充电移动到下一个地点，在遍历过程中如果碰到终点就可以返回花费的时间

时间复杂度为`O(N+M) + O(M*logM)`

#### 飞行路线

问题描述：Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在`N`个城市设有业务，设这些城市分别标记为`0 ~ N-1`，一共有`M`种航线，每种航线连接两个城市，并且航线有一定的价格。Alice和 Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以**免费**在最多`K`种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少

解法：和上一道题一样，状态改为还剩余的免费次数，注意这里是一张无向图，使用常见剪枝碰到终点就直接返回

## A星、Floyd、Bellman-Ford与SPFA

[code](./examples/53-bf-problem.rs)

[code-A*](./examples/53-astar.rs)

[code-floyd](./examples/53-floyd-lg.rs)

[code-Bellman-Ford-SPFA](./examples/53-bf-spfa-lg.rs)

### A*

A*算法解决的问题是，给定源点，求它到**目标点**的最短距离

A*和Dijkstra的区别在于小根堆是依据`distance[p] + predict(p, t)`而不仅仅根据该点到源点的距离进行排序的

`predict(p, t)`是该点到目标点的距离的预估值，这个预估值要**小于等于该点到目标点实际所需要的距离**

预估函数可以看成是一种吸引力，即预估函数计算值越接近最大的预估上限，求解就会越快，但是如果预估函数超过了实际所需距离，即小根堆的排序中吸引力成为了影响排序的主要因素，就会产生错误的答案

Dijkstra算法可以认为是吸引力为0的A*算法

⚠️一般在二维表格中预估函数比较好写，在普通的有向图中不好设计预估函数

常用的预估函数包括

1. 曼哈顿距：`|d[i1] - d[i2]| + |d[j1] - d[j2]|`
2. 对角线距离: `max(|d[i1] - d[i2]|, d[j1] - d[j2])`
3. 欧式距离: `sqrt(|d[i1] - d[i2]|^2 + |d[j1] - d[j2]|)`

> 实验结果：如果是一个起点到终点没有通路的二维数组，那么加上预估函数的速度基本都不如纯Dijkstra快，毕竟是多了一次计算步骤，在进入堆中的点数量不变的情况下，预估函数的cost会影响速度

### Floyd

Floyd算法解决的问题是求解图中任意两点的最短距离。可以是有向图/无向图，边的权值可以是正负，唯一的限制是图中不能出现负环（环中所有边的权值和为负数），因为如果负环存在，两点之间的最短距离可能是无穷小

Floyd的时间复杂度为`O(N^3)`，空间复杂度为`O(N^2)`，因为算法主流程就是以任意点作为**跳板点**来更新其余两点的最小距离，所以需要三层遍历，且**第一层遍历必须是跳板点**。需要一个距离二维数组来作为结果表做更新操作

实现过程：对于每一个点作为跳板点，遍历任意两个点的距离是否能通过这个跳板点变短，如果变短则更新，遍历完所有跳板点后结果完成，遍历顺序不影响算法正确性

## Bellman-Ford

Bellman-Ford解决的问题是单源最短路径，并且要求图中不能出现负环

松弛操作：假设源点为A，它去往某个点F的最短距离为`distance[F]`。那么对于一个点P，它去往另一个点S的距离为W，如果`distance[P] + W < distance[S]`，那么P出发的这条边就对点S进行了松弛操作

实现过程：遍历所有边，在一轮遍历中如果没有出现松弛操作，证明所有最短路径都被求出

时间复杂度为`O(M*N)`，首先每一轮遍历都需要遍历所有边，其次遍历的总轮数一定小于等于`N-1`，因为对于任意一个源点，如果存在它能到达最远的点的最短路，那么中间最多有`N-1`条边，而Bellman-Ford每轮遍历的一个松弛操作相当于增加了该点的最短路的一条边，那么至多`N-1`轮，所有点的最短路都可以得到

重要推论：Bellman-Ford算法可以验证一个图中任意源点开始是否存在负环，如果该点出发第`N`轮仍然出现松弛操作，说明图中存在负环

### k站中转内最便宜的航班

> 使用Dijkstra也可以做，每轮弹出所有点，在k轮遍历后，如果该点到目标点距离不为正无穷，就是答案

问题描述：有一些航班，问从起始航班到终点航班，最多可以经过`k`站，花费最便宜的路线的花费是多少，如果没有返回-1

解法：因为Bellman-Ford的边遍历顺序是随机的，有可能一次性更新多个点的最短路，要让遍历的轮数和每次增加的站点数同步，所以在每次更新时，都用旧的记录来计算`distance[P] + W`，和新记录中的`distance[S]`比较，将新的距离更新到新记录中，遍历最后交换两个记录，重复k次获得答案。这种比较方式表示每一次遍历都是从源点往外更新一轮离它最近的点的最短路，这样就和中转站对应上了

### SPFA（shortest path faster algorithm）

优化点：Bellman-Ford每轮循环都需要遍历所有的边，这是没有必要的，因为只有上一轮被松弛的点所连接的边在这一轮才有可能继续进行松弛操作，所以准备一个队列来接收所有的进行松弛操作的点，再用一个数组来标记某个点是否在队列中，如果在队列中就不再进队。每次弹出一个节点，将它的所有边尝试松弛操作，并把进行了松弛操作的边对应的节点插入到队列中。队列中只包含让源点距离变短的点

时间复杂度还是`O(N*M)`，如果没有负权边还是用Dijkstra使用

适用范围：

1. 小图
2. 解决负边（没有负环）的图的单源最短路径问题
3. 可以判断从某个点出发是否存在负环（通过增加一个虚拟源点可以判断图中是否存在负环）
4. 有并行计算的优势（Bellman-Ford+SPFA中每次遍历下的各点的松弛操作是独立的，所以可以使用多线程加速算法）

#### 是否存在负环

问题描述：给一个包含`N`个点的有向图，判断是否从`1`出发是否存在负环

解法：模版题

解法2：使用Floyd算法求解一次任意两点的最短距离，然后再遍历一遍所有跳板点，如果源点到任意点距离还可以缩小，那么存在负环

## 从递归入手一维动态规划

[code](./examples/54-uni-dp-problem.rs)

动态规划：用空间替代重复计算，包含一整套**原理**和**技巧**的总和

知道怎么算的算法 vs 知道怎么试的算法。知道怎么算就是算法流程固定，例如Dijkstra算法，知道怎么试就是要求某个问题的结果，知道可以通过哪些其他计算（重复过程）来得到这个结果，动态规划类算法属于此类

有些递归在展开计算时，总是重复调用同一个子问题的解，这种重复调用的递归变成动态规划很有收益。如果每次展开都是不同的解（例如带路径的递归）或者重复调用的现象很少，那么没有该动态规划的必要

任何动态规划问题都一定对应着一个有重复调用行为的递归。所以任何动态规划题目都一定可以从递归入手，逐渐实现动态规划方法

**暴力递归中尝试的部分就是在动态规划中的状态转移方程**，过程是相同的

从递归/写尝试函数入手解决问题，要比直接使用动态规划填格子的修改成本更低，如果思路错了改动更容器，当所有条件判断/分支都正确后，写动态规划代码只是添加一个额外空间存储中间计算结果而已

💥在看到动态规划的解法后，题目的暴力尝试->优化结果的过程，要能理解，分析出来，尝试借鉴其他人的优化过程

### 动态规划过程总结

想出设计优良的递归尝试（方法、经验、固定套路），尝试展开顺序包括

- 记忆化搜索（自顶向下的动态规划），如果每个状态的计算枚举代价很低，到这一步就可以了
- 严格位置依赖的动态规划（自底向上），为了进一步优化做准备的阶段
- 优化空间（空间压缩），不需要维护整个的dp表，一维、二维以及多维的动态规划都存在这种优化
- 进一步优化枚举（优化时间），之后大量内容涉及

对子项的求解定义可能不同，则展开顺序、计算顺序可能不一样，但是不影响解决问题

解决一个问题可能有很多尝试方法。众多的尝试方法中可能若干尝试方法有重复调用的情况，可以转换成动态规划，可以转换成动态规划的方法中也有优劣之分。判断优劣的依据是来自题目具体参数的数据量。最优的动态规划方法实现后，后续还有一整套优化技巧

### 斐波那契数列

问题描述：写一个函数返回斐波那契数列的任意项

解法：斐波那契数列的通项公式：`F(N) = F(N-1) + F(N-2)`，第一项是`0`，第二项是`1`，最简单的实现就是暴力递归。时间复杂度`O(2^N)`

优化1：暴力递归中很多子项是重复计算的，可以使用一个表格来记录算出来的子项答案，这样的话后续计算子项时如果已经有答案可以直接用。这样整个计算树就简化为最左的一条路径，计算次数就是行高，而后续的子项计算全部不需要展开（最多再有`O(N)`的时间复杂度），所以时间复杂度优化为`O(N)`。这种方法是自顶向下的动态规划，也叫**记忆化搜索**

优化2：因为斐波那契数列的任意项都是前两项之和，所以可以直接从头开始计算推出后续所有的项，这叫做自底向上的动态规划，省去递归函数调用的开销

优化3：空间使用优化，因为每个子项的计算只和前两项有关，所以只需要两个变量即可推出任意一项，不需要长度为`N+1`的查询表

### 最低票价

问题描述：给定一个数组表示一年内出游的日期，元素值的范围和长度都是`[1~356]`。火车票有三种售卖方式，分别为1、7、30天内免费出行，票价固定，问完成所有旅行需要的最低票价是多少

解法：使用暴力递归的方式，每个日期都可以买三种火车票去试，满足当前日期购买的火车票之后，**尽可能多得覆盖其他日期，**，每个日期要旅行至少买一张票即可，如果它覆盖了后面的日期就延后，剩下的日期再去重复此过程，然后得到火车票的花费最小值就是答案，时间复杂度`O(3^N)`

优化1：使用一个dp数组来保存计算过的内容，即自顶向下（记忆化搜索）的动态规划，这样可以省去重复计算的部分。虽然非计算出的子项也有一个遍历过程，即三种票价和每种火车票的当前日期尝试次数需要遍历，但是只有最长持续30天然后用持续1天的去遍历，所以可以看成`O(1)`的复杂度，即这样可以将时间复杂度优化到`O(N)`的级别

优化2：自底向上，因为开头的选择什么价位的车票是取决于最后选择车票倒推回来，所以可以利用这个关系，从最后的日期开始填dp数组，最后返回`dp[0]`即可

### 解码方法

问题描述：给定一串密钥，需要根据`1-A~26-Z`的范围和关系解码，同一串密钥有很多中解密方式，且有可能无法解密，如果整个字符串无法解密，返回0。本题结果的范围一定在32位整数范围内

解法：考虑暴力递归尝试解题。从`i`位置开始，有两种可能性，如果`sec[i] == 0`，那么从这个位置没有任何一种解码方式，直接返回0，否则可以分为两种情况，一种是取一位，从下一位开始继续求解可能性，另一种就是`i`和`i+1`解码（如果两位范围在`1~26`之间）之后，从`i+2`位开始继续尝试，直到位数到达密码的总长度，即递归出口返回1，表示找到一种解码可能性

改进1：改造为记忆化搜索形式，加一个dp数组来保存子项的计算结果

改进2：自底向上的动态规划，每个位置的可能性只跟它后面的一个或者两个位置的结果相关，所以从后往前递推

改进3：因为只和后面两个位置有关系，所以只需要两个变量来循环保存结果即可

### 解码方法II

问题描述：题目设定和上一题一样。但是引入了`*`字符，它可以表示`1~9`中任意数字。结果需要和`10^9+7`取模

解法：除了条件判断比上一题更多以外，唯一需要注意的是结果取模需要应用同余原理，即每次返回的结果都要跟给定的数字取模

条件判断划分为以下部分，在`i`位置

- 如果这个位置是`0`，那么返回0，构不成任何有效解码方式
- 取`i`单个字符
  - 如果是数字，那么结果是`f(i+1)`种可能性
  - 如果是`*`，那么结果是`9*f(i+1)`种可能性
- 取`i`和`i+1`两个字符
  - 数字+`*`
    - 数字是`1`或者`2`，那么结果是`9*f(i+2)`
    - 数字不是`1`或者`2`，那么结果是0
  - `*`+数字
    - 结果是`1`的1种和`2`可能存在的1种之和乘`f(i+2)`
  - 数字+数字：1种或0种
  - `*`+`*`：`1`开头的9种和`2`开头的6种，总共`15*f(i+2)`

⚠️改动态规划写法的时候一定要注意把条件判断全部保留下来，包括异常状况，例如这道题当中的`s[i] == '0'`的情况，如果改写后答案错误大概率是因为条件判断缺失的原因

### 丑数II

问题描述：分解完只包含质因数2、3、5的数叫做丑数，丑数的第一项是1，问第N项的丑数是什么

解法：暴力解法，写一个验证丑数的函数，然后从1开始往后遍历去寻找丑数，这种方式查找第N项丑数可能会涉及到非常多的数字尝试

优化1：尝试去写出每一项的丑数，根据观察可知，每一项丑数都是由之前任意项`prev * 2/3/5`中的最小值且比上一项大的值，但是这样有很多重复的计算（尝试）

优化2：在每一项上保留三个指针表示`* 2/3/5`，求解下一项的时候，将三个乘法求解结果的最小值放到这一项，然后之前三个结果任一与最后结果相同的指针后移

⚠️这道题中，从优化1到优化2的改进在于减少尝试可能性，因为之前项的某一个乘法结果如果被选中，这个数字就不可能再出现在后面，所以这种可能性也不需要再尝试

### 最长有效括号

问题描述：给定一个只包含`(`和`)`的字符串，找出最长有效的括号子串的长度。子串是连续的，最基本的有效子串为`()`，可以通过并列和嵌套关系来扩展长度

解法：在给定子串的任意位置，以此位置结尾的有效子串长度是和之前的各位置结尾的有效子串长度有关系的，关系是，如果当前位置是`(`，那么以当前子串为结尾构成的有效子串长度为`0`，如果是`)`，那么需要查看`i-1`位置的值，这个值表示之前位置已经构成的有效子串可以被当前位置扩展的距离，那么把这个距离减掉得到`i - dp[i-1]`，然后查看这个位置是`(`还是`)`，如果是前者，则长度加2,再加`dp[i-1]`（嵌套关系）并且要加上`i - dp[i-1] -1`位置的值（并列关系），如果是后者，则无法和当前位置构成有效子串，此位置长度为0。因为起始点无法构成有效子串，所以dp表中的值为0

### 环绕字符串中唯一的子字符串

问题描述：有一个无限长的字符串`base`，有无数个`a-z`字符串拼接而成，给定一个字符串`s`，问`s`中有多少个非空且不同的子串在`base`中也出现

解法：这道题不以常规的思路，即求以`s`中任意位置结尾的子串在`base`中出现的长度去求最终结果，因为这样做需要去重，且`s`字符串长度很长。转换思路后可以求`s`字符串中以`a-z`结尾的子串的最长长度，最终累加所有结果就是答案。要求最长长度，只需要遍历`s`字符串，如果此字符和之前的字符在`base`中是相邻的，那么连续长度（单独设置变量）加1并且更新dp表，否则更新连续长度为1更新dp表，遍历完之后返回dp表的累加和即可。本题中任意位置的前一个位置的最长长度是决定当前位置（字符）的最长长度的因素，如果连续，则当前位置字符结尾长度就是之前的字符的长度加1

### 不同的子序列II

问题描述：给定一个字符串，返回所有不同子序列的个数，不包括空字符串

解法：如果字符串中所有字符不同，那么全部子序列的个数为`2^N`，`N`是字符串长度。当字符串中有重复字符的情况下，考察以`a-z`为结尾字符的子序列的个数，最终累加起来之后，减去空集就是答案。首先记录未遍历字符串时的子序列，个数为1（空集），当来到一个新字符的时候，已有子序列全部拼接上这个新字符，去掉重复子序列数得到这次全新的子序列数量`all - dp[c]`，这里`dp[c]`就是之前计算过的以字符`c`结尾的子序列个数，因为之前的子序列个数去掉`c`之后，拼接上当前这个`c`就是重复的子序列，所以如此计算去重数。之后更新`all = all + all - dp[c]`，更新`dp[c] = dp[c] + all - dp[c]`，遍历完所有字符后得到答案

## 从递归入手二维动态规划

[code](./examples/54-two-dm-dp-problem.rs)

[code-nm-tree](./examples/54-n-m-tree-newcoder.rs)

尝试函数有1个可变参数可以**完全**决定返回值，进而可以改出一维动态规划表的实现。同理当尝试函数有2个可变参数可以**完全**决定返回值，就可以改出二维动态规划表的实现

一维、二维或者多维的动态规划问题大体过程都是

1. 尝试递归
2. 记忆化搜索（从顶到底）
3. 严格位置依赖的动态规划（从底到顶）
4. 更多时间、空间上的优化

动态规划表的大小估计：每个可变参数的可能性数量相乘

动态规划方法的时间复杂度估计：动态规划表大小 * 每个格子的枚举代价（计算出每个格子的代价）

二维动态规划依然需要整理动态规划表的格子之间的依赖关系。找寻依赖关系往往*通过画图来建立空间感*，依然是从简单格子填写到复杂格子的过程，即严格位置依赖的动态规划

二维动态规划的空间压缩原理不难。但*不同的题目中的依赖关系不一样*，需要画图来整理依赖关系

能改为动态规划的递归，统一特征是：**决定返回值的可变参数类型往往比较简单**，通常不会比`int`更复杂。具体原因见[题目2](#单词搜索)，也解释了带路径的递归不适合/无必要改成动态规划解法

⚠️不管是几维动态规划，依据递归的定义，可以避免很多边界条件讨论

### 最小路径和问题

问题描述：给定一个`N*M`的二维网格，每个元素上有一个值，沿途只能从右和下行动，从左上角点出发求一条路径到右下角点的累加和最小

解法：暴力递归做法，从左上角点`(0, 0)`开始到任意点的最小路径和有四种情况，如果该点就是左上角点，那么值为`grid[0][0]`，否则如果它上面有点、左边没点，或者上面没点、左边有点，该点的值都是存在点的结果加上当前点的值，最后就是两个点都存在，用它们的最小值加上当前点的值

优化1：记忆化搜索，构建dp表，大小和原二维数组相同，保存中间计算结果

优化2：严格按照位置依赖关系的动态规划，因为第一行和第一列的值容易计算，是一行或一列的累加和，所以先设置好，然后剩余的点都是依赖上方和左边的dp表的值求该点的值

优化3：空间优化，二维dp表压缩为一维dp表，因为每个点自身可以表示它之上的点，所以每一行预先求出最左边的点即可

### 单词搜索

问题描述：给定一个二维网格，里面是一些字符，给定一个字符串，问二维网格是否存在一条路径可以匹配给定的字符串。网格不能重复经过

解法：在网格任意一个位置开始，开始尝试从4个方向开始匹配字符串的起始位置之后的字符，遍历过的字符需要临时标记，之后要恢复现场

这道题也能看出，带路径的递归就是鼓励暴力递归写法，数据量也不大

### 最长公共子序列

问题描述：给定两个字符串，返回这两个字符串的最长公共子序列的长度，子序列是从左往右依次选取任意长度的字符构成的序列，不要求连续

解法：暴力递归，在两个字符串的任意位置可以得到的最长公共子序列的长度，分情况讨论

- 如果任意字符串位置（索引）已经小于`0`，那么返回0，不可能构成最长公共子序列
- 如果不保留当前位置字符，那么结果是两个字符串的剩余子串的结果
- 保留A字符串最后字符，和B删除最后字符的剩余字符计算结果
- 保留B字符串最后字符，和A删除最后字符的剩余字符计算结果
- 保留最后字符，如果字符相同，则剩余子串加1就是结果，如果不相同就退回第一种情况

优化1：为了转化动态规划时减少边界条件的判断，可以将索引改变为字符串长度，并且分情况讨论也可以简化为3种

- 如果两个字符串任意长度为`0`，那么结果是0
- 如果要舍弃任意字符串的最后一个字符，那么它们的结果一定比都舍弃好，因为多一个字符，保留了长度更长的可能性
- 如果不舍弃字符，那么当最后一个字符相等时，它们的结果一定是剩余子串结果加1，因为直接匹配最后一个剩余的子串一定是剩余子串的公共最长子序列，如果不匹配最后的字符只会减少可能性

优化2：记忆化搜索，带dp表缓存

优化3：严格位置依赖的动态规划，填dp表

优化4：空间优化，二维dp表转一维，并且使用一个变量在遍历过程中记录左上角的值。dp表开始表示第一行的结果，在求解下一行时，某个变量先记录`dp[0]`为左上角值，

### 最长回文子序列

问题描述：给定一个字符串，查找这个字符串中最长的回文子序列长度（注意不是回文子串）

解法1：这道题可以等效为原字符和逆序字符串查找最长的公共子序列的长度，根据回文定义可知正确性

解法2：定义查找回文子序列的方式，即在`[l..=r]`区间上求最长的回文子序列，然后根据两端字符可以分情况讨论

- 如果`l == r`，那么结果为1
- 如果`l+1 == r`，那么如果`s[l] == s[r]`，结果为2，否则为1（任意一个字符本身也是一个回文子序列）
- 如果两端字符相同，那么返回`s[l+1..r-1]`的结果加2，否则返回左右任意舍弃一个字符后的结果的最大值

优化1：记忆化搜索

优化2：严格位置依赖的动态规划。本题中`l`和`r`有固定关系`l <= r`，所以之需要填写一半（带对角线）的dp表即可，并且当`l == r`或者`l + 1 == r`时，无需依赖其他格子即可求值，剩余的普通各自依赖自己下方、左边和左下方格子的值，所以可以按照从下往上、从左往右的填写方法

优化3：空间优化，和上题相似，压缩为一维dp表后，需要使用一个变量记录左下方格子的值

### 节点数为N高度不大于M的二叉树个数

问题描述：给定节点数`N`，给定限制树高`M`，问可以生成多少种树结构

解法：暴力递归的定义就是给定节点数和树高，返回树的结构个数。分情况讨论

- 如果节点数为0，那么返回1，因为空树作为一个结构可以在任意树高限制中存在
- 否则，如果树高为0，那么返回0，因为除了空树不可能存在其他结构
- 当根节点占据一个位置之后，左树和右树结合起来有`P(0..k) * P(k..0)`种可能性

优化1：记忆化搜索

优化2：严格按照位置依赖的递归。第一行和第一列按照固定答案填满，每个格子只需要`dp[0..N-1][M-1]`的数据，所以仍然可以从左到右填格子

优化3：空间压缩，👍使用一个长度为N的一维数组，从底向上填格子，这样没有被填的正好是前一列所需要的数据

这道题的时间复杂度是`O(M*N^2)`，最好的空间复杂度是`O(N)`，因为填每个格子的平均枚举时间和`N`有关

### 矩阵中的最长递增路径

问题描述：给定一个二维网格，找出其中的最长递增路径，只能从上下左右四个方向移动，因为是严格递增，所以不能重复走格子

解法：暴力递归，定义从任意点出发，从上下左右四个方向出发能达到的最长递增路径，得到的最大结果加1就是最终结果

优化1：记忆化搜索

因为每个点的枚举都依赖它的上下左右四个方向的结果，所以不好整理依赖关系，由于它的枚举次数最多只有4，所以在记忆化搜索就结束优化过程

## 更多二维动态规划题目

[code](./examples/55-two-dm-dp-pro-problem.rs)

### 不同子序列

问题描述：给定两个字符串`s`和`t`，返回`s`中有多少种子序列可以构成`t`

解法：这个问题可以转化为，求`s`的前`i`个位置的子串中有多少种子序列可以构成`t`的前`j`个字符构成的子串。那么在任意`i`和`j`位置，它的答案就是两种情况的和，一种是舍弃`s`的第`i`个位置字符仍旧匹配`t`的前`j`个字符的子串，另一种就是**仅当**`s[i] == t[j]`时，可以计算`s`的前`i-1`子串有多少子序列构成`t`的前`j-1`个字符的子串。这道题的基本case是，如果`t`的长度为0，那么任意`s`长度的结果都是1，因为空串一定是一个答案，否则如果`s`的长度为0，那么结果都是0，因为`t`的长度大于0

优化1：空间压缩的遍历顺序应该从右往左，因为每个格子仅依赖它左上和上面的格子

### 编辑距离

问题描述：给定两个字符串，对字符串支持三种操作：插入、删除、修改一个字符，问将A字符串修改为B字符串所需要的最少操作代价是多少

> 原题目三种操作的代价相等，但更通用的情况是每个操作不同代价，解法讨论考虑更通用的情况

解法：dp表定义为选取前`i`个字符的A子串转化为取前`j`个字符的B子串所需要的最小代价，假设两个字符串的长度为`N`和`M`，那么最终的结果就是`dp[N][M]`。分情况讨论如下

- A字符串`i-1`位置字符参与转换
  - 如果`A[i-1] == B[i-1]`：`dp[i-1][j-1]`
  - 如果`A[i-1] != B[i-1]`
    - `i-1`字符参与前`j-1`长度B子串匹配：`dp[i][j-1] + insert_cost`
    - `i-1`字符直接更新：`dp[i-1][j-1] + update_cost`
- A字符串`i-1`位置字符不参与转换：`dp[i-1][j] + delete_cost`

基本情况填充：如果A字符串为空，那么转换为B字符串只需要计算插入代价。如果B字符串为空，那么只需要计算删除代价

枚举过程可以根据情况优化，如果两个字符串（子串）的最后一个字符相等，那么最小代价一定是`dp[i-1][j-1]`，因为如果舍弃这种情况，一定有额外的代价处理`i-1`位置的字符，否则是剩下三种情况取最小值

空间压缩优化：参考[最长公共子序列](#最长公共子序列)的方式，一模一样

### 交错字符串

问题描述：给定三个字符串，判断A字符串和B字符串通过洗牌（不改变各自字符的相对次序进行组合）是否能组成C字符串

⚠️通过三指针遍历的方式验证是错误的，因为如果A、B字符串在某个位置字符是相同的，那么无法保证哪个字符串的下一个字符是正确的

解法：dp表定义是从A字符串中选取`i`个字符和B字符串中选取`j`个字符，是否可以组成C字符串中的`i+j`个字符。特判是如果A、B字符串的长度和与C字符串长度不相同就直接返回`false`。那么对于特定点的分情况讨论如下

- 如果使用A字符串的`i-1`位置字符匹配C字符串的`i+j-1`位置字符，那么结果就是`A[i-1] == C[i+j-1] && dp[i-1][j]`
- 如果使用B字符串的`j-1`位置字符匹配C字符串的`i+j-1`位置字符，那么结果就是`B[i-1] == C[i+j-1] && dp[i][j-1]`

上述两种情况任意满足则该点满足，如果都不满足则该点不满足

空间压缩优化：每个点依赖左边和上面的结果

### 有效涂色问题

> 大厂真题

问题描述：给定N、M两个参数，表示一共有N个格子，每个格子可以涂上一种颜色，颜色在M种里选。当涂满N个格子，并且M种颜色都使用了，叫一种有效方法。求一共有多少种有效的涂色方法，测试数据范围`1 <= N,M <= 5000`。结果要对`1e9+7`取模之后返回

解法：dp定义为总共`i`个格子使用了`j`种颜色的有效涂色方法，分情况讨论如下

- 如果第`i-1`个格子之前的所有格子已经填满了`j`种颜色，那么这个格子的涂色方法就是`dp[i-1][j]*j`种方法，**这里要注意不是有`M`种可能，因为在当前求解问题中，总共只有`j`种颜色**
- 如果第`i-1`个格子之前只涂了`j-1`种颜色，那么这个格子的涂色方法就是`dp[i-1][j-1]*(M-j+1)`种方法，因为总共有M种颜色，到最后一个格子可能还可以涂`(M-(j-1))`种颜色

结果就是两种情况下的可能性相加

基本情况：如果没有格子或者没有颜色，那么可能性都是0，如果`i`个格子需要填满`1`种颜色，那么结果都是`M`，如果`i`个格子要填`>i`种颜色，则为0种可能

空间压缩：依赖左上和上面的结果

对数器验证的暴力解法：带路径的递归，将所有的可能性都填出来，判读有多少种填法满足要求

### 删除至少几个字符可以变成另一个字符串的子串

问题描述：给定两个字符串A和B，问至少删除几个A字符串的字符可以得到B字符串的子串（连续）

解法：dp表定义为在A字符串的前`i`个字符组成的子串中至少删除几个字符可以得到B字符串的前`j`个字符组成的子串的后缀子串（**包括空串**），分情况讨论如下

- 如果A字符串的`i-1`位置字符等于B字符串的`j-1`位置字符，那么要保留这个字符，因为如果不保留则往前依旧要匹配这个字符，且删除次数会增加，即`dp[i-1][j-1]`
- 如果A字符串的`i-1`位置字符不等于B字符串的`j-1`位置字符，那么这个字符要删掉，结果为`1 + dp[i-1][j]`

这道题的答案需要在所有A字符串至少删除多少个可以组成B删除任意多个结尾字符后的子串的后缀子串中选取一个最小值

基本情况：如果A字符串长度为0，那么至少需要删除0个能组成B字符串的后缀子串（空串），否则如果B字符串长度为0，那么至少删除所有长度的A字符串

空间压缩：每个格子依赖自己的上边和左上格子的值

对数器验证：A字符串的所有子序列，找到最长的构成的子串且在B字符串中出现，那么用B字符串的长度减去这个子序列长度就是结果

## 从递归入手三维动态规划

[code](./examples/56-triple-dm-dp-problem.rs)

尝试函数有3个可变参数可以**完全决定**返回值，那么可以改进三维动态规划的实现

优化点和其它的动态规划是一样的，严格位置依赖和空间压缩

### 一和零

> 属于多维费用背包问题，因为1和0是两种费用，所以属于二维费用背包问题

问题描述：给定一个二进制字符串数组，其中每个字符串只包含0和1，还有两个整数`m`和`n`。求数组的最大子集满足最多不超过`m`个0和`n`个1的长度

解法：暴力递归尝试，尝试方法定义为选取`i`位置之后的所有字符串的最长子集来满足不超过`j`个0和`k`个1。分情况讨论如下

- 不选择当前字符串，那么结果是从下个字符串开始选择`dp[i+1][j][k]`
- 选择当前字符串，那么判断当前字符串包含多少0和1，如果已经超过当前限制，则结果为0，否则结果为`1 + dp[i+1][j-z][k-o]`

每次都返回两种情况的最大值。特殊情况是当`i`为数组长度时，已经没有字符串可以选择，所有结果都是0

优化点1：记忆化搜索，带一个三维dp表当缓存

优化点2：严格位置依赖的动态规划，因为每个格子的位置仅跟`i+1`（可以看作z轴）的格子有关系，所以`i`从数组长度开始往下计算，每一层的格子计算顺序任意安排

优化点3：空间压缩，用一张二维dp表来求解，并且由于选取字符串的顺序不重要，所以直接遍历字符串即可，每次遍历都按照从右往左，从下往上的顺序进行填格子，因为每个格子只有当当前的0、1数量满足限制才会有另外一种情况，所以判断时仅需`j`和`k`小于等于当前字符串的0、1值时更新格子，否则就仍为上一层的结果

### 盈利计划

问题描述：总共有`N`个工人，给定一个数组表示每个工作所需要的工人，另一个数组表示每个任务产生多少利润。如果一个工人参与了一个任务，那么它不能参与其它任务。给定一个最小利润，定义盈利计划为工人和任务的组合，要求参与工人不超过`N`个且总盈利不小于最小利润，问总共有多少个计划。结果需要对`1e9+7`取模

> 和上一题类似，也是多维01背包问题，每个任务选或不选，代价是使用工人和产生利润

解法：暴力递归尝试，定义参数`i`、`j`、`k`分别表示到第`i`个任务，要使用不超过`j`个工人，产生不超过`k`的利润的最小值，分情况讨论如下

- 不选择第`i`个任务，直接从下一个任务做尝试
- 选择第`i`个任务，如果当前任务所需人数超过限制，那么结果为0，否则扣掉工人和利润后，进行下一个任务的尝试。⚠️即使利润已经满足要求，由于工人和任务还有剩余，那么选择工人继续做任务也有有效计划，为了在严格位置依赖的动态规划中不出现无效索引，利润的变化使用`(k - profit[task]).max(0)`

两种情况构成的任务数相加就是该任务处构成的所有盈利计划的数量

特殊情况是当工人数量为0，如果剩余待完成利润小于等于0，那么返回1，否则如果任务数已经为0，那么判断待完成利润是否小于等于0，如果是返回1，否则为0

优化：严格位置依赖的动态规划结合空间压缩优化，基本上和上一题一样，每一层都依赖它上一层的格子

### 骑士在棋盘上存活的概率

问题描述：给定一个`N*N`的二维数组表示棋盘，骑士在棋盘上指定位置开始行动，它可以从8个方向走“日”字形，问在行走`K`次后，骑士能存活的概率是多少，只要骑士在走完`K`步后还在棋盘上就算存活

解法：定义问题为骑士在`(i, j)`位置上还剩`k`步要走的情况下的存活概率是多少，那么答案就是`dp[row][col][k]`，分情况讨论如下

- 如果骑士当前在非法位置，那么存活概率为0
- 否则如果骑士还有0步需要走，则返回1，否则计算它的下一步的所有可能性并除8就是结果

优化：空间优化是高层格子依赖底层格子，但是同一层格子的依赖是8个方向，所以可以使用两个dp表来交替更新，从底向上填充dp表

### 矩阵中和能被K整除的路径

问题描述：在一个二维矩阵中，从`(0, 0)`位置到`(N-1, M-1)`位置有多少条路径，它们的路径和可以被`K`整除，结果需要对`1e9+7`取模

解法：定义问题为在`(i, j)`位置上，它到右下角的所有路径的路径和对`K`取模的结果需要为`k`，这里有一个公式，当前位置对`K`取模的结果和剩余路径和对`K`取模的结果的关系是`remain = (K + k - (cur % K)) % K`，也可以分情况讨论，如果当前值模`K`的结果小于等于目标结果，那么剩余路径和模`K`的结果就是`K-cur`，否则是`k+K-cur`。分情况讨论如下

- 如果下一步走右边，那么计算右边的新模结果
- 如果下一步走下边，那么计算下边的新模结果

两种情况相加再模`1e9+7`即为该点结果

优化：由于纵轴固定长度为`K`，所以严格路径依赖的动态规划需要在基本情况一次性填满纵轴，如果已经到达右下角，那么当该点值模`K`为想要的结果时返回1，否则都是0，然后对最后一行和最后一列进行填充，最后再从下到上、从右到左依次填充。空间压缩意义不大，只能将每个格子中纵轴结果为0的省略掉

### 扰乱字符串

问题描述：对于任意字符串有如下扰乱规则：可以在字符串任意位置将分割为两部分（每部分都不能为空），然后对于各自部分依旧可以应用此扰乱规则，最终一个字符串根据扰乱规则构成的所有字符串都是它的扰乱串。问给定两个字符串A和B，判断B是否为A的扰乱串

⚠️本题不能利用贪心思路，比如看到扰乱规则觉得只要两个字符串的字符种类和数量相同就是扰乱串关系，因为它们第一级只能被划分为两部分，所以有些字符串一定满足不了某些字符的相对位置关系，例如`cadb`

解法：暴力递归使用的子问题定义是，在第一次分割字符串的情况下考虑，即A字符串的左边`ia`个字符构成的子串和B字符串的左边`ia`个字符构成的子串是否可以通过扰乱得到，且两个字符串剩余的子串能否通过扰乱得到，或者A字符串的左边`ia`个字符构成的子串和B字符串的右边`ia`个字符构成子串可以通过扰乱得到，且剩余两个字符串的子串可以通过扰乱得到，在两种大情况下，满足任意一种情况则表示两个字符串可以通过扰乱得到。基本情况是当两个字符串各自只有一个字符时，结果是直接比较两个字符是否相同

优化1：原始变量为4个，但是由于每次比较两个字符串的子串长度相等，那么将参数减少为两个字符串的起始位置和字符串长度即可

优化2：记忆化搜索，因为dp表需要表示任意点是否可以建立扰流关系的状态，还要判断该点是否访问过的状态，所以可以使用`0/1/-1`分别表示是否访问过、可以建立扰乱关系、不可以建立扰乱关系

优化3：严格位置依赖的动态规划，长度变量的范围最多不超过字符串长度，且每一层的格子仅依赖下层格子，所以直接从长度为1开始填格子即可。要注意填格子过程中，如果递归尝试不会访问的参数填格子时也不需要填，否则会导致访问数组元素越界。不能应用空间压缩优化，因为每层格子会依赖多层格子的值，需要全部保存

这道题的时间复杂度是`O(N^4)`，因为每个格子的枚举代价也是`O(N)`

## 子数组最大累加和与扩展

[code](./examples/57-subarr-maxsum.rs)

子数组最大累加和是一个经典问题，也比较简单，解法就是一维动态规划的应用。**但是扩展问题很多，在笔试、面试中很常见**

### 子数组最大累加和

问题描述：给定一个数组，求其中的任意子数组的最大累加和

解法：定义基本问题为以`i`位置结尾向前能构成的最大累加和，那么在任意位置的分情况讨论如下

- 如果选择加上`i-1`位置的最大累加和，那么答案是`arr[i] + dp[i-1]`
- 如果不加`i-1`位置的最大累加和，那么答案是`arr[i]`

两者取最大值即为任意位置的答案，基本情况是当`i == 0`，答案是`arr[i]`

#### 子数组最大累加和的扩展问题

问题描述：在求解子数组最大累加和过程中，需要返回累加和最大的子数组的最左、最右和累加和

解法：在计算过程中，每个位置如果前一位的答案大于等于0，则加上前一位的答案，不更新最左索引，如果前一位答案小于0，则不加前一位答案，更新最左索引，在计算过程中如果碰到更大的子数组累加和，那么更新最终的答案。这里要注意最开始的累加和设置为`i32::MIN`，这样在第一位的计算中一定不会和前一位答案相加，可以直接更新左索引记录

### 不能选相邻元素的最大累加和问题

问题描述：给定一个数组，可以任意选取元素，要求不能选取相邻元素，求最大的累加和

解法：定义基本问题为从`[0..=i]`范围上任意选取元素组成的**子序列**的最大累加和，在`i`位置上分情况讨论如下

- 如果选取`i`位置元素，那么结果是`(dp[i-2] + arr[i]).max(arr[i])`
- 如果不选择`i`位置元素，那么结果是`dp[i-1]`

选择两种情况的最大值即为该位置的答案

### 环形数组的子数组最大累加和问题

问题描述：与普通数组的子数组最大累加和问题相同，区别是数组的头尾相连

解法：这道题关键在于理清可能性的种类，对于环形数组，可能构成最大累加和的子数组有两种情况

- 子数组没有被隔断，即不同时包括头尾元素，那么求解方式和普通数组相同
- 子数组被隔断，即包括头尾元素，但是中间缺失，这种情况下应选择让缺失部分子数组的累加和最小，由于这部分是一个普通数组，所以可以直接计算，最后用整体累加和减去这部分的值就是答案

上述两种情况取最大值就是答案，有一个特殊情况是当所有元素都为负数，那么最小累加和的子数组就是原始数组，由于题目不允许选择的子数组为空，所以此时答案只取第一种情况，第二种情况的结果一定是0

### 环形数组中不能选相邻元素的最大累加和

问题描述：与普通数组的不能选相邻元素的最大累加和问题相同，区别是数组的头尾相连

解法：唯一需要考虑的地方是第一个位置的元素，分情况讨论如下

- 如果选择第一位的元素，那么剩余范围就是`arr[2..=n-2]`，在这个子数组使用计算普通数组的不能选相邻元素的最大累加和方法即可
- 如果不选择第一位元素，那么剩余范围就是`arr[1..=n-1]`，计算方法同上

上述两种情况取最大值就是答案

⚠️这道题和上一道题都是需要将环形数组计算过程等效为非环形数组的计算过程加上特例判断，基本思路是要将答案怎么尝试（可能性）列出来

### 打家劫舍IV

问题描述：打家劫舍问题的基本描述就是不能选相邻元素求子数组最大累加和，这道题给了小偷一个“偷窃能力”的定义，即小偷只能偷金钱小于等于他能力的房屋，问最少给多少能力他能偷到至少`k`座房屋

解法：能力的范围是有限制的，即所有房屋中的最少金钱数到最多金钱数`[min_money..=max_money]`，超出这个范围对于解题没有意义。因此可以利用[二分答案法](#二分答案法与相关题目)来构建外层结构，子问题是给定一个能力值，判断小偷最多可以偷多少家，如果这个值大于等于`k`，那么记录答案往左找，如果小于`k`，直接往右找，最终返回答案

优化点：子问题可以使用动态规划求解，类似普通的打家劫舍问题，但这里需要注意求的是房屋数量而不是金钱数。也可以使用贪心求解，因为给定能力值后，对任意位置房屋，小偷只要能偷就偷，最终一定可以偷到最多的房子，因为对于任意两个房子，如果都满足能力条件，偷前一家会比偷后一家给之后偷窃行为留下更大的可选范围

时间复杂度是`log(max_money - min_money + 1) * N`

### 子矩阵最大累加和问题

问题描述：给定一个二维矩阵，求其中累加和最大的子矩阵的位置，返回左上角和右下角点的位置

解法：暴力解法就是将所有可能的子矩阵全部遍历一遍，时间复杂度为`O(N*M*N*M)`。求子矩阵累加和可以转化为从每行开始，先求本行的累加和，然后和依次和下一行累加再计算累加和，遍历完每一行之后，中间出现过的最大的累加和就是答案，因为任意子矩阵也一定是选择任意两行作为头尾组成的，它们合并完后的数组的子数组最大累加和就是这两行构成的子矩阵的最大累加和

时间复杂度为`O(N^2*M)`，空间复杂度为辅助数组长度`O(M)`

### 乘积最大子数组

> 原题数据类型为整数，以下讨论也同样支持浮点数类型

问题描述：给定一个数组，求数组中乘积最大的非空子数组，并返回这个最大的乘积

解法：定义问题为求解以任意位置`i`结尾向前能构成的乘积最大的子数组的乘积，首先`i`位置的元素一定要保留，因为题目要求的是非空子数组，分情况讨论如下

- 如果仅保留`i`位置，那么结果就是`dp[i]`
- 如果`i`位置是负数，那么希望使用以前一个元素结尾得到的最小乘积（正收益）
- 如果`i`位置是正数，那么希望使用以前一个元素结尾得到的最大乘积（正收益）

最终结果取上述三种情况的最大值。基本情况是当数组只有1个元素，最大最小值都是它自己

### 子序列累加和必须被7整除的最大累加和

问题描述：给定一个非负数组，可以选择任意元素组成子序列，要求子序列必须能被7整除，问子序列的最大累加和是多少

解法：定义问题为数组前`i`个元素中对7取模的结果为`j`的子序列的最大累加和，分情况讨论如下

- 如果不选择`i-1`位置的元素，那么`dp[i][j] = dp[i-1][j]`
- 如果选择`i-1`位置的元素，那么`dp[i][j] = dp[i-1][(j+7-(arr[i]%7))%7] + arr[i-1]`，这里需要确保后面的情况存在，即dp表的值不为`-1`

最终结果是上述两种情况的最大值。基本情况是当`i`为0时，对7取模只能为0，`-1`表示不存在累加和模7为`j`的子序列

时间复杂度为`O(N)`，因为取模部分是常数。空间压缩可以使用两个一维数组交替计算

暴力解法验证：将所有子序列中累加和能被7整除的最大值得到即可

### 魔法卷轴

问题描述：给定一个数组，其中有正数、负数和0，并且有两个魔法卷轴，效果是可以将任意子数组全部变成0，问在最多使用两个卷轴的情况下可以得到的数组最大的累加和是多少

解法：根据卷轴的使用次数分情况讨论如下

- 不使用卷轴，那么计算数组累加和就是结果
- 使用一次卷轴，定义问题为在`arr[0..=i]`上只使用一次卷轴能得到的最大累加和，分情况讨论如下
  - 如果`i`位置元素不参与卷轴效果，那么结果是`dp[i-1] + arr[i]`
  - 如果`i`位置元素参与卷轴效果，那么结果是遍历过程中的最大累加和。**这里要注意特殊情况，如果之前的最大累加和比0都小，那么之前的所有元素都要参与卷轴效果**
- 使用两次卷轴，这种情况可以保证两个卷轴的效果一定不重叠，因为如果重叠就表示可以等效为只用了一次卷轴的效果，所以可以遍历数组，每个点都作为分割点，得到`[0..=i]`和`[i+1..=N-1]`两个范围上用一次卷轴得到的最大累加和的和

最终结果是上述三种情况的最大值。对于第三种情况，可以提前计算出从`[i+1..=N-1]`位置上如果必须使用一次卷轴可以得到的数组最大累加和，这样在分界点遍历的时候可以直接查表，计算方式按照之前的计算方式倒序计算

时间复杂度为`O(N)`，因为每个操作都是遍历一次数组，相加还是`O(N)`的时间复杂度

暴力解法验证：已任意节点分割数组，对两个子数组进行卷轴使用组合，将所有结果的最大值返回

### 三个无重叠子数组的最大和

问题描述：给定一个整数数组和一个整数`k`，返回三个长度为`k`且互不重叠且它们的累加和最大的子数组，返回值为三个子数组的起始位置下标，**如果有多个结果返回返回字典序最小的一个**

解法：在`[0..i]`范围上求解长度为`k`的累加和最大的子数组的初始位置，同样求解`[i+1..N-1]`范围上长度为`k`的累加和最大的子树组的初始位置，两个子结果求出来之后遍历数组，每个点往右延伸`k`长度作为中间数组，然后从左右依次选择累加和最大的初始位置，根据最大值变化更新答案。本题需要构建一个以`i`位置开头长度为`k`的子数组的累加和的辅助数组来方便后续计算。以`[0..i]`范围上求解长度为`k`的累加和最大的子数组的初始位置为例，分情况讨论如下

- 如果子数组包含`i`位置的元素，那么需要判断`if ksum[i-k+1] > ksum[dp[i-1]] { i-k+1 }`，否则结果是`dp[i-1]`
- 如果子数组不包含`i`位置的元素，那么结果是`dp[i-1]`

最终结果取两种情况的最大值，基本情况是`[0..k]`范围上结果都为0

### 可以翻转1次的情况下子数组最大累加和

问题描述：给定一个数组，允许随意翻转一个子数组（逆序），求必须翻转一次之后子数组的最大累加和

解法：首先必须翻转一次和不翻转实际上没有区别，因为对单个字符的翻转等同于不翻转。并且有两种翻转对于求解子数组最大累加和无意义，一种是翻转子数组范围在新数组的最大累加和子数组之间，一种是翻转子数组范围完全包含新数组的最大累加和数组（答案分析法，排序可能性）。由此可知，如果想要实现翻转后子数组的最大累加和增大，那么翻转的子数组和新数组的最大累加和子数组一定有一个分界点。那么翻转后的子数组最大累加和就是分界点前的最大子数组累加和和分界点之后的最大子数组累加和之和，求一个最大值即可，**结果要跟原始数组的子数组最大累加和做比较**

这道题需要求以`i`为开头的所有子数组的最大累加和和以`i`结尾的所有子数组的最大累加和作为查表前提

暴力解法验证：将任意子数组翻转，得到翻装后的最大累加和进行判断

### 删掉1个数字后长度为k的子数组最大累加和

问题描述：给定一个数组，求必须删除一个元素后的新数组中长度为`k`的子数组的最大累加和，可以删除任意元素

解法：使用一个长度为`k+1`的窗口遍历数组，另外维护一个单调队列保存窗口的最小值，每次移动窗口并减掉队列中的最小值，取结果的最大值

暴力解法验证：删除任意元素之后求解子数组最大累加和

## 最长递增子序列与扩展

[code](./examples/58-longest-increase-sub.rs)

[code](./examples/58-fix-longest-increase-sub.rs)

### 最长递增子序列模版

题目描述：给定一个数组，求其中的最长递增子序列和最长不下降子序列长度

对于求解一个数组的最长递增子序列长度，先定义求解问题为以`i`位置元素结尾的最长递增子序列长度，那么求解每个`i`位置的结果的过程就是，基本情况为`dp[0] = 1`，当`i > 0`时，遍历之前的所有元素，如果比当前元素小，则`dp[j] + 1`就是当前元素可能的结果，向前遍历完找到最大值更新dp即可，这种方式的时间复杂度为`O(N^2)`，空间复杂度为`O(N)`

优化方式为准备一个数组`aid`，每个位置的元素表示`i+1`长度的最长递增子序列**最小的结尾元素**。dp定义同上，求解dp的过程如下

1. `dp[0] = 1`
2. 在`aid`中查找大于等于`arr[i]`的最小元素的索引`j`
   1. 如果找到（`j == x`）就将`arr[i]`的值**更新**到`aid[j]`中，并且`dp[i] = j + 1`
   2. 如果没有找到（`j == -1`）就将`arr[i]`的值**插入**到`aid`中，并且`dp[i] = aid.len()`
3. 最终dp数组中的最大值就是结果

原理：每当遍历一个元素时，如果它的值大于所有之前的长度更短的最长递增子序列的最大元素，它本身就可以扩展最长递增子序列长度，所以要插入`aid`，如果它的值小于等于某个长度更短的最长递增子序列的最大元素，那么它就可以替换掉那个元素，以帮助后面的元素更容易地从那个长度往后扩展递增子序列，只要找到满足条件且**长度更长**的递增子序列位置即可

`aid`数组一定是严格递增的排列顺序，因为按照上面的规则，要插入的元素一定会大于已有的所有元素，所以在这个数组上查找小于等于某个值的最右位置可以使用二分搜索

优化算法的时间复杂度为`O(N*logN)`，空间复杂度为`O(N)`

#### 最长不下降子序列

只需要修改二分搜索策略为，仅查找比当前数更大的`aid`数组的元素的位置即可

### 俄罗斯套娃信封

问题描述：给定一个二维数组，`arr[i] = [wi, hi]`表示第`i`个信封的宽度和高度，当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。求最多能有多少个信封能组成一组“俄罗斯套娃”信封，注意每个信封不能旋转，必须按照指定宽高处理，即不允许做`[wi, hi] => [hi, wi]`转化

解法：首先按照宽度将所有信封排序，当宽度相同时要按照高度逆序排序。然后对结果数组的高度部分求最长递增子序列长度就是答案

排序结果的高度部分构成的子数组的最长递增子序列一定符合题目要求，分情况讨论如下

- 如果宽度相等，那么两个信封一定不会在同一个子序列，因为高度高的都在前面，不会统计到后面高度低的递增子序列中
- 如果宽度小
  - 高度相等，两个信封不在同一个子序列，因为相同高度一定不会在同一个递增子序列
  - 高度小，两个信封一定会统计到同一个子序列，因为那个高度小的在高度大的前面
  - 高度大，两个信封不在同一个子序列，因为高度大的信封不会进入后面高度小的信封的递增子序列
- 如果宽度大
  - 高度相等，两个信封不在同一个子序列
  - 高度小，两个信封不在同一个子序列，因为宽度大且高度小的在后面，宽度小高度大的信封不会统计到它的子序列
  - 高度大，两个信封一定会统计到同一个子序列，因为宽度大高度大的在后面，宽度小高度小的信封会统计到它的子序列

由上述分析可知，高度数组的最长递增子序列一定是可以组成套娃信封的最大可能数量

### 使数组K递增的最少操作次数

问题描述：给定一个正整数数组和一个正整数`k`，如果对于每个位置`k <= i <= n-1`，都有`arr[i-k] <= arr[i]`，那么称数组对于`k`递增，每次操作可以选择一个位置将其改为任意其他正整数。求让数组变成k递增的最少操作次数

解法：这道题可以将整个数组分成`k`个小组，每个小组的变化相对于其他小组是没有关系的，所以求出每个小组的最长不下降子序列长度，用它们本身的长度减去这个子序列长度就是需要的操作次数，因为要使用最少的操作将整个小组改为不下降子序列，只要基于最长不下降子序列的元素调整剩下的不满足要求的元素即可

### 最长数对链

问题描述：给定一个数对数组，每个数对关系是`(left, right) => left < right`，定义一种跟随关系，当且仅当`b < c`时，`(a, b) < (c, d)`关系成立，用这种关系构造一个数对链，找出并返回能够形成的最长数对链的长度

解法：这道题利用了求解最长递增子序列的一个技巧，即对辅助数组比较和插入的值不同。本题中先以`left`将数对数组排序，将首个数对的`right`放入辅助数组，开始遍历数对，使用`left`查找是否有大于等于它的最小开始元素，如果没有则插入`right`，如果有再判断`right`是否小于该位置的值，如果小于将`right`更新到该位置，即替换之前的数对。因为先对`left`排序，所以对于相同`left`的数对，保证以最小的`right`去和后面的数对形成最长递增序列即可

最快解法：使用贪心考虑，将整个数组按照`right`排序，遍历一次数组，如果后面数对的`left`不能跟前面构成数对链就舍弃，否则累加

### 有一次修改机会的最长不下降子序列

问题描述：给定一个数组和一个整数`k`，只有一次机会可以将连续`k`个数全部修改为一个值，可以选择修改或者不修改，返回最长的不下降子序列长度

解法：首先有一个前提是修改一定比不修改的结果更好，因为在原始的最长不下降子序列中，任意两个元素中间的其它元素都可以被修改为和后一个元素相同来的扩展子序列。那么在一定修改的情况下，对于每个位置的元素，将它前面的`k`个元素修改为跟它一样之后，这`k`个元素加上这些元素之前的**小于等于这些元素的**最长不下降子序列的长度以及**以这个元素为首**的最长不下降子序列长度就是当前位置决定的最长不下降子序列长度，遍历完数组即可得到答案。还有一种特殊情况就是只有最后`k`个元素被更新，这种情况不需要计算之后的最长不下降子序列长度

> 对于求解以任意位置开头构成的最长不下降子序列，实际上就是相反的以任意位置结尾构成的最长不上升子序列，查找辅助数组中小于当前数字的最大元素，并且**辅助数组是从大到小排列**

这道题要注意在任意一个分界点，如果它自身在左边的最长不下降子序列没出现，那么左边的统计长度为最长不下降子序列的当前长度，如果出现，就是那个位置表示的长度`i+1`。在求解最长不上升子序列时，由于是求dp表，在更新时如果当前位置数字出现在辅助数组中，那么dp表的值要更新为该位置加1

## 01背包、有依赖的背包

[code](./examples/59-01packet-tmpl-lg.rs)

[code](./c/summer.c)

[code](./examples/59-01packet-deppacket.rs)

[code](./examples/59-deppacket-tmpl-lg.rs)

### 01背包模版题

问题描述：01背包就是每个物品只能选择一次的情况下，计算在满足代价限制的情况下能得到的最大收益。给定一个正数`t`，表示背包容量，有`m`个货物，每个货物可以选择一次，且每个货物有自己的体积`costs[i]`和价值`values[i]`，求在不超过总容量的情况下，挑选货物得到的最大价值

解法：定义基本问题为前`i`个物品中选择容量和为`j`的物品能得到的最大价值，分情况讨论如下

- 如果不选择第`i`个物品，那么结果为`dp[i-1]`
- 如果选择第`i`个物品，且选择后剩下的容量`j - costs[i] >= 0`，结果为`dp[i-1][j-costs[i]] + values[i]`

基本情况是如果只有0个物品，那么得到的最大价值总是零。空间压缩优化后每一行从右往左计算即可

> 01背包的时间复杂度都是`O(物品个数 * 背包容量)`，空间复杂度是`O(背包容量)`

### 夏季特惠

问题描述：你有X的预算，平台上有N个游戏均有折扣，每个游戏有原价和折扣价a和b，有关系`a >= b`，购买每个游戏的快乐值为w，由于优惠存在，你可能会有一些冲动消费导致购买游戏费用超过总预算，只要满足获得的总优惠金额不低于超过预算的总金额心理上就不会觉得吃亏，问在不吃亏的前提下能获得的最多快乐值

解法：由于心理不吃亏的判断依据是获得的优惠不低于超出的预算，那么假设预算为0，只要优惠金额大于花费金额就一定不吃亏，那么所有满足此限制的游戏都可以优先购买，此时剩下的游戏选择就转化为一个01背包问题，之前购买的游戏剩余的心理预期金额会添加到原始的预算中，而剩余的游戏的花费则应该被转化为`-(sale[i] - discount[i] - discount[i])`，含义在于剩下的游戏买就会亏，而预算是限制能亏多少的上限，定义基本问题为前`i`个游戏花费`j`的预算可以获得最大快乐值，直接套用01背包模版解题即可

### 目标和

问题描述：给定一个非负整数数组和一个整数`target`，向数组中的每个整数前添加`+`或`-`，然后串联所有整数，返回能串联起来结果为`target`的表达式的可能性有多少种

解法1：暴力递归尝试，定义问题为在第`i`个数上，将其变为正数或者负数之后，剩余的数字能组成`target`的可能性，分情况讨论如下

- 如果`i == arr.len() && sum == target`，那么返回1，否则返回0
- 将`sum`累加上`arr[i]`或者累加上`-arr[i]`之后，求解剩下的数

基本情况是到达最后一个数字的累加和，如果等于`target`，那么可能性为1，否则为0

优化1：记忆化搜索，由于第二个参数，即当前的累加和可能是负数，所以dp表不能使用二维数组（需要转换），使用一个二级哈希表来记录即可

优化2：严格位置依赖的动态规划，这里需要使用**平移技巧**，由于累加和是有限制的，即最大值最小值是全部数的累加和与其负数，那么将求解过程中的累加和参数统一向右移动这个数字即可

解法2：对题目进行分析可以得出一些结论

1. 数组中是否存在负数对于结果没有区别，因为负数在运算中也可以变成正数，所以这道题只关心每个元素的绝对值
2. 数组中元素的正负变更不影响结果的奇偶性，所以如果所有数的累加和的奇偶性和`target`不同，那么可能性为0
3. 数组的最大累加和如果小于`target`或者最小累加和如果大于`target`，那么可能性为0
4. 将可能性分为正数集合`sa`和（转变为）负数集合`sb`，那么有关系`Sum(sa) - Sum(sb) = target`，对两边加上`Sum(sa) + Sum(sb)`得到`2 * Sum(sa) = target + Sum(sa) + Sum(sb)`，所以`Sum(sa) = (target + Sum(all))/2`，此时将问题转换为在集合中选择一个和为`(target + Sum(all))/2`的子集的可能性，这就成为了一个01背包问题，定义基本问题为前`i`个元素和为`j`的可能性，分情况讨论如下。基本情况是如果没有元素，只有组成`0`的时候可能性为1，其它都为0
   1. 如果不需要`i`位置元素，结果为`dp[i-1][j]`
   2. 如果需要`i`位置元素，结果为`dp[i-1][j-arr[i]]`

### 最后一块石头的重量 II

问题描述：有一堆石头，每个石头都有自己的重量，当两个石头碰撞时，如果重量相等那么不会残留新石头，如果质量不相等，那么重量更大的石头会剩下自身重量减去重量更小的石头的重量，问如何碰撞可以让全部石头剩下的数量最少

解法：因为石头是两两相撞，所以所有的碰撞可以等同于将石头分为两堆，各自内部碰撞完成后再进行碰撞。那么为了使剩余石头的重量最小，两组石头的重量差应该尽可能小，即要找出一个组，它们的重量满足`weight <= SumAll/2`的关系并且重量仅可能大。这是一个01背包问题，定义问题为前`i`个石头在重量不超过`j`的情况下最大的重量是多少，分情况讨论如下

- 如果不要`i`位置的石头，那么结果为`dp[i-1][j]`
- 如果要`i`位置的石头，那么结果为`dp[i-1][j-arr[i]] + arr[i]`

最终结果需要取两种可能性的最大值，基本情况是如果不选择石头，最大重量都是0

### 有依赖的背包模版题

> 有依赖的背包是值物品选择有依赖关系，多个物品会组成一个复合物品，但是不同的复合物品不会有重叠，选择过程变为**不要**和**怎么要**的展开

问题描述：物品分为两大类，主件和附件，主件购买没有限制，有钱就可以。附件购买则必须先购买其附属的主件。每个主件最多有2个附件，且附件不会再包含附件。每个物品有三个信息：价格、重要度和归属。物品编号从1开始，如果归属为0则表示其是主件，收益使用“价格*重要度”表示。求在不违反购买规则的情况下，给定总钱数N，可以达到的最大收益

解法：定义基本问题为前`i`个物品价格不超过`j`可以达到的最大收益，分情况讨论如下，这里只需要考虑主件即可

- 如果不买第`i`个物品，那么结果是`dp[i-1][j]`
- 如果购买第`i`个物品，则有以下几种展开
  - 只购买第`i`个物品，结果是`dp[i-1][j-arr[i]] + vals[i]`
  - 这个物品有附件1，只购买该附件，结果为`dp[i-1][j-arr[i]-assis[ii]] + vals[i] + vals[ii]`
  - 这个物品有附件2，只购买该附件，结果为`dp[i-1][j-arr[i]-assis[ij]] + vals[i] + vals[ij]`
  - 这个物品有附件1和附件2，全部购买，结果为`dp[i-1][j-arr[i]-assis[ii]-assis[ij]] + vals[i] + vals[ii] + vals[ij]`

结果取所有情况的最大值，为了方便记录可以使用一些辅助数组。基本情况就是不购买任何物品，收益全部为0

- `kings`：该编号的物品是否主件
- `fans`：该编号如果是主件，存在几个附件
- `fellows`：该编号的附件具体有哪些？使用它们的编号表示，是一个长度为2的数组

### 非负数组前k个最小子序列累加和

问题描述：给定一个仅包含非负数的数组，求前k个最小的子序列累加和，子序列包括空集。数组长度在1~10^5，数组元素的大小在1~10^6，k的范围和数组长度相同

解法：理论上使用01背包可以求解，定义问题为前`i`个数在累加和为`j`的情况下有多少个子序列，分情况讨论如下

- 如果不保留`i`位置元素，那么结果为`dp[i-1][j]`
- 如果保留`i`位置元素，那么结果为`dp[i-1][j-arr[i]]`

最终结果是两种情况相加，基本情况是当没有元素，只能构成累加和为0的1个子序列，其余都为0。最终只要从`j=1`开始将前`k-1`个累加和拿到即可

⚠️由于题目中的要求，如果使用01背包的解法，求解时间会超过10^7~10^8数量级，所以不能使用此解法

优化解法：先对数组进行排序，然后使用一个最小堆，开始遍历数组，将第一个元素的数组坐标和值进入堆（堆中元素按照值排序），然后出堆元素计入答案，将它的下一个元素进堆，也将它和它的下一个元素的和进堆，数组坐标总是取累加和最右边元素的坐标。这种解法一定要求数组中只有非负数，一旦数组中有负数，那么负数相加还是负数，也就是更小的累加和会出现在后面。时间复杂度为`O(N*logN) + O(k*logk)`

## 分组背包、完全背包

[code](./examples/60-group-packet-tmpl-lg.rs)

[code](./examples/60-whole-packet-tmpl-lg.rs)

[code](./examples/60-purchase-hay-lg.rs)

[code](./examples/60-group-packet-whole-packet.rs)

### 分组背包模版题

> 分组背包是所有物品需要分组，每组只能取一件物品，时间复杂度不会升阶

题目描述：给定N件物品，限制重量为M，每件物品有重量、价值和组数，每组只能选取一件物品，求满足重量限制的条件下可以得到的最大价值是多少

解法：先对物品按组号排序，定义基本问题为前`i`组在不超过重量`j`的情况下可以的到的最大重量

- 如果不在第`i`组选择物品，那么结果为`dp[i-1][j]`
- 如果在第`i`组选择物品，那么需要遍历第`i`组的所有物品，得到各自的可能答案`dp[i-1][j-arr[i]] + weight[i]`

当前组的最终结果取上面所有可能性的最大值。基本情况是如果不选任何组则价值为0

### 从栈中取出K个硬币的最大面值和

问题描述：桌子上总共有N堆硬币，可以将一堆硬币看成一个栈，取硬币只能从栈顶开始。给定一个正整数`k`，求恰好进行`k`次操作（取硬币）之后能得到的最大的硬币面值之和

解法：可以将每组可以执行的操作次数看成背包，这样每堆硬币就转化为操作0次、1次...可以得到的总面值，此时就讲问题转化为分组背包。定义问题为前`i`组操作次数等于`j`可以得到的最大硬币面值之和，分情况讨论如下

- 如果不在第`i`组进行操作，结果为`dp[i-1][j]`
- 如果在第`i`组操作，只有当该组操作满足剩余的操作数时，尝试得到结果`dp[i-1][j-k] + arr[k]`

最终结果取所有情况的最大值。基本情况是当不选择任何操作时，得到的最大硬币面值是0

### 完全背包模版题

> 完全背包是在01背包的问题基础上，每个物品都可以选择**无限次**

问题描述：给定一个正数`m`表示背包容量，有`n`种货物，每种货物有自己的体积和价值，每种货物可以选择任意个，求在不超过总容量的情况下可以得到的最大价值

解法：定义基本问题为**编号`1~i`的物品**中，不超过容量`j`的最大价值是多少，分情况讨论如下

- 不选择编号`i`的物品，那么结果是`dp[i-1][j]`
- 选择编号`i`的物品，那么结果是`dp[i][j-arr[i]] + arr[i]`，因为在选择了`i`编号物品之后，容量变小，但是可选编号的范围仍然在`1~i`中，⚠️基本问题的定义不再是前`i`个物品，而是编号`1~i`的物品

最终结果取两种情况的最大值。基本情况是如果没有物品，那么价值为0

### 正则表达式匹配

问题描述；给定字符串s和字符串p，s中一定不包含“.”和“\*”字符，p中可能包含这两个字符，“.”可以变成单个任意其他字符，“\*”可以重复它之前一个字符0~n次，p中的字符不会以“\*”开头，也不会出现两个或以上“\*”相邻的情况，问是否可以用p字符串完全匹配s字符串

解法：定义基本问题为判断s字符串`i`位置之后的字符串是否能被p字符串`j`位置之后的字符串完全匹配。分情况讨论如下

- 如果`i >= s.len() && j >=p.len()`，返回`true`
- 否则如果`j >= p.len()`，那么无法再继续匹配任何字符串，返回`false`
- 否则如果`i >= s.len()`，如果`j + 1 < p.len() && p[j+1] == '*'`，那么结果返回`match(i, j+2)`，否则返回`false`
- 否则如果`j+1 < p.len() && p[j+1] == '*'`，那么这是一个完全背包问题
  - 不保留`j`位置的值，返回结果`match(i, j+2)`
  - 如果`s[i] == p[j] || p[j] == '.'`，保留`j`位置的值，返回结果`match(i+1, j)`
- 否则返回`(s[i] == p[j] || p[j] == '.') && match(j+1, i+1)`

最后需要的答案是`dp[0][0]`，基本情况是如果`i == s.len()`，判断`j + 1 < p.len() && p[j+1] == '*'`，如果为`true`，那么结果是`dp[i][j+1]`，否则返回`false`，`j == q.len()`处为`true`

### 通配符匹配

问题描述：给定字符串s和字符串p，s中一定不会含有“?”和“\*”字符，p中可能含有这两个字符，“?”表示可以变成1个任意字符，“\*”表示可以匹配任何字符串，问是否可以用p字符串完全匹配s字符串

解法：和上一道题一样，定义基本问题为s的`i`位置后字符串用p的`j`位置后字符串来匹配，分情况讨论如下

- 如果`i >= s.len() && j >= p.len()`，返回`true`
- 否则如果`j >= p.len()`，返回`false`，因为p中没有字符串再去匹配s了
- 否则如果`i >= s.len()`，如果`p[j] == '*'`则返回`match(i, j+1)`，否则返回`false`
- 否则如果`p[j] == '*'`，这是一个完全背包问题
  - 不保留`j`位置的值，则返回`match(i, j+1)`
  - 保留`j`位置的值，则返回`match(i+1, j)`
- 否则返回`(s[i] == p[j] || p[j] == '?') && match(i+1,j+1)`

最后的答案是`dp[0]`，基本情况是当s字符串已经为空，如果`p[j] == '*'`，则返回`dp[j+1]`，否则返回`false`，除了`j == p.len()`处为`true`

### 购买足量干草的最小花费

问题描述：有N个公司提供干草，每个公司购买一次需要花费`cost[i]`，得到干草`vals[i]`，每个公司的产品可以购买任意次，问至少购买`h`数量干草最少要花的钱数

1. 前i号公司购买`h`数量干草所需要花费的最少钱数
2. 前i号公司至少花`x`钱数可以购买的最大干草数

以上两种基本问题定义都可以解题，但是根据数据量，公司数量是100，单位干草是5000，单位干草价格也是5000，`h`的范围是50000，如果是第二种问题定义，那么花费的钱数至少是50000\*5000，还需要乘公司数量，时间复杂度明显更高，而第一种问题定义，则是100\*50000，后续再扩展一点，不会超过规定的时间复杂度（`10^7~10^8`）

解法：有上述分析可知基本问题定义为前`i`号公司购买`h`数量干草所需花费的最少钱数，由于如果只购买`h`数量干草，很有可能没有有效答案，所以干草数量就应该更多，为了满足能在最满足不够`h`数量干草的基础上每个公司都可以购买干草，所以使用他们售卖的干草数的最大值加到`h`上，计算完之后，在`dp[h]`之后选取最小值就是答案。分情况讨论就是完全背包的基本流程

## 多重背包、混合背包

[code](./examples/61-multi-packet-tmpl-lg.rs)

[code](./examples/61-multi-packet-monoq-lg.rs)

[code](./examples/61-sakura-lg.rs)

[code](./c/coins.c)

### 宝物筛选（不优化）

> 多重背包就是每种物品只能选有限次

问题描述：一共有N种货物，限制容量为t，每种货物有价值、重量和数量。求货物在不超过背包容量的情况下能得到的最大价值

解法：定义基本为`1~i`号货物在不超过`j`容量的前提下能得到的最大价值，分情况讨论如下

- 如果不需要`i`号货物，那么结果就是`dp[i-1][j]`
- 如果需要`i`号货物，那么需要`1~nums[i]`种可能，每一种的结果是`dp[i-1][j-nums[i]*weight[i]]`

最终结果要取所有情况的最大值，基本情况为没有货物，价值总是为0。时间复杂度`O(t*N*avg(nums))`，这个复杂度无法通过题目

### 宝物筛选（二进制分组优化）

对于任意一个物品，可以使用一个二进制组来表示它的数量，第一组1个、第二组2个、第三组4个...最后不够的为一组，这样所有组可以组合出这个物品任意的方案，就像二进制表示十进制数一样。这样就将原问题转化为一个01背包问题，按照01背包问题解法求解即可

时间复杂度为`O(t*log(avg(nums)))`，会比`O(t*N)`差一点

#### 观赏樱花🌸

问题描述：每棵樱花树有花费时间、美学价值和最多能看多少次的限制，如果次数为0表示可以无限看，总时间限制为1000，求在不超过时间限制的情况下能得到的最大美学价值是多少

解法：使用二进制分组优化，在解题之前需要将不限制观看次数的樱花树的次数设置成1000，因为总共时间也只有1000，即使某棵树可以无限次观看，它的上限也就是1000，此时原问题就转化为了多重背包问题，按照上述思路解题即可

### 宝物筛选（单调队列优化）

在求解任意编号`i`物品满足不同的限制的时候，根据上面的分析可知，只需要`i-1`编号物品的若干结果，而这些结果的特点是限制为物品重量的（数量+1）的倍数。比如当一个物品有4个，重量为3，求解`dp[i][100]`就只需要`dp[i-1][100]`、`dp[i-1][97]`、`dp[i-1][94]`、`dp[i-1][91]`、`dp[i-1][88]`，其它的结果没有影响，那么原始求解过程可以变成将以重量取模范围对每个范围进行求解`[0..cost-1]..=(cost*num).min(limit)`

比如`i`物品的重量是3、价值是5、数量是4，背包容量为20，`dp[i][20] = (dp[i-1][20] + 0*5).max(dp[i-1][17] + 1*5).max(dp[i-1][14] + 2*5).max(dp[i-1][11] + 3*5).max(dp[i-1][8] + 4*5)`，此时只需要维护一个单调队列，总是能拿到它们的最大值即可，当窗口移动到`dp[i][23]`，只要把`dp[i-1][8]`移除即可，由于进入单调队列的值一直在变化，所以要想办法通过它们的`j`的值来计算，那么进入单调队列的值可以转化为`dp[i-1][j]-j/3*5`，最后再用得到的最大值加上`jr/3*5`，正好对应它们各自代表的选取该物品的个数。**注意单调队列如果维护的是值，且判断时使用了大于等于（找最大值），那么当后面的元素进队列时可能会将原始队头元素弹出，但是当真正出窗口的元素的值和队尾元素值相同时就会将刚插入的队尾元素弹出，所以需要使用大于判断，保证不会出现这种情况，使用索引维护就完全不会出错**

对于空间压缩的算法，需要从右往左计算，原理同上。先将数量个结果放入单调队列，再开始求值，时间复杂度为`O(t*N)`

### 能成功找零的钱数种类

问题描述：每一种货币有面值和数量，给定不同的钱数`m`，问在`1..=m`中这些货币是否能成功找零

解法：当一种货币数量仅有1张，那么就是01背包问题，选或者不选，如果一种货币的数量加起来的钱数超过了限制数，可以认为是完全背包问题，可以无限选择，否则就是多重背包问题，使用一个窗口来记录不同数量对应的可以找零的结果，按照取模结果来分组求解即可

## 区间dp

[code](./examples/62-range-dp.rs)

[code](./examples/62-match-bracket-newcoder.rs)

[code](./examples/62-strange-painter.rs)

[code](./examples/62-choir-lg.rs)

区间dp：解决大范围的问题拆分成若干小范围问题来求解

可能性的展开方式有

- 基于两侧端点的可能性展开
- 基于范围上划分点的可能性展开

### 让字符串成为回文串的最少插入次数

问题描述：给定一个字符串s，可以在字符串任意位置插入任意数量字符，问最少插入多少字符可以让原字符串变为回文串

解法：定义基本问题为在`l..=r`索引范围内要将字符串修改为回文串最少需要插入的字符数量，分情况讨论如下

- 如果`l == r`，表示只有1个字符，这也是基本情况，结果为0
- 如果`l + 1 == r`，表示有2个字符，那么如果两个字符相等结果为0，否则结果为1
- 如果`l + 1 < r`，表示包含超过2个字符
  - 如果`arr[l] == arr[r]`，那么结果是`dp[l+1][r-1]`
  - 如果`arr[l] != arr[r]`，那么结果是`min(1 + dp[l+1][r], 1 + dp[l][r-1])`

严格位置依赖的动态规划求解顺序应该是从下往上，从左往右求解。时间复杂度为`O(N^2)`，因为可变参数是索引，所以dp表长度为N。注意整个dp表的左下方都是无效区域，因为`l`不可能小于`r`

### 预测赢家

问题描述：给定一个非负数组，有两名玩家在这个数组上做游戏，玩家1总是先手，每名玩家只能从数组的头或尾拿一个数字当作他们的得分，当数组中没有元素则游戏结束，如果玩家1得分大于等于玩家2，那么玩家1赢，否则玩家2赢，当两名玩家做的都是最优决策时，求给定数组的条件下玩家1是否会赢

解法：定义基本问题为在数组的`l..=r`范围上，玩家1能取得的最大分数，分情况讨论如下

- 如果`l == r`，表示数组中只有一个数字，结果就是这个数字
- 如果`l + 1 == r`，表示数组中还有两个数字，那么返回更大的那个数字
- 如果`l + 1 < r`，表示数组中有超过两个数字，此时无论拿数组头还是尾的元素，都分为两种情况（以玩家1选择头元素为例），**最终要使用这两个结果的最小值，因为玩家2做的是最优决策**，剩给玩家1的一定是最小结果
  - 玩家2如果拿头，则结果是`dp[l+2][r]`
  - 玩家2如果拿尾，则结果是`dp[l+1][r-1]`
- 玩家1选择尾元素也是相同结果
  - 玩家2如果拿头，则结果是`dp[l+1][r-1]`
  - 玩家2如果拿尾，则结果是`dp[l][r-2]`

### 多边形三角剖分的最低得分

问题描述：给定一个凸多边形的所有顶点N个，按照顺时针排列，假设将这个多边形剖分为N-1个三角形，所有三角形的边不会交叉，每个剖分得到的三角形的分数是三个顶点的值的得分，求如何剖分可以让多边形的总分数最低

解法：凸多边形以起点和终点构成的边作为剖分三角形的公共边，除公共边的两个顶点以外的任何一个顶点作为三角形的顶点，可以得到一个三角形，然后剩余的两部分就又成为了凸多边形剖分三角的问题，最终计算得分的最小值。以起点和终点作为凸多边形的剖分底边分情况讨论如下

- 如果`l == r`，表示只有一个顶点，分数为0
- 如果`l + 1 == r`，表示有两个顶点，分数也为0
- 如果`l + 1 < r`，表示至少有三个顶点，那么在`l`和`r`中间选择任意一个点，构成三角形后，加上剩余两部分多边形的得分即可

dp表求解的枚举过程无法优化，时间复杂度`O(N^3)`

### 切棍子的最小成本

问题描述：有一个长度为N个单位的木棍，棍上从0到N标记了若干位置，给定一个整数数组，其中的元素表示需要将棍子切开的位置（位置不可能在起点或者终点），使用切点的顺序可以随意选取。每次切割棍子的成本是当前切点所在棍子的长度，切棍子的总成本是每次切割成本的总和。求切棍子的最小总成本

解法：首先为了记录每次在切点切木棍时所需的成本，需要构造一个辅助数组，因为原始切点数组中各个切点是否有序不影响求解过程，为了便于计算成本将其从小到大排序，然后在数组头部加上0，数组尾部加上N，那么每个切点的成本就是`arr[r+1] - arr[l-1]`，比如总长度是7，切点为`[1, 3, 4, 5]`，那么辅助数组是`[0, 1, 3, 4, 5, 7]`，对于切点`k == 2`在`1..=4`范围上切棍子，有成本`arr[4+1] - arr[1-0] = 7`。定义基本问题为在`l..=r`切点范围内切木棍所需要的最低成本，分情况讨论如下

- 如果`l > r`，非法情况，成本为0
- 如果`l == r`，表示只有一个切点，那么结果就是它当时的成本
- 如果`l > r`，可以选择`l..=r`范围上任意切点，计算最小成本

### 戳气球

问题描述：有N个气球，编号为0到N-1，每个气球都有一个分数，存放在数组中，要求你戳破所有气球，每个气球戳破可以得到的分数是`arr[i-1] * arr[i] * arr[i+1]`，如果`i-1`和`i+1`超出了数组范围，那么认为分数为1。求如何戳破气球可以得到最大分数

解法：如果按照先戳破气球来枚举可能性，在子问题中无法确定左边或者右边没有被戳破的气球是哪个，所以无法正确计算分数，所以使用最后戳破的气球来枚举。首先扩展原数组使得头尾两端各补充一个不会戳破的分数为1的气球。定义基本问题为`[l..=r]`范围上`l-1`和`r+1`位置气球都没有被戳破的情况下可以得到的最大分数，如果`l`位置的气球最后戳破，那么先计算`[l+1..=r]`范围的结果，最后加上`l`位置戳破的分数`arr[l-1]*arr[l]*arr[r+1]`，然后计算`r`位置的气球最后戳破的分数，再枚举中间任意位置被戳破的情况。基本情况是如果`l == r`表示只有1个气球，分数就是它自己和左右两边气球的分数乘积

### 布尔运算

问题描述：给定一个布尔表达式和一个期望的布尔结果，布尔表达式由0、1、&、|、^组成。布尔表达式一定是正确的，不需要检查有效性。可以随意改变计算的优先级，目的是让表达式最终得出期望的布尔结果，返回有多少种不同的逻辑计算顺序

解法：以任意一个计算符号作为最后参与计算的操作符。定义基本问题为`[l..=r]`范围上保证两端一定是0或1情况下计算结果为0或者为1的计算顺序数，如果`l == r`表示只有一个数字，则如果是0就累计0的计算结果数，如果是1累计1的计算结果数。否则遍历其中所有的操作符

- 对于`&`，计算结果为1需要左边、右边都为1，计算结果为0包括左边为0右边不为0，左边不为0右边为0，左边右边都是0
- 对于`|`，计算结果为1需要左边为1右边不为1，左边不为1右边为1，左边或者右边都为1，计算结果为1需要左边、右边都为0
- 对于`^`，计算结果为1需要左边为1右边为0，左边为0右边为1，计算结果为0需要左边右边都为0，左边右边都为1

### 完成配对需要的最少字符数量

问题描述：给定一个由`[]()`组成的字符串，问最少插入多少个括号能使这个字符串的所有括号正确配对

解法：正确配对的方式有嵌套和并列两种，所以有两种尝试方向，如果两端可以配对，那么内部字符串继续计算，否则尝试任意划分点做并列情况尝试。定义基本问题为在`l..=r`范围内上最少插入多少个括号能使字符串所有括号正确配对，分情况讨论如下

- 如果`l == r`，结果为1
- 如果`l + 1 == r`，判断是否能构成`[]`或者`()`，如果可以返回0，否则返回2
- 如果`l + 1 > r`
  - 如果`s[l] == s[r]`，那么结果1可能是`dp[l+1][r-1]`
  - 否则以`l..r`范围上任意点作为划分点，结果为`dp[l][k] + dp[k+1][r]`

### 涂色打印机

问题描述：有一条长度为N的模板，初始没有颜色，给定一个目标颜色序列，每次可以将木板的一段长度涂成一个颜色，问涂成目标颜色最少需要涂几次

解法：每次涂色可以认为如果两端颜色相同，就直接涂满，即解决头的时候顺便把尾解决掉，但此时并没有真正解决头，只是可以缩减问题范围，去掉尾，划分点处理无注意事项。定义基本问题为在`l..=r`涂色范围上要涂成目标颜色序列最少涂几次，分情况讨论如下

- 如果`l == r`，表示木板长度为1，只有一种颜色，结果为1
- 如果`l + 1 == r`，如果`s[l] == s[r]`，那么只需要一种颜色，结果为1，否则结果为2
- 如果`l + 1 < r`，分两种情况
  - 如果`s[l] == s[r]`，表示处理`l`位置颜色的时候，`r`位置可以顺便处理，结果为`dp[l][r-1]`
  - 否则以`l..r`范围的任意点作为划分点，分别处理左右颜色，结果为`dp[l][k] + dp[k+1][r]`

### 合唱队

问题描述：合唱队的人要根据他们的身高排出一个队形。假定合唱队一共N人，给定一个数组表示最终按照身高排成的队形，并已知**任何两个人的身高都不同**。排队方式分为第一个人直接插入空的当前队形中，从第二个人开始的每个人，如果他比前面进队那个人高，那么将他插入当前队形的最右边。如果他比前面进队那个人矮，那么将他插入当前队形的最左边。求有多少种排列顺序可以得到理想队形

解法：定义基本问题为`l..=r`范围上当`l`位置最后进入的可能性和`l`位置最后进入的可能性，分情况讨论如下

- 如果`l == r`，即队列只有一个人，那么直接返回1
- 如果`l + 1 == r`，当`arr[l] < arr[r]`，总共有两种可能，`l`位置最后进入有1种，`r`位置最后进入有1种，当`arr[l] > arr[r]`，那么不可能排出这种序列，返回0
- 如果`l + 1 < r`，那么需要判断`l`位置最后进入和`r`位置最后进入的情况
  - 如果`l`位置最后进入
    - 如果`l+1`位置最后进入，则如果`arr[l] > arr[l+1]`，结果为0，否则结果为`dp[l+1][r][0]`
    - 如果`r`位置最后进入，则如果`arr[l] < arr[r]`，结果为0，否则结果为`dp[l+1][r][1]`
  - 如果`r`位置最后进入
    - 如果`l`位置最后进入，则如果`arr[r] < arr[l]`，结果为0，否则结果为`dp[l][r-1][0]`
    - 如果`r-1`位置最后进入，则如果`arr[r] < arr[r-1]`，结果为0，否则结果为`dp[l][r-1][1]`

### 移除盒子

问题描述：给定一个数组表示一堆颜色不同的盒子，颜色使用正数表示。经过若干轮操作可以去掉盒子，每次可以选择连续的颜色相同的盒子移除掉，直到所有盒子都去掉，每次移除掉的盒子可以得分，得分计算规则为移除的盒子个数的平方。求能获得的最大积分总和

解法：在`l..=r`范围上移除盒子，有可能在这个范围之前还有一部分盒子可以继续移除，那么这部分盒子的数量作为一个参数参与可能性讨论，定义基本问题为`l..=r`范围上有`k`个颜色为`arr[l]`盒子的情况下，移除盒子得到的最大分数，分情况讨论如下

- 继续扩大前缀盒子的数量，并且消除所有前缀盒子，计算得分，再累加后续得分
- 继续扩大前缀盒子的数量，然后遍历后续所有和此盒子颜色相同的起始盒子位置，尝试找它们合并，再加上中间一部分移除盒子的分数

最终结果取最大值即可。时间复杂度为`O(N^4)`

### 合并石头的最低成本

问题描述：给定一个数组表示一排石头，数组的每个元素表示每堆石头的数量，每次操作需要将`k`堆石头合并为一堆，合并成本为这`k`堆石头的总数，返回把所有石头合并为一堆的最低成本，如果无法合并成一堆则返回-1

解法：首先对于石头堆数根据`k`的值判断是否能合成一堆的公式是`(N-1) % (k-1) == 0`，如果不满足这个公式就无法将石头合成为一堆，因为每次操作都会消去`k-1`堆石头，即只要将`N-1`堆消完最终就会剩余一堆石头，所以可以得到这个公式，利用这个公式可以保证给定的石头堆数最终一定能合成为一堆。定义基本问题为在`l..=r`范围上，所有石头合成到不能再合成所需要的最小代价，分情况讨论如下

- 如果`l..=l`位置作为一堆，剩余的所有石头会消为`k-1`堆，结果为`dp[l][l] + dp[l+1][r]`
- 如果`l..=l+k-1`位置作为一堆，剩余所有石头会消为`k-1`堆，结果为`dp[l][l+k-1] + dp[l+k][r]`
- ...

需要取所有情况的最小值。基本情况是如果只有一堆石头，那么代价就是0，因为不需要合并。如果当前合并范围一定能合成一堆石头，已经尝试过的所有合并可能要加上最终合并为一堆的代价，否则就是上面尝试的最小值。可以使用一个补0计算的累加和数组来辅助计算从`l..r`上合并石头为一堆的成本

### 统计不同回文子序列

问题描述：给定一个字符串s，求s中不同的非空回文**子序列**个数

解法：定义基本问题为在`l..=r`范围上有多少个不同的非空回文子序列，分情况讨论如下

- 如果`s[l] != s[r]`，表示左右两端不能同时参与回文构建，结果为`dp[l][r-1] + dp[l+1][r] - dp[l+1][r-1]`，即左边参与构建回文数和右边参与构建回文数的和减去重叠的回文数
- 如果`s[l] == s[r]`，根据中间的`s[l]`字符数量，分为以下情况
  - 如果不存在这个字符，结果为`dp[l+1][r-1]*2 + 2`，因为中间的每个回文都可以通过左右两个相同字符再构建一个对应的回文，多出来的两个是这两个字符有两种回文形式
  - 存在1个字符，结果为`dp[l+1][r-1]*2 + 1`，中间回文数同上，但是由于中间有此字符，所以只需要加上两个此字符构成的回文即可
  - 存在多个字符，找到里左右字符最近的两个相同字符，记位置为`i`和`j`，结果为`dp[l+1][r-1]*2 - dp[i+1][j-1]`，即内部重叠计算的部分等效为最外层两个相同字符替代了靠内的两个相同字符与中间字符构成的回文

## 树形dp

[code](./examples/63-tree-dp.rs)

[code](./examples/63-dancing-lg.rs)

[code](./examples/63-curriculum-lg.rs)

[code](./examples/63-curriculum-pro-lg.rs)

树也是一种图结构，树的头节点没有父亲，其它所有节点只有一个父亲节点，构成一个有向无环图（Directed Acyclic Graph），呈发散状。在树上，从头节点出发到任何一个节点的路径是唯一的

树型dp就是在树上做动态规划，依赖关系比普通动态规划简单。绝大多数都是父依赖子

解题套路

1. 分析父树得到的答案需要子树哪些信息
2. 把子树信息的**全集**定义成递归返回值
3. 通过递归让子树返回全集信息
4. 整合子树的全集信息得到父树的全集信息并返回

### 最大BST子树

问题描述：给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小（节点个数）

解法：定义基本问题为在一棵二叉树上最大的二叉搜索树子树的大小是多少，分情况讨论如下

- 这个最大子树包含头节点，那么此时需要判断包括头节点的树是否为BST，如果是，大小为左子树大小加右子树大小再加1
- 这个最大子树不包含头节点，那么就查找左子树和右子树中的最大BST子树，取它们的最大值

最终结果是两个结果取最大值，递归返回的信息需要包括任意一棵子树的如下信息，本题有一个细节，如果节点值的范围是整个`i32`类型，那么表示正无穷和负无穷需要使用`i64`类型，防止影响BST判断，如果节点值的范围更小，则无需做此变更

```rust
struct Info {
  // 树中的最小值
  min: i64,
  // 树中的最大值
  max: i64,
  // 树是否为bst
  is_bst: bool,
  // 树中最大的bst大小
  bst_size: i32,
}
```

基本情况，即一棵空树，最小值为正无穷，最大值为负无穷，这样做是为了方便单一节点子树判断是否为BST，空树是BST，空树的最大BST大小为0

时间复杂度为`O(N)`，N为二叉树的节点个数，求解过程为树的后序遍历

### 二叉搜索子树的最大键值和

问题描述：给定一棵二叉树，返回其中最大的任意BST的键值和（节点值的累加和）

解法：和上一道题一样，直接定义递归返回的信息

```rust
struct Info {
  // 树中的最小值
  min: i32,
  // 树中的最大值
  max: i32,
  // 树是否为bst
  is_bst: bool,
  // 树的键值和
  sum: i32
  // 树中最大的bst键值和
  bst_sum: i32,
}
```

分情况讨论如下

- BST包含头节点，那么最大键值和是整个树的键值和与左、右子树的最大键值和比较
- BST不包含头节点，那么最大键值和是左、右子树中的最大BST键值和

结果取最大值

### 二叉树的直径

问题描述：给定一棵二叉树，定义树中的“直径”是任何两个节点之间最长路径的长度（边的数量），这条路径不能重复经过节点

解法：分情况讨论如下

- 最长路径经过根节点，即左子树的高度加上右子树的高度为结果
- 最长路径不经过根节点，那就是左子树最大直径和右子树最大直径的最大值

定义递归返回的信息

```rust
struct Info {
  height: i32,
  diameter: i32,
}
```

### 在二叉树中分配硬币

问题描述：给定一个有N个节点的二叉树，每个节点的值表示该节点的金币数，每次操作可以将一枚金币从一个节点移动到另一个节点，求让每个节点只有一枚金币的最少移动次数

解法：分情况讨论如下

- 如果需要根节点参与转移金币，即左子树金币数和节点数差值的绝对值要移出或者移进，加上右子树金币数和节点数差值的绝对值移除或者移进，再加上左右子树内部的最小移动次数就是答案，先判断两边的差值绝对值是否为0
- 如果不需要根节点参与转移金币，那就是左子树的最小次数加上右子树的最小次数

定义递归返回的信息

```rust
struct Info {
  size: i32,
  coin: i32,
  min_times: i32,
}
```

### 没有上司的舞会

问题描述：某大学有N个职员，编号为1~N，他们之间有从属关系，父节点是子节点的直属上司，他们的关系是一棵多叉树。现在有一个舞会，参加规则是某个职员的直接上司参加他就不参加，某个上司不参加，他的直属下级可以选择参加或者不参加，参加的职员会统计他们的总快乐值，问最大能得到多少快乐指数

解法：定义基本问题为一棵树能取得的最大快乐指数是多少，分情况讨论如下

- 如果根节点参加，那么结果是根节点的快乐值加上所有子节点不参加的快乐指数
- 如果根节点不参加，那么结果是每个子节点作为子树能得到的最大快乐指数的最大值累加起来

最终结果需要取最大值。本题需要使用链式前向星建图，使用一个辅助数组`boss`来记录某个节点是否为根节点，初始全部为`true`，在遍历边的过程中如果某个节点是子节点，那么就设置为`false`，最后仍然为`true`的就是根节点

### 监控二叉树

问题描述：给定一棵二叉树，可以在树上任意节点安装摄像头，节点上每个摄像头可以监控其父节点、自身和它的直接子节点。问要监控整棵树所需要的最小摄像头数量

解法：这里不分析所有可能性而使用一个贪心的分析方法。在假设任意节点一定有父节点的前提下，如果它左右两个子节点都是空，那么这个节点的状态记为0，表示没有被监控覆盖，如果一个节点它左右任意子节点状态为0，那么它一定有一个摄像头，记状态为2，而对于一个空节点，可以认为它是已经被监控的，且它本身不需要装摄像头，记状态为1，那么任意节点分情况讨论如下

- 该节点为空，返回状态1
- 该节点的左右子节点任意状态为0，返回状态2
- 该节点左右节点都为1，**此时出现贪心的点，即一定不放摄像机，交给他的父节点处理，返回状态0**，因为在它的位置放摄像机只能惊恐自己和它的父节点，而左右子节点无意义，但是父节点放摄像机还（有可能）能监控父节点的另外一个子节点
- 其它情况返回1，因为它至少有一个子节点有摄像机，所以已经被处理

最终拿到根节点的状态，如果为0表示它还没有被覆盖，那么在它的位置放一台摄像机即可。根据分析可知，对于任意一棵树最少摄像机放置的方法是固定的，不需要选择

### 路径总和 III

问题描述：给定一棵二叉树和一个整数target，定义路径为从任意节点只能向下与其它节点构成，问该二叉树中路径之和等于target的路径有多少条

解法：只需要遍历所有的节点，在每个节点计算它的前缀和减去target的值在所有路径和中出现的次数，累加进结果中即可，需要注意的是要在遍历过之后减去次数以及前缀和中自身的值，防止影响其它节点计算。注意初始统计表中应该插入`(0, 1)`，因为没有节点时`0`已经出现1次，在任意节点统计时，需要先统计路径条数再去更新带上当前节点的路径条数，因为搜索时只关心不包含当前节点的路径数

### 到达首都的最少油耗

问题描述：给定一棵N个节点的树，编号从0到N-1，每个节点表示一个城市，0是首都，给定一个二维数组表示不同城市之间有路。每个城市都有一个代表，所有代表要到首都参加会议，每座城市有一辆车，车的座位数是固定的，城市里的代表可以选择乘坐所在城市的车或者乘坐其它城市的车，相邻城市之间一辆车油耗是一升。求所有代表到达首都最少需要多少升汽油

解法：因为题目给的路径是无向的，所以建图应该建无向图，在遍历树的时候需要将父节点传入递归函数，这样可以保证只向下遍历。每个城市的油耗是它所有子树的油耗加上到子树根节点的人数除座位数向上取整，所以每棵子树要将自己的人数（节点个数）和油耗传递给父节点

### 相邻字符不同的最长路径

问题描述：给定一棵树，根节点是0，节点编号为0到N-1。并且给定一个数组表示每个节点的父节点（`parent[0] = -1`），然后给定一个字符串，长度为N，`s[i]`表示每个节点的字符。问找出树上任意相邻节点字符不同的最长路径，返回该路径长度

解法：定义基本问题为以某个节点作为根节点的树，能得到的最长满足题目要求的路径长度，分情况讨论如下

- 如果该路径不包含根节点，那么结果就是所有子树的最长路径取最大值
- 如果包含根节点，那么结果就是所有子树的必须包含该子树根节点且字符与此根节点不同的的最长路径中取最长和次长，再加2

最终结果取两个结果的最大值，定义每个节点需要返回的信息为

```rust
struct Info {
  max_path: i32,
  max_root_path: i32,
}
```

解法2：可以从叶子节点往上计算，每个节点的最长路径是它所有子节点的最长和次长路径加上它自身，如果加不上它自身就是0，利用一个队列来处理节点，当某个节点的子节点全部遍历完自身进入队列，直到最后弹出根节点

### dfn序

用深度优先遍历（先序）的方式遍历整棵树，给每个节点依次标记序号，编号从小到大的顺序就是dfn序，这个序有以下特性

- 父节点编号一定比子节点小
- 节点编号加上该节点为头节点的子树大小可以定位该子树所有的节点，需要同时记录每棵子树的大小

#### 移除子树后的二叉树高度

问题描述：给定一棵二叉树，树中有N个节点，每个节点分配1~N的**互不相同**的值，另外给定一个长度为M的数组queries，`queries[i]`表示在树中删除这个节点作为根节点的子树后树的高度，并且`queries[i]`不会是根节点

解法：遍历二叉树得到dfn序，然后根据dfn序的编号记录每个节点子树的节点个数和高度，那么对于任意一个`queries[i]`，该节点对应的dfn序号，再加上节点个数就是所有被影响的节点，此时树的高度就是除删除节点之外的所有节点的最高高度，所以还需要两个记录高度的数组，依旧按照dfn序号组织，从左往右得到最大值，从右往左得到最大值，那么最终结果就是`maxl[0..dl].max(maxr[dr+1..=N])`

#### 从树中删除边的最小分数

问题描述：给定一棵无向连通树，节点编号为0~N，有N-1条边。删除树中两条不同的边以形成三个连通组件（子树），对于任意一种删除边方案，获取三个组件中每个组件的所有节点值的异或值，最大异或值减去最小异或值的差值就是这种删除方案的分数，求可能的最小分数

解法：求解思路为遍历任意两条边的组合，将三个组件的异或值求出后进行分数计算，最后统计最小分数。根据异或运算的属性`a ^ b = c => a = b ^ c`，只要求出离根节点更远的两棵子树的异或和，最后剩余组件的异或和也能求出。更远的两棵子树的关系分情况讨论如下

- 如果b树是a树的子树，那么a树移除b树后的异或和就是a树的异或和异或b树的异或和
- 如果b树不是a树的子树，那么两者异或和是各自子树的异或和

在求解dfn序的时候需要每棵子树的大小（节点数量）和异或和。由于这棵树是无向的，所以可以定编号0为根节点，不影响计算。使用邻接表建图

#### 选课

问题描述：总共有N门功课，每门课有对应学分，每门课有一门或者没有直接先修课（如果a是b的先修课，那么必须先学习a才能学习b）。一个学生要在这些课程里选择M门课程学习，求他能获得的最大学分是多少

普通解法：假设总共有N+1门课，根据题意可知所有课程会分为至少一棵的树，所以可以将这些树的根节点再连到一个虚拟的根节点上，然后可选课程也变为M+1。在这样的前提下定义基本问题为在节点`i`以及它的`j`个子树上选`k`门课可以得到的最大分数是多少，分情况讨论如下

- 如果`k == 0`，表示没有课程需要选，返回0
- 如果`k == 1`，则只能选择节点`i`的课程，因为它是先修课，返回`arr[i]`
- 考虑是否选择`i`节点的第`j`个子树课程，结果取最大值
  - 如果不选择，那么结果就是`dp[i][j-1][k]`
  - 如果选择，那么结果根据在第`j`个子树上选择`[1:k]`门课后，剩余课程在前面的子树上选择`dp[i][j][s] + dp[i][j-1][k-s]`

最终结果是`dp[0][j][m]`，时间复杂度为`O(N*平均子树个数*M^2)`。使用邻接表建图可以更容易得计算子树的索引位置

优雅解法：定义一个结构表示对于所有的其中所有的课程，当存在一个虚拟父节点是可以保证它们是连通的，此时求在这些课程中选择M门课能取得的最大学分。首先为所有的课程节点计算dfn序，然后定义基本问题为从`i`序号到N+2序号（dfn序号从1开始，总共N个节点，最后的dfn序号是N+1）的课程能保证构成所需结构的前提下选M门课的最大学分是多少，计算需要逆序进行，增加不存在的N+2需要是为了数组计算不越界，分情况讨论如下

- 不选择`i`序号课程，那么结果为`dp[i+size[i]][j]`
- 选择`i`序号课程，那么结果为`arr[~dfn[i]] + dp[i+1][j-1]`

最终结果取最大值，时间复杂度为`O(N*M)`。⚠️本题不需要保留dfn序的信息，而是需要dfn序号下的子树大小和该节点的学分值。动态规划求解顺序是从下到上、从左往右

## 状压dp

[code](./examples/64-status-compress-dp.rs)

[code](./examples/64-tsp-lg.rs)

[code-tsp-c](./c/tsp.c)

> 插头dp，自行学习

对于一些简单路径的递归，比如每个元素只能选择一次，后续还要利用不同状态计算，这种问题可以使用状压dp来解决。设计一个整形可变参数`status`，用位信息表示某个样本是否还能使用，利用这个信息去进行**尝试**。改进过程和其它dp类似：尝试递归->记忆化搜索->严格位置依赖->空间压缩

如果有`k`个样本，那么状态的可能性就是`2^k`，所以可变参数的范围就是`[0..2^k]`。因此样本每增加一个，复杂度是指数级增加，所以状压dp能解决的问题数据量都不会太大，在20个左右（`10^6`）级别

如果数据量过大，状压dp无法解决，那么双向广搜是一个解决问题的备选方案

### 我能赢吗

问题描述：给定两个整数N和M。两个玩家可以轮流从公共整数池1~N中取数，每次取出的数都要进行累加，谁在自己的回合让累加和大于等于M，谁就获胜。问在给定条件下先手玩家是否能稳赢，假设两名玩家做的都是最优决策

解法：如果M小于等于0，那么先手一定获胜，如果1~N的累加和小于M，那么先手一定失败，对于其他情况来说，定义`status`为所有数字的选取状态，基本问题为当前先手在还剩下`remain`数字的情况下是否一定可以获胜，递归过程中只要遍历1~N所有数字，判断它们的状态和与剩下数字的关系即可，如果大于则直接获胜，如果小于则要让后手（下一个先手）失败，只要存在一种获胜方式，直接返回

⚠️本题中dp表只需要一维，因为剩余的数字是由`status`直接决定的，所以没有必要将其作为dp表参数。对于任何dp来说，都只关注决定性的变化参数

时间复杂度`O(2^N*N)`，枚举过程有`O(N)`的时间复杂度，所以要乘状态，空间复杂度为`O(2^N)`

### 火柴拼正方形

问题描述：给定一个整数数组，每个元素表示火柴棒长度。要用所有的火柴棒拼成一个正方形，火柴棒不能折断，每根火柴棒只能用一次。可以拼成正方形返回`true`，否则返回`false`

解法：首先求所有火柴棒的长度累加和，判断是否可以拼成正方形，如果可以那么定义基本问题为，在给定状态`status`下，已经拼了多少长度（一条边），还剩几条边需要拼，是否可以完成拼接任务。遍历所有还能选择的火柴棒，继续尝试，由于已经拼了的长度和还剩几条边的数量都是可以通过状态得到的，且是决定性关系，所以dp表只需要一维数组。时间复杂度和空间复杂度和上题相同

### 划分为k个相等的子集

问题描述：给定一个整数数组和一个正整数`k`，问是否有可能把这个数组分成`k`个非空子集，要求所有集合的累加和都相等

解法1：如果使用状压dp，本题解法和上一道题相同，只要把4条边改为`k`个集合即可，每个数字选择与否构成状态，当前填了多少，还剩几个集合要填，dp表只需要状态一维即可

解法2：直接暴力递归，先将数组排序，从右往左（数字从大到小）依次尝试往结果数组里填，这样做可以保证当某个大的数字没办法往结果数组中填的时候及时结束算法，比先填小数字节省一些时间。在填的过程中有一种剪枝策略，即如果一个数对于答案数组中累加和相同的位置保证只计算一次。时间复杂度为`O(k^N)`，不推荐

### 售货员的难题（TSP问题）

问题描述：某乡有N个村庄（`1 <= N <= 20`），有一个售货员要到各个村庄去售货，各村庄之间的路程已知，且任意两个村庄的路程大多不同（有向带权图），为了提高效率他从商店出发到各个村庄一次，然后返回商店所在的村，求一条最短的路径

解法：定义状态为任意地点是否已经经过，经过为1，未经过为0，并且提供一个当前出发地点，因此dp表是一个二维表，只需要在当前点的任意下一个地点进行遍历，然后找到最小值即可。时间复杂度为`O(2^N*N^2)`，TSP问题的精确解最优复杂度就是这个，还有很多其它算法可以得到优良解

### 每个人戴不同帽子的方案数

问题描述：总共有N个人和40种不同的帽子，帽子编号是1~40，给定一个整数数组，`arr[i]`表示第`i`个人喜欢的所有帽子的列表。在为每个人安排一顶他喜欢的帽子的前提下要确保每个人戴的帽子跟别人都不一样，求总共有多少种方案。结果需要对`10^9 + 7`取模

解法：因为帽子种类有40种，所以将帽子是否被选取作为状态和遍历人作为展开方式不恰当，复杂度不满足要求。因为题目中人数大小为1~10，所以定义人是否得到帽子为状态，当前遍历的帽子编号为另一个参数，基本问题为还能安排多少种方案满足要求，分情况讨论如下

- 该编号帽子不参与方案
- 该编号帽子参与方案，且有人喜欢该编号帽子

可以使用状态表示每种帽子适合哪些人，每种帽子的状态都是一个整数，不同的位对应人，0表示不适合，1表示适合

### 最优账单平衡

问题描述：给定一个数组表示所有交易，`arr[0]`表示给钱的人，`arr[1]`表示收钱的人，`arr[2]`表示交易的钱数，求还清所有债务的最小交易笔数

解法：首先将所有交易模拟进行得到每个人最终的负债情况，然后剔除其中所有负债为0的人，剩下的所有人需要平衡债务。还清所有债务的最小交易笔数等同于将这些人划分为尽可能多的无法再进行划分的还债单元，每个这样的还债单元还清债务所需要的交易次数是`N-1`次，例如3个人只需要发生两次交易，那么总体看所有人还清债所需最少的交易次数就是人数减去最多的单元数。定义基本问题为给定一个负债数组，以每个人是否被分组作为状态，得到可以分的不可再分的最多组数，分情况讨论如下

- 如果当前累加和是0，那么只需要拿出一个未分组的人，然后尝试分组，最后剩下的一定会跟取出来的人分到一组，所以这种情况只遍历一次
- 如果当前累加和不是0，那么需要尝试所有未分组过的人，然后得到分组的最大值

特殊情况是当只有一个元素时，分组数为0，时间复杂度为`O(2^N*N*每个组平均人数)`，即只遍历没有被分组的人，这里设定没有被分组为1，被分组为0

### 好子集的数目

问题描述：给定一个整数数组，定义好子集为这个子集中所有元素的乘积可以表示为一个或多个互不相同的质数的乘积，返回数组中好子集的数组，需要对`10^9+7`取余。如果两个子集删除的下标不同，那么被视为不同的子集（排列而非组合）

解法：根据题目给定的数据，数字的范围为`1~30`，那么好子集的个数取决于各个数字的个数，所以首先统计每个数字的总数。在这些数字上所有的质数包括2、3、5、7、11、13、17、19、23、29，使用状态表示每个质数在乘积中出现1次或者不出现，那么问题转换为该数字下要满足指定状态可以有多少个子集，分情况讨论如下

- 如果不选择这个数字，那么直接进入下一个数字
- 如果选择这个数字，那么这个数字要有效（可以消减状态），其次它的个数要大于0，然后它对于必须消减有效状态（满足`num & status == status`）

为了计算方便，可以对1～30进行转换，即每个数字可以解决哪些质数，如果不能解决则认为是无效数字。基本情况是如果当前数字为1，且所有状态都被解决，那么1可以扩展子集，数量是1的个数k计算得到`2^k`

### 分配重复整数

问题描述：给定一个整数数组，至多有50个不同的值。同时给定一个订单数组，每个订单表示需要`order[i]`个相同的整数，问所有订单是否能够被同时满足

解法：根据题目提供的数据量，最多有10个订单，那么每个订单是否被完成可以作为状态进行尝试，因为具体的数字在分配时没有意义，所以只需要统计不同数字的个数即可，那么问题转变为任意一个数字可以满足多少订单，依次尝试，初始状态为所有订单没有被满足，需要一个辅助结构，即每个订单状态要被完成需要多少个数字

时间复杂度为`O(N*3^M)`，首先N是不同的数字个数，对于枚举过程，每个状态都需要去枚举自己的子状态，如果当前订单需要完成一个，那么等价于`C(M,1)*2^1`，需要完成两个为`C(M,2)*2^2`，依此类推，需要完成M个就是`C(M,M)*2^M`，它们的累加和是二项式定理形式，即`(1+x)^N`展开，这里`x = 2`，所以枚举代价为`3^M`

#### 遍历一个状态的所有子集的技巧

```rust
let mut i = status;
while i > 0 {
  handle(i);
  i = (i - 1) & status;
}
```

## 动态规划中观察优化枚举的技巧

[code](./examples/65-dp-iter-opt.rs)

[code](./examples/65-less-equal-k-newcoder.rs)

动态规划题目中，写出记忆化搜索的版本之后为什么还要写出严格位置依赖的版本？除了可以进行空间压缩优化之外，还在于通过严格位置依赖建立对求解答案的空间感，即格子之间的依赖关系，通过观察枚举过程来进一步优化，让时间复杂度更好

动态规划方法的复杂度大致可以理解为`O(状态数量*每个状态的枚举代价)`。当每个状态的枚举代价为1时，记忆化搜索版本的答案的时间复杂度就已经是最优了。但是当枚举代价较高时，记忆化搜索的版本可能不是最优解，因为所有的枚举都会在递归过程中出现，那就可能会有进一步的优化。为了观察到这种优化方式，我们需要改写成严格位置依赖的版本

本节的观察优化枚举技巧包括

- 观察并优化转移方程
- 观察并设计高效的查询结构

### 买卖股票的最佳时机

问题描述：给定一个数组表示一支股票在任意一天的价值，在只能交易一次的前提下，问你能得到的最大收益是什么，题目要求每支股票买入后只能在之后卖出

解法：虽然题目要求股票不能在当天同时买入卖出，但是题目要求如果收益总是为负数就返回0，所以可以将同一天两次交易的收益（0）作为最小收益参与计算。遍历一次股票价值数组，维护`i`位置之前的最小值，在`i`位置当天尝试卖出，得到的结果取最大值即可

### 买卖股票的最佳时机 II

问题描述：给定一个数组表示一支股票在任意一天的价值，可以交易无数次，问能得到的最大收益，同时最多只能持有一支股票

解法：因为交易次数无限制，所以股票中所有的上升趋势都要买到，所以遍历一次数组，将所有上升趋势的值累加起来就是答案

### 买卖股票的最佳时机 III

问题描述：给定一个数组表示一支股票在任意一天的价值，最多可以完成两笔交易，不能同时参与多笔交易，即完成一笔交易才能开始下一笔交易

解法：定义基本问题为在第`i`天作为第二笔交易的卖出日可以得到的最大利润是多少，所以需要遍历`0~i`天做完第一笔交易再加上第`i`天的价格减去那天的买入价格，取所有可能的最大值就是答案。从`0~i`天做第一笔交易的最大利润也是一个问题，每天减去之前天数的最小值和前一个结果取最大值

优化枚举：上面的解法中枚举有`O(N)`的代价，但是每次枚举的规律如下

```text
dp[i] = dp[i].max(dp1[0] + price[i] - price[0])
dp[i] = dp[i].max(dp1[1] + price[i] - price[1])
dp[i] = dp[i].max(dp1[2] + price[i] - price[2])

// 等效于

dp[i] = max(dp1[k] - price[k]) + price[i]
```

因此可以预先制作一个存储结构保存`max(dp1[k] - price[k])`对于每个`k`的值，这样枚举过程就被优化为`O(1)`

空间压缩优化：省略dp表的创建，因为无论是第一次还是第二次交易的结果求解都只依赖它之前的结果，所以只需要几个变量即可

### 买卖股票的最佳时机 IV

问题描述：给定一个数组和一个整数`k`，数组每个元素表示一支股票在每一天的价格。求在最多完成`k`笔交易的前提下可以获得的最大利润是多少。任意时间只能存在一笔进行中的交易

解法：定义基本问题为在完成`k`笔交易的前提下，在`0~i`天可以获得的最大利润，分情况讨论如下

- 如果`i`天不参加交易，那么结果是`dp[k][i-1]`
- 如果`i`天参加交易，因为是最后一天，它肯定会卖掉，那么要遍历从`0~i`中任意一天为节点完成`k-1`笔交易，然后再加上最后一笔交易的利润`dp[k-1][m] + prices[i] - prices[m]`，取最大值

最终结果取两者的最大值就是结果

⚠️本题一个重要的剪枝，如果`k`的数量大于等于`N/2`，表示交易次数大于等于所有股票上涨的趋势次数，所以问题转换为无限交易次数可以取得的最大利润，将所有上升趋势累加即可

枚举优化：根据枚举所需要的值，可以看出将`max(dp[k-1][m] - prices[m])`提前做成辅助结构可以省去遍历的过程，这个值跟每个格子的左上角值相关，只需要一个变量即可循环计算使用，它的含义是`0~m`天中上述值的最大值

空间压缩优化：将二维dp表修改为一维dp表

### 买卖股票的最佳时机含手续费

问题描述：给定一个数组表示一支股票的每日价格，整数`fee`表示每次交易的手续费，可以无限次交易，但是同时只能保持一个交易，返回可以获得利润的最大值

解法：定义一个辅助数据表示`0~i`天必须买入股票并且扣除手续费的最大值，定义基本问题为`0~i`天中无限次交易可以得到的最大利润，分情况讨论如下

- 第`i`天不参与交易，那么结果就是`dp[i-1]`，前`i-1`天的最大利润
- 第`i`天卖出股票，那么结果就是`prepare[i-1] + price[i]`

结果需要取两者的最大值，在得到`0~i`天的最大利润之后，要更新`0~i`天买入股票并扣除手续费的最大值，要么就是买第`i`天的股票为`dp[i] - price[i] - fee`，要么就是不买`i`天的股票为`prepare[i-1]`

### 买卖股票的最佳时机含冷冻期

问题描述：给定一个数组表示一支股票的每日价格，可以无限次交易，同时只能保持一笔交易，但是每次卖出股票之后，必须要等待一天才能继续买入股票，问可以取得的最大利润

解法：使用一个辅助结构来保存`0~i`天必须购买一次股票可以得到的最大值，定义基本问题为在`0~i`天可以做无限次交易后能获得的最大利润，分情况讨论如下

- 如果第`i`天不参与交易，那么结果是`dp[i-1]`
- 如果第`i`天参与交易，那么结果是`prepare[i-1] + price[i]`

结果取两者的最大值，并且在计算完第`i`天可以获得最大利润之后要更新辅助结构，它的值是要不要购买第`i`天的股票的最大值，如果不购买就是`prepare[i-1]`，如果购买就是`dp[i-2] - price`

### DI序列的有效排列

问题描述：给定一个长度为N的字符串，其中的元素只可能是`D`或者`I`，`D`表示当前元素应该大于下一个元素，`I`表示当前元素应该小于下一个元素，要根据这个字符串构建一个有效排列，即`0..=N`的N+1个数字的排列满足字符串的规定，问总共有多少种有效排列，结果对`10^9+7`取模

> 如果尝试过程是在第`i`个数上，给定第`i-1`个数，并且结合所有数字的选择状态来计算全部排列次序，根据题目提供的测试数据量是无法通过的

解法：根据题意，具体是哪些数字并不重要，只要它们互不相同即可，所以将数字选择的状态可以转化为小于上一个数字的数量，定义基本问题为在第`i`个数字上，给定小于上个数字的剩余数量，同时可以得到大于上个数字的剩余数量，根据大小关系来进行遍历。在第`0`个数字上可以假设上一个数字是无限大且需要满足一个`D`的关系即可

观察优化枚举：每个格子对于`D`的情况，就是左边格子的结果加上左下格子的关系，对于`I`的情况，只要计算到`N-i`即可，所以要从右往左计算，第一个就是自己下面的格子的值，后面的都是它右边的格子加上它下面的格子，所以可以省略一次`O(N)`的遍历，最终时间复杂度为`O(N^2)`

### 规划兼职工作

问题描述：给定一组数组，分别表示工作开始时间、结束时间和报酬，限制是同一时间只能做一份工作，并且在结束工作的时间点结束一份工作可以直接开始做另一份工作，问可以获得的最大报酬

解法：首先对所有工作的结束时间进行排序，然后定义基本问题为在第`i`个结束时间（工作）之前在满足限制的情况下可以随意工作能取得的最大报酬是多少，分情况讨论如下

- 可以不做第`i`份工作，那么结果就是`dp[i-1]`
- 做第`i`份工作，因为在之前的`0~i-1`份工作中，只要做工作就会产生报酬，所以是有单调性的，只需要找到结束时间小于等于当前工作的开始时间的且更靠右的工作即可，通过二分查找得到之前工作的结束时间小于等于当前工作的结束时间的最右位置，然后再加上当前这份工作的报酬

最后取两个结果的最大值，基本情况是当`i`等于0，结果是`profit[i]`，时间复杂度为`O(N*logN)`

### K个逆序对数组

问题描述：在一个数组中定义逆序对，数组中任意两个元素，如果`num[i] > nums[j]`且`0 <= i < j < nums.len()`，则这两个元素为逆序对。给定一个整数和`k`,要求找出包含`1~N`的数组所含有`k`个逆序对的不同数组的个数，答案需要对`10^9+7`取模

解法：定义基本问题为在`1~i`范围上恰好有`j`个逆序对的数组个数有多少，那么在任意`i`位置上，`1~i`所有数字中找逆序对仅跟最大数字（即`i`）的位置有关

- 当`i > j`时，结果为`dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][0]`，分别对应最大数字`i`从末尾到开头所有位置所需要计算的量，如果放到末尾，那么它本身无法构成逆序对，就需要之前的数字取构成所有逆序对，如果放到某个位置恰好构成`j`个逆序对，那么前面的数字就不能构成任何逆序对
- 当`i <= j`时，结论类似，但是`i`最多只能构成`i-1`个逆序对，所以结果为`dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i+1]`

最终结果是`dp[N][k]`，基本情况是任意元素构成0个逆序对的数组只有1种，对于0个元素构成其它的逆序对个数的数组数量为0。时间复杂度为`O(N*k)`（优化枚举后）

观察优化枚举：因为每个格子都只需要上一行包括它以及它之间的固定数量的格子，所以可以使用一个窗口变量来保存这个值，省去`O(N)`的遍历时间。

### 自由之路

问题描述：给定一个字符串表示类似老式电话号码盘上的字符，给定另外一个字符串表示要得到的字符串，返回最少可以得到所有字符串所需的最少步骤，输出一个字符和转动号码盘都需要一个步骤。第一个字符串的第一个字符就是在12:00方向的字符，所有字符必须到12:00方向才能输出

解法：定义基本问题为在第`i`个字符开始要得到`j`之后所有的字符所需要的最少步骤，分情况讨论如下

- 第`i`个字符如果等于目标字符串的第`j`个字符，那么直接返回`1 + dp[i+1][j+1]`
- 先得到顺时针方向离第`i`个字符最近的目标字符串的第`j`个字符的位置，计算距离再加上下一个答案
- 再得到逆时针方向离第`i`个字符最近的目标字符串的第`j`个字符的位置，计算距离再加上下一个答案

计算所有情况的最小值，时间复杂度是`O(N*M*logN)`

⚠️输出字符只是一个步骤，在递归中不能直接更新`i`的值

### 累加和不大于k的最长子数组

问题描述：给定一个无序数组，长度为N，其中可能有正数、负数和0。给定一个整数`k`，求数组中所有子数组累加和不大于`k`的最长子数组长度，子数组是连续的

解法1：定义基本问题为以`i`位置结尾的子数组，它的累加和不大于`k`的最长子数组长度是多少，假设`0~i`的累加和为a，只要找到`i`前面某个累加和大于等于`a-k`的最靠右的索引位置，然后计算两个索引的间隔，最终取每次计算的最大值即可。为了省去枚举时的遍历，由于我们只需要找到大于等于某个值的最左位置，所以可以构建一个记录`0~i`范围上最大前缀和的辅助数组，每次只要在这个数组中进行二分查找即可，注意要保留一个数也没有的情况，保证查找大于等于一个负数的情况下可以返回值。时间复杂度为`O(N*logN)`

解法2：贪心思路，首先计算以`i`开头的最小累加和，要么是它自己，要么是它加上`minsum[i+1]`，同时需要记录这个最小累加和的终止索引，这里的计算方式是从右往左。那么从开始位置尝试计算是否小于等于`k`，直到某个索引超过这个限制，那么统计一个长度，此时窗口可以往右移一个位置，这里出现贪心，因为总是要求最长长度，所以即便下一个位置到现在终止位置中间有有效答案也不需要考虑，只需要减去出窗口的值之后继续滑动窗口即可

## 数位dp

[code](./examples/66-digit-dp.rs)

[code](./examples/66-windy-lg.rs)

[code](./examples/66-moe-lg.rs)

[code](./examples/66-range-digit-lg.rs)

数位dp的尝试方法并不特殊，类似从左到右的尝试。数位dp是在数字上的每一位进行线性展开。解题核心在于可能性的展开以及排列组合知识

数位dp推荐使用记忆化搜索方式写，递归写好问题也就解决了，数据量大就挂缓存，位数不多不挂缓存也能过题

### 统计各位数字都不同的数字个数

问题描述：给定一个整数N，代表十进制数字小于`10^N`。如果每个数字，每一位都不同，那么这个数字叫做有效数字，求有效数字的的个数，不包括负数

解法：0位有1个数字（1），1位有10个数字（0～9），2位有`9*9`（因为两个数字不能相同），3位就是`9*9*8`，以此类推，将规律实现出来即可

### 最大为N的数字组合

问题描述：给定一个有序数组，其中包含`1~9`的数字字符，且无重复字符，可以使用任意字符无限次来写数字，要求这个数字不能大于N，问可以生成多少个整数

解法：对于N这个数，以它的位长度来定义基本问题，在长度为`i`时，使用数组中的字符可以生成多少个不大于N的数字，分情况讨论如下

- 如果不为`i`位选择数字，那么直接进入下一位，需要带上`i`位没有选择数字的状态
- 如果为`i`位选择数字，选择小于这个位的数字（如果有），那么要带上后续可以随意选择数字的状态
- 如果为`i`位选择数字，选择等于这个位的数字（如果有），那么要带上后续不能随意选择数字的状态

基本情况是当`i == 0 && skip == 0`时，即没有数字需要填写并且之前的数字没有跳过，那么就是1，否则就是0

优化解法：对于前一位选择的数字是小于那一位的数字，可能性就是`digits.len()^rem`，所以可以事先把这些结果计算出来，定义一个结构`prep[i]`表示在`i`位上填比目标数小的数会有多少种可能性，在递归中当当前数小于目标数时直接查表即可，仅在当前数等于目标数的情况进行递归。之前每次计算的结果需要提前加到最后的结果中，因为它们同时也是跳过之前各个位数的可能性

⚠️这道题目不需要挂缓存表也可以通过。时间复杂度为`O(N*num.len())`

### 统计整数数目

问题描述：给定两个数字字符串`num1`和`num2`以及两个整数`max_sum`和`min_sum`。如果一个整数满足一下条件，就认为是一个好整数，即`num1 <= x <= num2 && min_sum <= digit_sum(x) <= max_sum`，求好整数的数目，答案需要对`10^9+7`取模

解法：本题可以转化为`0~num2`中满足的数字个数减去`0~num1`中满足的数字个数，最后根据`num1`本身是否满足条件再更新结果即可。要求`0~N`范围上满足好整数要求的数的个数，首先定义基本问题为在`i`位上，已有累加和的值以及本身是否可以自由选择数字的条件下，可以构成好整数的个数，分情况讨论如下

- 如果`i == N.len()`，表示所有数字填完，且符合条件，返回1
- 否则，如果`presum > max_sum`，那么从`i`位开始已经无法满足要求，返回0
- 否则，如果`presum + (N.len() - i)*9 < min_sum`，那么从`i`位开始选什么都不会超过`min_sum`，也返回0
- 根据是否可以自由选择数字分情况
  - 可以自由选择，那么就是`0~9`十个数乘后续的可能
  - 不可以自由选择，首先计算小于当前位的数的可能，之后的位又能自由选择，再计算等于当前位数的数的可能，后续位不能自由选择

本题需要挂缓存表，时间复杂度为`O(N.len()*max_sum*2*10)`

### 完全没有重复的数字个数

问题描述：给定一个正整数N，返回在`1..=N`范围内每一位都互不相同的正整数个数

镜像题目：至少有1位重复的数字个数，要求相同，即N个数减去上面问题的结果

解法：假设数字N有`l`位，对于任意位，假设第`i+1`位填好数字，剩下的位有多少种可能性的计算方式是固定的，即`9*8*7*...*(10-i)`，因为第`i+1`位已经填好，所以下一位会少一种可能性。首先对于数字范围仅在`l-1`位及更少的位的可能性可以直接计算。在`l`位时，先计算使用所有小于`l`位数字的数的可能性，从预先处理的结构去除，然后定义基本问题为在第`i`位以`status`的数字可选状态且`i+1`位数字已经填了的情况下可以构成各位互不相同的正整数有多少个。时间复杂度为`O(num.len()*2^10*10)`

⚠️基本问题中的一个前提，`i+1`位置数字已经填好意味着当前位可以从0开始尝试

### windy数

问题描述：不含前导零且相邻两个数字之差至少为2的正整数被成为windy数，求`a..=b`范围上总共有多少个windy数

解法：为了求`a..=b`范围上所有的windy数个数，可以求`0..=b`和`0..=a-1`范围上的windy数个数，相减就是答案。特例有0本身是一个windy数。求`0~N`范围上的windy数需要定义基本问题为在第`i`位上，根据之前选中的数字和是否可以自由选择的条件可以构成多少windy数，用`10`来表示之前没有选数字，本题中不选数字和选择0的含义不同，所以当所有位都不选可以等同于选择了0，且0是windy数，不影响最终结果。分情况讨论如下

- 如果当前不能自由选择数字，表示当前位只能选不超过目标位的数字
  - 如果之前没有选择数字，那么代表当前是数字的首位，需要累加以下几种情况
    - 继续不选数字
    - 选择`1~x`，不包含当前位的数字
    - 选择当前位数字
  - 如果之前选择了数字，那么这一位要满足windy数的限制，且可以从`0~9`进行选择
- 如果当前位可以自由选择数字
  - 如果之前没有选择数字，表示高位空缺，需要累加以下几种情况
    - 继续不选数字
    - 选择`1~9`任意数字
  - 如果之前选择了数字，那么这一位要满足windy数的限制，且可以从`0~9`进行选择

时间复杂度为`O(num.len()*11*2*10)`

### 萌数

问题描述：如果一个数字，存在**长度至少为2**的回文子串，那么这个数字被称为萌数。例如101、110、111等。求`a..=b`范围上有多少个萌数。结果需要对`10^9+7`取模。⚠️题目范围的数字很大，最大1000位，所以需要使用字符串表示

解法：由于数字是字符串形式，所以直接做计算不方便，可以将问题转化为求`0..=a`和`0..=b`上有多少个萌数，然后单独判断`a`是不是萌数，最后累加结果。直接判断一个数字串是否存在长度至少为2的回文子串并不简单，可以等效为找出所有不是萌数的个数，然后用这个数字范围减去这个结果，要判断某个数不是萌数，只要它的任意一个位不等于它的前一位或者前二位就满足条件

可以转化的前提包括，要求的是长度至少为2，反例是不存在回文，更好判断，且问题的总体规模是一个数字，范围直接确定，两个结果是互斥的，更好计算

定义基本问题为在第`i`位上，在前一位和前两位选择了某些数字和当前位是否可以自由选择的条件下，能构成的非萌数的数量。使用10表示没有选择数字，并且0一定是非萌数，分情况讨论如下

- 如果不能自由选择数字
  - 如果前一位为10，表示当前位是首位，那么需要统计以下几种情况的结果
    - 当前位不选，继续后面的计算
    - 当前位可以选`1~N-1`的数字
    - 当前位选择`N`
  - 如果前一位不为10，表示前一位和目标位相同
    - 可以选择`0~N-1`中满足非萌数要求的数字
    - 如果满足非萌数要求的话可以选择`N`
- 如果可以自由选择数字
  - 如果前一位为10，表示跳过了位数，需要统计以下几种情况的结果
    - 继续不选数字，继续后面的计算
    - 当前位可以从`1~9`选择
  - 如果前一位不为10，那么可以从`0~9`中选任意满足非萌数要求的数

⚠️计算最大数字可以先使用同余原理将该数字算出来

时间复杂度为`O(num.len()*11*11*2*10)`

### 不含连续1的非负整数

问题描述：给定一个正整数N，统计在`[0..=N]`范围上有多少个整数的二进制表示中不存在连续的1

解法：定义一个子问题为给定位数下，可能有多少个不存在连续1的数字，分情况讨论如下

- 如果没有位数，那么有1个
- 如果只有1位，那么有2个
- 如果有k位，那么如果k位上是0，有`dp[k-1]`，如果k位上是1，有`dp[k-2]`，结果就是`dp[k-1] + dp[k-2]`

因为题目给定的是一个正整数，所以最高位一定是0，那么从第30位（0位开始计算）开始，定义基本问题为在第`i`位上，前面所有位数都和目标数相同，还能构成多少个不存在连续1的数字，分情况讨论如下

- 如果该位上是0，那么直接递归调用计算后面的位数`f(i-1)`
- 如果该位上是1，那么当该位是0的情况下，直接使用上面子问题的答案，此时不需要递归计算，如果该位使用1，那么只有当它的前一位不是1的情况下开始递归调用下一位，否则直接退出递归`f(i-1)`

时间复杂度为`O(30)`

### 范围内的数字计数

问题描述：给定两个正整数，求在`[a..=b]`范围上的所有整数中，每个数码（`0~9`）各出现了多少次，并且`a`和`b`都大于等于1

解法：在每一位上，统计出现次数和比较数码与该位上的数字的大小关系以及数码是否为0有关，分情况讨论如下

- 数码非0
  - 如果数码小于目标位，那么它之前有`0~pre`总共`pre+1`种可能，它后面有几位就有`10^suf`种可能，两种组合相乘即可
  - 如果数码大于目标位，那么它之前有`0~pre-1`总共`pre`种可能，它后面有几位就有`10^suf`种可能，两种组合相乘即可
  - 如果数码等于目标位，那么它之前有`0~pre`总共`pre+1`种可能，它后面有它后面位数构成的数字种可能，两种组合相乘即可
- 数码为0
  - 如果数码小于目标位，那么它之前有`1~pre`总共`pre`种可能，它后面有几位就有`10^suf`种可能，两种组合相乘即可
  - 如果数码等于目标位，那么它之前有`1~pre`总共`pre`种可能，它后面有它后面位数构成的数字种可能，两种组合相乘即可

时间复杂度为`O(num.len())`

## 动态规划中得到具体决策方案的技巧

[code](./examples/67-dp-decision.rs)

[code](./examples/67-decision-newcoder.rs)

[code](./examples/67-longest-incremental-newcoder-lg.rs)

[code](./examples/67-diving-lg.rs)

很多动态规划问题要求的不是一个值，而是具体方案，可以使用以下两种方式得到具体方案

- 利用动态规划表生成决策路径
- 有时候需要额外的路径收集结构

### 最长公共子序列其中一个结果

问题描述：给定两个字符串，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则输出-1

解法：先将dp表填好，两个字符串的最长公共子序列的解法见[最长公共子序列](#最长公共子序列)。然后从dp表上得到结果，dp表的定义是`i`和`j`长度的两个字符串的最长公共子序列的长度是多少，那么对于`dp[i][j]`，如果`str1[i] != str2[j]`，则答案一定是从上或者左得到，如果`str1[i] == str2[j]`，那么答案是从左上得到，据此可以推出（逆向）某个具体的最长公共子序列

### 最小的必要团队

问题描述：给定一个数组表示所需技能清单，给定一个二维数组表示备选人员所具有的技能列表，返回规模最小的必要团队，团队成员用人员编号表示

解法：由于题目中技能的数量不多，所以使用状压dp求解问题，先将需要的技能设置编号，然后将每个人的有效技能（被需要的）编号，初始状态为0，在第`i`个人的判断上有两种可能性，分别为选择和不选择。dp表计算完成后，从`dp[0][0]`开始将所有的有效人选得到，判断条件是当前人是最后一个人或者当前人当前状态和下一个人当前状态的结果不同，表示选择了当前这个人，因为如果结果相同表示当前这个人没被选，取了下一个人开始的结果

### 最长递增子序列字典序最小的结果

问题描述：给定长度为N的数组，输出数组中最长的递增子序列，如果有多个则输出字典序最小的，这道题的字典序是将每个数字作为整体字符来排的，即数字大字典序就更大

解法：求一个数组中最长递增子序列的长度，定义基本问题为求解以`i`开头向右可以得到的最长递增子序列，并且使用一个辅助数组来记录答案（具体见[最长递增子序列](#最长递增子序列与扩展)），和模版求解的区别在于这里要搜索的是小于等于当前值的最左位置，并且需要倒序求解，而模版是正序。在得到结果的dp数组之后，从头开始遍历，如果第`i`位的子序列长度和最长长度相同，那么它直接更新结果数组`ans[0]`，因为后面出现的数字一定更小，如果更大则之前的数字的最长长度会更长，对于其它位置的数字，只要它比结果前一位的数字更大就直接更新，理由同上，开始先把所有的结果都设置为整数最大值，然后进行更新

### 潜水的最大时间与方案

问题描述：总共有N个工具，每个工具有自己的重量和阻力，以及提升在水中的停留时间。因为背包和力气有限，所以所有工具的重量和阻力有各自的限制，求要在水下停留的时间最久所需下标字典序最小的选择工具的方案。这里的字典序完全遵循字符串字典序的判定

解法：这个一个有两个限制条件的01背包问题，定义基本问题为求`1~i`号工具中，满足重量限制m和阻力限制v的情况下可以得到的最长停留时间。从第`i`号工具开始讨论，分别为选择和不选择，最大值即为结果。在求解dp表的过程中使用一个辅助结果来保存方案，根据是否选择了工具来进行记录

## 动态规划中根据数据量猜解法的技巧

[code](./examples/68-bribery-monster-newcoder.rs)

[code](./examples/68-dp-guess.rs)

[code](./examples/68-longest-subsequence.rs)

前提：方法运行的指令数不能超过10^7~10^8规模，否则就会超时

利用这个前提有两个结论

1. 想出**能通过的方法**去实现
2. 确定优化做到什么程度才能通过

### 贿赂怪兽

问题描述：开始是能力是0，目标是从0号怪兽开始通过所有N只怪兽。如果能力小于`i`号怪兽，则必须花钱贿赂此怪兽，然后得到此怪兽的能力。如果能力大于等于`i`号怪兽，那么可以不贿赂此怪兽，直接通过，且能力不会下降。问通过所有的怪兽需要花的最少钱数

#### 能力值的数据范围更大

解法：定义基本问题为通关`0~i`号怪兽且正好花费`j`钱数所能得到的最大能力是多少，默认值为整数最小值，分情况讨论如下

- 如果不贿赂`i`号怪兽，那么当前的能力必须大于等于此怪兽的能力，即`dp[i-1][j] >= cap[i]`，如果满足结果就是`dp[i-1][j]`
- 如果贿赂`i`号怪兽，那么需要满足当前的钱数大于所需钱数且`dp[i-1][j-money[i]] != i32::MIN`，即存在历史结果，即`j >= money[i]`，如果满足结果就是`dp[i-1][j-money[i]] + cap[i]`

两者取最大值即可，默认情况是当没有怪兽的情况下，花多少钱都是获得最大为0能力

#### 贿赂所需钱数范围更大

解法：定义基本问题为通关`0~i`号怪兽在拥有`j`能力的情况下所需的最少钱数是多少，默认为整数最大值，分情况讨论如下

- 如果不贿赂第`i`号怪兽，那么当前能力需要大于怪兽能力`j >= cap[i]`，结果就是`dp[i-1][j]`，否则结果更新为整数最大值
- 如果贿赂第`i`号怪兽，那么需要`dp[i-1][j-cap[i]]`结果存在，结果是`dp[i-1][j-cap[i]] + money[i]`

两者取最小值即可，默认情况是当没有怪兽的情况下，只有0能力结果钱数为0，其余为整数最大值

### 选择k个数字使得两集合累加和相差不超过1

问题描述：给定一个整数N，表示1~N这些数字可以选择，给定一个正数`k`，表示要从1~N中选择`k`个数字组成集合A，剩下数字组成集合B，需要做到A和B的累加和相差不超过1。如果能做到返回集合A选择了哪些数字，任何一种方案都可以。如果不能做到返回长度为0的数组。数据规模为`2 <= N <= 10^6, 1 <= k <= N`。**大厂笔试题**

解法：如果使用01背包解法，那么需要定义一个问题为在第`i`个数字上，剩余`k`个数字可以选，要满足累加和为`sum`的情况下是否可以满足要求，根据题目给定的数据规模可知这种解法无法通过测试。题目的含义其实是，当所有数字的累加和为偶数时，所选数字集合的累加和为其一半，否则所选数字集合的累加和可以是一半或者一半加1（如果前者无法实现），并且由于所有数字是连续的，则存在一种快速选择数字的方式，先将`k`个数字选择到前`k`个数，然后判断和目标数字的差距，然后计算将第k个数移动到最后一位上可以增加的数量，用目标数字除这个量向下取整就是需要移动的数字个数，然后剩下的一个数字需要补足缺少的数，最终将还剩下的数字补上即可，需要先判断目标数字是否在最小和最大数字的范围内。这种解法的时间复杂度基本在`O(N)`范围

### 两个排列的最长公共子序列长度

问题描述：给出由1~N这些数字组成的两个全排列，求它们的最长公共子序列长度，数据规模是`N <= 10^5`

解法：如果按照求两个数组的最长公共子序列，那么至少需要一个大小为N^2的dp表，根据题目的数据规模来看这种方式无法通过。由于两个全排列的长度相同，且数字范围固定，所以可以先记录在第一个数组中每个数字的索引，然后根据这个信息将第二个数组转换为索引数组，此时只要求这个索引数组的最长递增子序列长度即可。因为第二个数组转换出的结果的排序就是第一个数组中数字的相对顺序，所以可以两个数组的最长公共子序列长度通过求解最长递增子序列长度即可得到

### 使数组严格递增的最小操作数

问题描述：给定两个整数数组，返回使数组1严格递增所需要的最少操作数（可能为0），每一步操作可以从数组1和数组2中各选出一个有效索引，然后进行`arr1[i] = arr2[j]`赋值，如果进行各种操作后无法让数组1严格递增则返回-1，数据规模为`1 <= arr1.len(), arr2.len() <= 2000, 0 <= arr1[i], arr2[i] <= 10^9`

解法：如果定义问题为在数组1的`i`位置后的所有数字被修改为严格递增所需的最少操作数，那么第二个影响参数就是前一个数，已知题目中数组中元素大小非常大，所以这种尝试是无法通过的。修改基本问题为求解在前一个数字不变的（即使用原数组元素）情况下，包括第`i`位置元素以及之后所有元素要严格递增所需的最小操作数为多少，此时影响参数只有一个，由于是严格递增，所以数组2中有意义的元素需要去重并排序，在任意位置上，如果可以不换，那么计算下一个位置的结果，最终取最小值。时间复杂度为`O(N*(N.min(M) + log(M)))`

## 动态规划专题总结与预告

动态规划：一些递归有重复计算，可以用空间记录返回值来避免重复计算。同时还有相关的一整套原理和技巧的总和

什么样的递归可以变成动态规划：设计的可变参数类型简单，即不比int类型更复杂的递归，可以变成动态规划。如果递归过程中的路径信息比较复杂（回溯），那么不能或者没有必要改动态规划。有些虽然有路径信息，但是路径信息比较简单的话也可以改成动态规划（例如状压dp）

- 重叠子结构：除了数据量不一样，子过程逻辑相同的结构，即递归过程
- 最优子问题：大问题的最优解通过最优的子问题的解得到
- 无后效性：
  - 之前过程的决策所造成的参数变化要带到之后的过程中
  - 之前过程的决策不能对后面的过程影响因素特别大

## 贪心经典题目专题1

[code](./examples/69-greedy-1.rs)

[code](./examples/69-meeting-ii-newcoder.rs)

[code](./examples/69-concat-sticks-lg.rs)

狭义的贪心：每一步都是在当前状态下做出最好的选择，从而希望最终的结果是最优或最好的

广义的贪心：通过分析题目自身的特点和性质，发现让求解答案的过程变得更快，都算是广义的贪心

贪心题目的难度在于证明局部最优可以导向全局最优，不建议每道题都去证明，使用对数器来验证结果

有关贪心的若干现实情况和提醒

- 不要纠结严格证明，浪费时间收益很低，贪心千题千面，带点玄学
- 一定要掌握写对数器的技巧，这是解决贪心问题的关键
- 解法几乎只包含贪心的思路，通常代码量不大
- 大量积累贪心的经验，重要的不是证明，而是题目的特征以及贪心方式的特征，总结好以便借鉴
- 关注题目的数据量，题目的解法可能来自贪心，也可能不是，能用普通解法过尽量使用普通解法（稳）
- 贪心在笔试中出现概率更高，在面试中出现概率不高，原因是笔试需要淘汰率，而面试需要区分度，纯贪心的问题是想没想出来的二元区分，区分度很低
- 广义的贪心无所不在，可能和其它思路相结合，一般都可以通过自然智慧想明白，不需要证明

### 最大数

问题描述：给定一个非负整数数组，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数

解法：参照背景问题解法，将所有数字转换为字符串，然后按照拼接顺序排序，与背景问题的排法相反即可

#### 最大数的背景问题

问题描述：给定一个仅包含小写字母组成的字符串的数组，将它们重新排序并拼接得到一个字典序最小的字符串，求这个字符串

解法：本题的贪心尝试是将字符串数组重新排序，比较依据是`a|b <= b|a`，这里`|`表示字符串的拼接，严格证明过程如下

##### 证明比较方式具有传递性

传递性表现为`a|b <= b|a, b|c <= c|b ==> a|c <= c|a`，如果将小写字母当作26进制的整数，那么定义一个函数`f(k)`表示`k`字符串对应的26的字符串长度次方，所以`a|b = a*f(a)+b`，证明过程如下

```text
1) a*f(a)+b <= b*f(b)+a
2) b*f(b)+c <= c*f(c)+b

对1)两侧进行 -b +c
对2)两侧进行 +a -b
1) a*f(a)+c <= (b*f(b)+a-b)+c
2) (b*f(b)+a-b)+c <= c*f(c)+a

得到
a*f(a)+c <= c*f(c)+a ==> a|c <= c|a
```

此时可知这种排序方式具有传递性，即排序结果最后是一个固定的有序序列

##### 证明排序后数组中任意两个位置的元素交换都会增大拼接结果的字典序

`... a m1 m2 m3 b ...`如果交换`a`和`b`，证明过程如下

```text
... a m1 m2 m3 b <= ... m1 a m2 m3 b ... (因为a|m1 <= m1|a)
... m1 a m2 m3 b <= ... m1 m2 a m3 b ...
.
.
... m1 b m2 m3 a <= ... b m1 m2 m3 a ...
```

因此贪心思路可证明为正确

### 两地调度

问题描述：公司计划面试2N个人（偶数），给定一个数组表示每个人飞往A和B地所需的费用，求在每个城市都有N人的条件下所需的最少费用

解法：首先将所有人移动到A地，然后计算每个人从A到B所需要多支付的费用（可能为负数），将这个费用按照从小到大排序，将前N个人移动到B地，累加上他们的移动花费到之前所有人移动到A地的费用就是结果

### 吃掉N个橘子的最少天数

问题描述：厨房总共有N个橘子，每天有三种方案可以吃橘子，1）吃一个橘子，2）如果为2的倍数，吃N/2个橘子，3）如果为3的倍数，吃2/3N个橘子。返回吃掉N个橘子的最少天数

解法：根据题意，只要橘子数大于等于1就应该按比例吃橘子，所以在超过两个橘子的时候只有两种方案可供选择，要么一天吃一个到（或者直接是）2的倍数，然后吃一半，要么一天吃一个到（或直接是）3的倍数，然后吃2/3，从中选择一个最小值。可以使用dp表来存储中间答案

### 会议室II

问题描述：给定一个会议时间安排的数组，每个会议时间都包括开始和结束时间，返回所需会议室的最小数量，即一个会议室可以覆盖多个会议

解法：这道题跟"线段最多重合问题"是一样的，将会议时间按照起始时间排序，再创建一个小根堆，开始遍历会议时间安排数组，如果当前会议的起始时间大于目前的堆顶的会议结束时间，那么就弹出堆顶的时间，将此刻的时间插入，在插入后堆的大小就是目前所需的最小会议室数量

### 课程表III

问题描述：有N门不同的在线课程，从1到N编号，给定一个数组表示第`i`门课会持续上多少天且必须在不晚于某个时间完成。学期从第1天开始，且不能同时修读两门及以上的课程，求最多可以修读的课程数组

解法：基本思路是截止日期越靠前的课程越要优先考虑，所以按照截止日期从小到大排序，准备一个大根堆来存储选择课程的代价（消耗的时间），遍历每个课程，如果当前到的时间加上这个课程的持续时间没有超过它的截止时间，那么插入堆中，如果超过了，就查看堆顶的元素，如果当前的代价小于堆顶的代价，那么将此课程替换进堆顶（因为按照截止日期排序了，所以堆中的元素都是可以完成的课程，当前代价更小且截止日期更晚，结果一定更好），最终堆的大小就是答案

### 连接棒材的最低费用

问题描述：有一些长度为正整数的棍子，每个棍子的长度以数组形式给出。可以通过支付两个棍子长度之和的成本将任意两个棍子连接起来，求连接所有棍子直到剩下一个棍子所需的最小成本

问题描述：思路证明见哈夫曼编码的最小代价。需要一个小根堆，将所有的棍子长度插入小根堆中，一次弹出两个，相加之后记录一次成本再次插入堆中，直到堆中只有一个数字，返回所有成本

## 贪心经典题目专题2

[code](./examples/70-greedy-2.rs)

[code](./examples/70-max-meeting-lg.rs)

### 砍竹子II

问题描述：现在需要将一根指定长度的竹子砍为若干段，每段长度均为正整数，求所有长度的最大乘积是多少。结果需要对`10^9+7`取模

解法：划分方式就是根据总长度对3取模的情况来讨论

- 如果长度模3为0，那么将竹子分为除3份
- 如果长度模3为1，那么将竹子先分两份2，然后剩余分为除3份
- 如果长度模3为2，那么将竹子先分一份2，然后剩余分为除3份

计算过程使用乘法快速幂即可

#### 预备知识：乘法快速幂

如果要求一个数的幂次，可以将它的幂次以二进制的形式展示，然后设`x = N`，那么每次`x = x * x`，就会让乘积以2的幂次增长，例如求`10^75`，75的二进制表示是`1001011`，也就是只需要计算`10^64*10^8*10^2*10^1`，所以时间复杂度就是`O(logN)`

### 分成`k`份的最大乘积

问题描述：一个数字N一定要分成`k`份，求所有划分的数可能得到的最大乘积是多少。数字`N`和数字`k`的数据规模都在`10^12`，返回对`10^9+7`取模的结果。**真实大厂笔试**

解法：因为要分成`k`份，直观思路是每份都数尽量接近平均数，所以先将`N/k`，然后将剩下的`N%k`份数各加1，然后两部分使用乘法快速幂求结果再相加。再使用暴力递归写一个解法来验证即可

> 这道题使用动态规划不能做，因为求中间数的过程需要取模，这就导致结果之间无法进行比较

### 会议必须独占时间段的最大会议数量

问题描述：给定若干会议的开始、结束时间，当你参加某个会议期间不能参与其它会议，结束时间和开始时间相同允许连续参加，求能参与的最大会议数量。**真实大厂笔试**

解法：思路是按照会议的结束时间从小到大排序，然后遍历所有会议，只要当前会议的开始时间大于等于之前会议的结束时间就参加，累计参加的会议数量就是答案。使用全排列验证的方法来写对数器验证算法

### 会议只占一天的最大会议数量

问题描述：给定若干会议的开始、结束时间，在任何会议召开的时间段，只需要抽一天参加，在当天不能参与其它会议，求可以参加的最多的会议

解法：将所有会议按照开始时间排序，找到最早的会议开始时间和最晚的会议结束时间，遍历每一天，首先将当天可以参与的所有会议的结束时间插入一个小根堆，然后将小根堆中已经无法参加的会议（即结束时间已经小于当天）移出，最终选择一个会议参加即可，这里要将堆中的时间弹出，防止重复计算

### IPO

问题描述：有N个项目，每个项目给定纯利润（做完项目会赚的钱）和做项目所需要的最小资本。给定一个初始资本，完成一个项目就能获得纯利润，最多选择`k`个不同的项目，同一时间只能做一个项目。求最终可以获得的最多资本

解法：首先将所有项目组织起来，按照它们的启动资金为排序依据插入小根堆中，然后准备一个大根堆，以达到`k`个项目限制的情况开始遍历，每次将小根堆的项目取出，将所能当前能做的项目插入到大根堆中，然后取大根堆的项目做（如果大根堆不为空）并累加利润，如果大根堆为空或者到达`k`个项目的限制则退出循环

### 加入差值绝对值直到长度固定

问题描述：给定一个非负整数数组，计算任何两个数差值的绝对值，如果数组中没有就将此结果插入到数组中，重复这个过程直到数组的长度固定，返回数组最终的长度。**真实大厂笔试**

解法：遍历一遍数组，统计每个数的词频，并且记录（不包含0的）最小值和最大值，然后求这两个数的最大公约数，那么在这个最大公约数到最大数之间所有的倍数都会存在在数组中，补齐数量即可。如果数组中全是0，答案为数组长度，如果存在0，则最大公约数计算时不包含0，如果不存在0且存在词频超过1的数，那么最后要加上一个0。对数器验证方式可以使用暴力遍历测试，将所有的组合计算并加入到数组中直到数组长度固定

## 贪心经典题目专题3

[code](./examples/71-greedy-3.rs)

### 最短无序连续子数组

问题描述：给定一个整数数组，需要找出一个连续子数组，对这个子数组进行升序排序，然后整个数组都变为升序排序。求这个子数组的最短长度

解法：思路是找到这个最短子数组的左右两端位置，只需要正反向遍历两遍数组即可，从左往右遍历时记录最大值，只要当前值小于这个最大值，就更新右端位置，然后从右往左遍历，只要当前值大于已遍历部分的最小值，就更新左端位置，最后右端位置减去左端位置就是答案

### 最小区间

问题描述：有`k`个非递减排列的整数列表，找到一个最小区间，使得`k`个列表中的每个列表都至少有一个数包含在其中

解法：首先有一个广义的贪心（提高解题速度）就是答案中的区间一定包含这些整数列表中的数字，否则那个范围总是更大。使用有序表（`TreeSet`）做这道题可以解决每次拿到当前的最大最小数字。思路是准备一个有序表，首先将所有列表的头元素加入进去（需要按照值、列表索引进行排序以防止重复元素被忽略），然后得到一个答案区间，然后进入循环，取出最小的数字，找它所在列表的下一个元素放进有序表，如果没有元素则直接退出循环

> 这道题也能用堆做，思路相同，稍麻烦

### 组团买票

问题描述：景区一共有M个项目，每个项目给定两个参数`(ki, bi)`，`ki`表示折扣系数，`bi`表示票价，对于每一个项目只要来一个人，它的票价就是`bi - ki * (his_p)`，`his_p`为包括他的所有玩这个项目的人数，这个价格最终是大于等于0。现在有N个人，每个人可以选一个项目或者不选，问准备多少钱可以应付所有的可能。**真实大厂笔试**

解法：题目的问法含义就是要准备的钱数可以应对景区可以赚的最多钱数，对于每个项目，景区可以赚到的钱有一个公式`money = bi - ki * (1+people) - ki*people`，含义是当这个项目有人玩的时候，这个人的折扣要被减掉并且新人带来的新折扣会影响之前所有人的票价，还需要继续减掉这个值。准备一个大根堆，将所有项目按照赚钱数维护进去，每次取一个最赚钱的项目，累计门票价格并增加该项目人数，再插入到堆中，直到堆中取出的项目不赚钱或者赔钱，就退出循环（如果有剩下的人，统一认为不选择项目）。使用暴力递归来遍历所有可能计算结果

### 平均值最小累加和

问题描述：给定一个长度为N的数组，给定一个数字`k`，要将数组分为`k`个集合，每个数字只能进一个集合，返回每个集合的平均值都累加起来的最小值，平均值向下取整，数据规模为`1 <= N <= 10^5, 0 <= arr[i] <= 10^5, 1 <= k <= n`。**真实大厂笔试**

解法：思路是将前`k-1`个数字各自为1份，然后剩下的所有数字放一份，这样所有更小的数总是保留下来不被其它的数增大，且更大的哪些数被最大化的缩小。暴力解法是尝试组织不同的数字为不同的组，当所有组都有数字的时候求平均值累加即可

### 执行所有任务的最少初始电量

问题描述：给定一些任务，每个任务有需要消耗的电量和至少多少电量才能开始这两个参数，求要做完这些任务至少需要多少的初始电量。**真实大厂笔试**

解法：每个任务有两项指标，分别为消耗和需要，思路是由最终钱数为0（表示正好把钱花完）开始倒推，每次推需要的钱数为`max(cost, remain+need)`，分情况讨论如下

- 如果需要相同，那么消耗多的任务总是后执行，应该先被倒推（如果需要不同则不一定满足）
- 如果消耗相同，那么需要少的任务总是后执行，应该先被倒推（如果消耗不同则不一定满足）

由上述结论可知，需要消耗多而需要少的任务先被推，那么也就是等效为“消耗-需要”更多的先被推，将所有任务排序后计算即可。暴力方法只要将所有任务的全排列列出然后计算一个最小值即可

### 两个0和1数量相等区间的最大长度

问题描述：给出一个长度为N的01字符串，需要找到两个区间，这两个区间中1的个数相等，0的个数也相等，这两个区间可以相交但是不能完全重叠，求这两个区间的最长长度。**真实大厂笔试**

解法：思路是找左右两端为0的最先出现的位置和左右两端为1的最先出现的位置，然后计算两个长度的最大值即可

## 贪心经典题目专题4

[code](./examples/72-greedy-4.rs)

[code](./examples/72-quiz-newcoder.rs)

### 数组的最小偏移量

问题描述：给定一个正整数组成的数组，可以对任意元素执行任意次数的两类操作，如果元素是偶数则可以对其除2，如果是奇数则可以乘2。定义数组的偏移量是数组中任意两个元素之间的最大差值，返回数组在执行某些操作之后拥有的最小偏移量

解法：任意一个数，如果是偶数，它的变化范围是除2直到变为奇数之后开始乘2除2变动，而奇数会直接乘2除2变动，所以所有的奇数都有一次变大的机会，那么直接将所有的奇数乘2，此时得到一个偏移量，然后将最大数（偶数）除2，开始更新偏移量，直到最大数成为奇数（所有数中偏移量最小时的最大值），数组中的最小值总是有可能的最大值，这样就构成了最小的偏移量。题目需要借助一个有序表来实现，时间复杂度取决于进出有序表的数字个数，因为每个数字最大可能构成`logV`个数字，所以时间复杂度为`N*logV`

### 森林中的兔子

问题描述：森林中有未知数量的兔子，你可以问每个兔子一个问题“还有多少只兔子和你颜色相同”，然后答案全部收集到一个数组中，答案不一定包含所有兔子，且每个答案都保证正确，求森林中兔子的最少数量

解法：根据题意可知，如果两个兔子的答案不一样，那么它们一定不是相同的颜色，但是如果它们的答案一样，它们的颜色可能一样可能不一样，且假设一样时它们的总体数量最少。根据这个结论可以将兔子的答案从小到大排序，相同数量为一组，这一组要对`x+1`向上取整，因为`x`只和该兔子相同颜色的兔子表示总共有`x+1`个该颜色的兔子，然后这些组再乘`x+1`，累加所有结果即可。求`a / b`向上取整可以使用`(a + b - 1) / b`的方法

### 使数组相似的最少操作次数

问题描述：给定两个正整数数组，数组长度相等，每次操作可以对第一个数组的任意两个位置（不同）进行加2和减2操作，如果两个数组中每个元素出现的频率相等，那么这两个数组是相似的，求将两个数组变相似所需要的最少操作次数，数据保证两个数组一定能变相似

解法：这道题的关键在于**加2减2操作不会影响每个数字的奇偶性**，所以奇数和偶数可以分开计算，且两组数都按奇偶各自从小到大排序，按顺序进行转换，所有转换的值的绝对值累加和最后除4（每次转换可以完成4）就是结果

### 知识竞赛

问题描述：每个部门要选两个员工去参加一个需要合作的知识竞赛，每名员工有两个参数，分别为推理能力和阅读能力，如果选择任意两个员工，他们的合并能力是两者各自两种能力相加再除2，现在要让这个两个能力的最小值更大，求这个值最大是多少

解法：首先要求的值最终是多少的大小关系和除2没有关系，所以可以假设能力就是直接相加，题意是任意两者的两个能力相加之后找一个最小值，然后让这个值最大，一般的方法是`O(N^2)`时间复杂度的遍历比较。思路是将能力数组按照`|推理能力-阅读能力|`进行从小到大排序，这样排序之后，任意位置（人）的两个能力与他之前的某个人的能力之和的最小值只取决于他两个能力中更小的那个，因为前面的人两个能力差值更小，这样只需要遍历一遍所有人，同时维持之前的人两种能力的最大值即可

### 将数组分成几个递增序列

问题描述：给定一个有序的正数数组和整数K，判断该数组是否可以被分成一个或几个长度至少为K的不相交的递增子序列。数组中所有数字都要被这些递增子序列包含

解法：先求整个数组中的最大词频的数，设为`x`，然后假设有`x`组子序列，只要将这个数左边和右边的数分别按从上到下、从下到上依次分配给`x`组，这样就一定能构成递增子序列且每个子序列的元素个数尽量平均，此时只要每个子序列长度都大于等于K即可，所以判断`N/x >= K`就是答案

### 最低加油次数

问题描述：汽车从起点出发驶向目的地，该目的地的距离为`target`，沿途有加油站，每个加油站的指标是距离和油量，一直1升汽油可以走1单位路程，求为了到达目的地，汽车至少需要加多少次油，如果无法到达目的地，则返回-1

解法：汽车加油的策略是能走多远走多远，并且每经过一个加油站就需要把它能加的油记录起来（大根堆），每当走不到下一个加油站就（假装）回去加一次油，直到走到终点

## 贪心经典题目专题5

[code](./examples/73-greedy-5.rs)

[code](./examples/73-river-lg.rs)

### 跳跃游戏II

问题描述：给定一个长度为N的整数数组，表示在0下标可以从该位置往右跳的最大距离（中间的距离也都能到），求要到达`n-1`下标所需的最少跳跃次数

解法：记录一个当前位置为0，开始遍历所有的位置，如果当前位置能到达遍历的位置，则忽略此位置，如果不能到达此位置，更新当前位置为最远能到达的位置，并且此时跳的次数加1，**最后再更新最远能到达的位置（必须最后更新来处理初始位置为0的特殊情况）**

### 灌溉花园的最少水龙头数目

问题描述：在x轴上有一个一维花园，花园长度为N，从0点开始到N点结束，花园里共有N+1个水龙头（在每个点），给定一个长度为N+1的数组表示`i`位置上的水龙头可以灌溉的区域（左右方向），求灌溉整个花园的最少水龙头数目，如果无法灌溉全部花园，那么返回-1。花园是连续的，所以如果每个水龙头的覆盖范围都是0，这种情况属于无法满足要求

解法：首先维护一个数组`right[i] = j`，表示在`i`点开一个水龙头的情况下往右最远能覆盖到`j`位置，然后遍历每个点，如果当前已经打开的水龙头所能到达的点可以覆盖遍历位置，那么忽略此位置（同时需要维护一个当前所能到达的最右位置，更新这个值），否则要再开一个水龙头，更新当前位置，如果更新后的位置仍然小于遍历位置，那么说明无法覆盖所有花园

这道题和上一道题的贪心点在于记录好当前位置所能去的最远位置，到达比这个最远位置更远的位置时，要把中间过程中更新的可能扩大的最远位置取出来，再进行后续的行为

### 字符串转化

问题描述：给出两个长度相同的字符串str1和str2，每次转换可以将str1中相同字符转换为其它小写英文字母，求是否可以将str1转换为str2

解法：分情况讨论如下

- 如果两个字符串相等，那么可以转换
- 如果两个字符串不等
  - 如果目标字符串有26个英文小写字母，那么一定无法转换，因为至少发生一次转换就会消除掉一种小写字母，再也无法撤销此操作
  - 只要str1中相同字符的位置对应于str2中的字符也相同，那么一定可以转换成功，否则不可以转换。判断方法为，先记录每个英文字母的出现位置（初始为-1），在每次更新这个位置的之后同时判断str2中对应两个位置的字符是否相同即可

### 过河问题

问题描述：一共N人出游，碰到了一条河，河的两岸是东岸和西岸，每个人的渡河时间为`ti`，现在西岸有一条船，一次最多乘坐两人，如果船上有1个人，到对岸时间为该人的渡河时间，如果船上有两个人，到对岸的时间为两人渡河时间的最大值，求最少要花多少时间才能使所有人渡河

解法：首先要注意船到对岸之后还需要有人再送回来。所有人的渡河时间排序对于结果没有区别，因为可以任意人组合渡河，有两种比较明显的策略

1. 让渡河时间最短的人每次送一个渡河时间最长的人，直到最后西岸只有1个人，渡河结束
2. 每次让两个渡河时间最长的人过去，但是前提是这两个人不能再回来，所以需要有两个渡河时间最短的人先渡河，然后任意一个人回来，两个渡河长的人再过去，然后另一个渡河时间短的人再回来

定义基本问题为`0..i`的人要渡河所需要的最短时间，首先对时间进行从高到低排序，然后分情况讨论

- 如果只有1个人，那么就是他自己的渡河时间
- 如果只有2个人，那么就是后者（已排序）的渡河时间
- 如果只有3个人，那么就是第3个人的时间+第1个人的时间（回程）+第2个人的时间
- 如果大于3个人，可以比较两种策略，然后取最大值
  - 时间短送时间长，`time[i] + time[0] + dp[i-1]`
  - 时间长的一起过，`time[1] + time[1] + time[i] + time[0] + dp[i-2]`

### 超级洗衣机

问题描述：假设有N台超级洗衣机放在同一排上，开始的时候，每台洗衣机内有一定数量的衣服，也可能是空的，每一步操作中，可以选择任意台洗衣机，同时将其中的一件衣服送到相邻的一台洗衣机。求能让所有洗衣机中剩下的衣服数量相等的最少的操作步数，如果不能实现则返回-1

解法：只要所有的衣服可以整除洗衣机数量，那么一定能达成所需要的条件，对于满足条件的衣服数量，针对每台洗衣机进行分情况讨论

- 如果这台洗衣机左边所有洗衣机衣服的总数小于所需，右边也小于所需，那么这台洗衣机需要给左边衣服，也需要给右边衣服
- 左边大于，右边小于，取两者绝对值最大值
- 左边小于，右边大于，同上
- 左边大于，右边大于，同上，因为同时当前这台洗衣机能收到两件衣服

只要将所有洗衣机的转换次数都求出来，最大值就是答案，因为在那个次数可以让所有洗衣机的衣服相等

## 贪心经典题目专题6

[code](./examples/74-greedy-6.rs)

[code](./c/dream-city.c)

### 消灭怪物的最大数量

问题描述：在一款电子游戏中，在游戏中你需要保护城市免受怪物侵袭。给定两个等长数组表示怪物距离城市的距离和怪物的速度。你有一种武器，充满电需要1单位时间，并且一次能消灭一个怪物，武器开始时是充满电的，求你输掉游戏前可以消灭的怪物的最大数量，如果全部消灭则返回数组长度

解法：开枪策略是每次打距离城市最近的怪兽，一直怪兽的初始距离和移动速度，可以求出每个怪兽在什么时间点到达城市（距离/速度向上取整），每单位时间都要开枪，一旦怪物的到达时间小于等于当前时间，说明游戏结束，返回杀死怪物数量即可

### 最大回文数字

问题描述：给定一个仅由0~9组成的字符串，找出能够使用其中的数字形成的最大回文整数。以字符串形式返回，该整数不应该包含前导零。不需要使用所有的数字，但是必须至少使用一个数字，数字可以重新排列

解法：首先需要统计每个数字出现的词频，然后开始找一个中点，对于1~9的数字，只要出现过奇数次，那么最大的数字就应该是中点，只要出现非0次，那么一半数字应该从大到下填到左边，这个过程完成后，如果没有中点，如果左边没有填过数字，则返回0，否则如果0的次数是奇数中点就是0。然后将一半的0续填到左边，将左边填好的数字逆序填到右边即可

### 最大平均通过率

问题描述：给定一个二维数组，每个元素表示每个班级有x个学生能通过考试和总共多少学生，现在额外给一个整数表示一定能通过考试的学生，问如果分配这些学生到班级中可以让平均通过率最大，返回这个最大的平均通过率

解法：准备一个大根堆，将每个班级按照每增加一个天才提高的通过率幅度的大小放到堆中，然后遍历所有天才，将其分配好后更新到堆中，最后统计最大平均通过率即可。时间复杂度为`O(N*logN + M*logN)`

### 雇佣K名工人的最低成本

问题描述：有N名工人，给定两个数组表示他们的工作质量和最低期望工资。现在我们需要雇佣`k`个工人组成工资组，这个工资组中每个工人的实际工资由他们的最低期望工资和与其他工人的工作质量比例来支付工资，并且每名工人至少应该得到他们的最低期望工资，求满足上述条件的工资组所需的最小金额

解法：按照工作质量比例来支付工资就是当确定给了一名工人工资后，其他工人的工资取这个工资按照他们的工作质量比例计算出的工资和他们的最低期望工资取最大值。按照题意，组内所有人的工资是由那个工作质量单价最高的工人决定，因为满足了他的最低工资之后，其他所有工人的工资都能按比例满足且不小于他们的最低期望工资。所以需要按照工作质量单价为所有工人排序，然后准备一个大根堆来保存前`k`个人中工作质量最小的部分（因为结果就是`k`个工人的工作质量之和乘最大的工作质量单价），开始遍历数组中的每个工人，只要第`i`个工人参与到组中，那么一定是以他的质量单价计算最终结果，时间复杂度为`O(N*logN)`

### 砍树

问题描述：一共有N棵树，每棵树有两个信息：初始重量和每天增重。你每天最多能砍一棵树，砍树时的收益是这棵树的初始重量加上这棵树长到这一天的总增重。从第一天开始你一共有`m`天可以砍树，返回这些天内你能获得的最大收益

解法：如果题目中树不会随着时间增重，那么这道题就简化为了一个普通的01背包问题，基本问题就是在满足`j`天砍树的条件下砍前`i`棵树能获得的最大收益。因为砍任意一棵树都会得到它的初始重量，那么只要将所有的树按照增重大小排序，问题仍旧是一个01背包，但是排序后最后一天砍的树一定是那棵树的最大收益，对于前`i`棵树，分情况讨论如下

- 如果不砍第`i`棵树，那么结果就是`dp[i-1][j]`
- 如果砍第`i`棵树，那么这棵树一定是最后一天砍，并且收益最高`dp[i-1][j-1] + a[i] + (j-1)*b[i]`

结果取最大值即可，特殊情况是0天和0棵树，结果都是0，时间复杂度`O(N*logN) + O(N^M)`

## 博弈类问题必备内容详解

[code](./examples/75-games.rs)

[code](./examples/75-bash-games.rs)

[code](./examples/75-nim-games.rs)

[code](./examples/75-anti-nim-games.rs)

[code](./examples/75-fabonacci-games.rs)

[code](./c/wythoff-games.c)

[code](./examples/75-sg.rs)

[code](./examples/75-sg-ed-lg.rs)

[code](./examples/75-split-games.rs)

博弈类问题大致分为，公平组合游戏、非公平组合游戏（大部分棋类游戏）、反常游戏

本章的博弈类问题主要关注公平组合游戏（ICG），反常游戏属于公平组合游戏的变种。不涉及经济学相关的博弈，例如纳什博弈

公平组合游戏的特点为

1. 两个玩家轮流行动且**游戏方式一致**
2. 两个玩家对状况十分理解（神的视角，理性）
3. 游戏一定会在有限步数内分出胜负（不会产生循环）
4. 游戏以玩家无法行动结束

ICG的特点是当状态确定，结局也就已经确定了，没有任何随机的成分。游戏中的每一个状态只有必胜态和必败态两种状态。这类博弈问题的结果没有意外，任何一方想通过自身努力改变游戏结局都是不可能的，*这一点比较反直觉*

### 巴什博弈(Bash Game)

问题描述：一共有N颗石子，两个人轮流拿，每次可以拿1~M颗石子，拿到最后一颗石子的人获胜，根据N、M的值判断谁赢

解法：这个游戏的结论是，如果N**不是**`(M+1)`的整数倍，则先手赢，否则后手赢。因为如果不是整数倍，先手会通过拿1~M数量的石子让石子剩下`(M+1)`的整数倍给后手，而后手碰到这种情况无法再通过拿石子把石子的数量改为整数倍，所以后手一定输，因为他最后一定会碰到`M+1`个石头

### 质数次方版取石子(巴什博弈扩展)

问题描述：一共有N颗石子，两个人轮流拿，每一轮当前选手可以拿`p^k`颗石子，保证`p`是质数且`k`是自然数，根据石子数求谁会赢，如果先手赢返回"October wins!"，后手赢返回"Roy wins!"。（注：自然数包括0）

解法：根据题意，每个人可以拿的石子数量是从1（任何质数的0次方）开始，到其他任意数字，但是每个人都拿不了6的整数倍数量的石子，因为6的因子是2和3，没有一个质数的次方能同时包含这两个质数，所以结论就是只要总石子数量是6的整数倍，那么先手输，否则后手输

### 尼姆博弈(Nim Game)

问题描述：一共有N堆石头，两个人轮流进行游戏，每个玩家的回合可以在任何一个非空的石头堆移除任意正数的石头数量，谁先拿走最后的石头就获胜，求最终谁会获胜

解法：尼姆博弈的结论是，如果所有堆的石头数量的异或和为0，那么后手赢，否则先手赢，证明如下

首先最后的局面是所有堆石头都为0，那么异或和也为0，此时当前选择的选手就输了，所以初始状态如果异或和为0那么先手输，否则后手赢，那么有两点需要证明

1. 对于任意异或和为0的情况，选手取一部分石头后会造成一个异或和不为0的情况给另一个人
2. 对于任意异或和不为0的情况，选手总能在任意堆上取一部分石头造成异或和为0的情况给另一个人

对于1来说，如果异或和为0，表示在每一位上，所有堆上的0/1数量和都是偶数，那么在任意一个非空堆上拿走任意数量石头，一定会减少1，从而让这个石头堆的异或和变为非零状态

对于2来说，只要在各堆石头上找到跟异或和的最高位的1对应位是1的那个石头堆（一定可以找到，因为那一位的1的数量是奇数个），然后去除那一堆石头，其他堆石头的异或和就是总异或和和这堆石头的异或和，总异或和这一位之上的所有位都是0，所以不需要考虑，对于下面部分，只要拿走一部分数量使得剩余数量跟其他堆石头异或和为0即可，这一定可以实现，因为低位的变化范围是固定的

因为上述两点得证，所以在任意状态下，游戏结局已经确定

### 反尼姆博弈(反常游戏)

问题描述：一共有N堆石头，两人轮流游戏，每个玩家回合中需要选择任何一个非空的石头堆，从这堆石头中移除任意正数的石头数量，谁先拿走最后的石头就失败，返回最终谁会获胜，先手获胜打印John，后手获胜打印Brother

解法：题目的描述和尼姆博弈是反过来的，所以叫做反常游戏。根据题意可以对石头堆分情况讨论

- 如果每堆石头都只有1个，那么奇数先手输，偶数后手输，这是确定的
- 如果除了一堆石头大于1个，其它堆石头都只有1个，那么先手必赢，因为他可以控制所有数量为1的石头的堆数
- 其它情况，已知上一种情况异或和一定不为1，由尼姆博弈可知，如果当前异或和为0，那么先手拿石头一定会让异或和为非0，所以后手一定会赢（因为后手最后一定能面对第二种情况），否则先手一定赢

### 斐波那契博弈(Fibonacci Game + Zeckendorf定理)

问题描述：一共有N枚石子，两个玩家按照如下规则进行游戏：先手后手轮流取石子，先手第一轮可以取走任意的石子，接下来每一轮当前玩家至少要取走一个石子，最多取走上一次取的数量的2倍。玩家取走的数量必须不大于目前场上剩余的石子数量，双方以最优策略行动。这个游戏先手一定赢（第一次可以任意取具有改变局面的能力），但是先手想知道自己至少取走几颗石子就保证获胜

解法：首先有结论，如果石子数量是一个斐波那契数，那么先手第一次不拿完所有石子就必输，更小的斐波那契数可以直接观察，而更大的斐波那契数可以分成两个更小的数（本身就是递归相加），且题目要求最多取上次的两倍，那么以5为例，2和3，第一次如果取小于2，那么后手可以留个3，如果取大于2，后手也直接赢。然后根据zeckendorf定理知任何一个正整数都可以被分解成不相邻的斐波那契数的和，所以只要先手拿走最小的那个斐波那契数即可，后手一定拿不完剩下的所有石子（最多两倍，因为不相邻）。对于给定的石子数，生成这个范围内所有的斐波那契数，然后看它由哪些数组成，方式是二分查找离它最近且小于它的斐波那契数（生成时有序），如果这个数本身是斐波那契数，就返回它，遍历直到当前组成的数是1或者2即可。如果没有找到答案直接返回石头堆数（说明初始为1或2）

### 威佐夫博弈(Wythoff Game)

问题描述：有两堆石子，数量任意，可以不同，游戏开始两人轮流取石子。游戏规定每次有两种不同的取法。1）在任意的一堆中取走任意多的石子，2）可以在两堆中同时取相同数量的石子。最后把石子全部取完者为胜者。给出初始的两堆石子的树木，返回先手能否取胜

解法：威佐夫博弈的结论是：

1. 小堆 != (大-小)*黄金分割比例，先手赢
2. 小堆 == (大-小)*黄金分割比例，后手赢

计算乘法的结果需要向下取整

### SG函数和SG定理

图游戏的概念：如果把游戏的每个局面（状态）都看作图中的一个点，每个局面可以通过一种行动来走向下一个点。如果当前行动有若干个，那么就代表这个点有若干个后续节点，最终，必败局面的点认为不再有后继节点。所以对于公平组合游戏（ICG），可以等效为一张图

SG（Sprague-Grundy）函数，以下是SG函数值的求解方式，俗称mex过程

- 最终的必败点是A，定义`sg(A) = 0`
- 假设状态点是B，那么`sg(B)`是查看B所有的后继节点的sg值，其中没有出现过的最小的自然数（0也是自然数）

根据SG函数的返回值来判断当前局面是先手赢还是后手赢，如果SG值等于0则后手赢，否则先手赢。如果`sg(B) != 0`，那么说明它的后继节点一定有`sg(rear) = 0`，先手就可以通过某次行动把这个必败局面留给后手，所以先手一定赢，`sg(A) = 0`同理

> 虽然判断SG的值只需要判断是否为0，但是因为SG定理的应用，所以要求SG的值为整数（自然数）

SG定理（Bouton定理），如果一个ICG游戏又若干组独立的ICG子游戏组成，那么有`sg(all) = sg(a) ^ sg(b) ^ sg(c)...`。任何ICG游戏都是如此，正确性证明类似于尼姆博弈

当数据规模较大时，要学会使用对数器打印SG表，观察看能不能寻找出规律

#### SG函数展示巴什博弈

```rust
fn sg_bash_games(n: i32, m: i32) -> bool {
    let mut sg = vec![0; n as usize + 1];
    let mut appear = vec![false; m as usize + 1];
    for i in 1..=(n as usize) {
        appear.fill(false);
        for j in 1..=(m as usize) {
            if j <= i {
                appear[sg[i - j] as usize] = true;
            } else {
                break;
            }
        }
        for (ti, &b) in appear.iter().enumerate() {
            if !b {
                sg[i] = ti as i32;
                break;
            }
        }
    }
    if sg[n as usize] == 0 { false } else { true }
}
```

#### SG定理展示尼姆博弈

首先找到最大石头堆的数量，然后求解1~max的SG函数的值，然后遍历石头堆求一个异或和即可

#### 两堆石头的巴什博弈

问题描述：有两堆石头，数量分别为a、b，两个人轮流拿，每次可以拿1~m颗，拿走最后一颗石子的人获胜。**真实大厂笔试**

解法：这是两个相互独立的子游戏组成的ICG，所以分别计算两堆石头的SG值，每堆的计算过程和巴什博弈相同。然后做异或计算即可（SG定理）。需要使用动态规划来验证结果

因为只有两堆石头，所以要使它们的异或和为0的条件就是两者SG值相等，而根据巴什博弈的SG值的特点，只要判断`a%(m+1) = b%(m+1)`即可

#### 三堆石头拿取斐波那契数博弈

问题描述：有三堆石头，数量分别为a、b、c。两个人轮流拿，每次可以选择其中一堆石头，只能拿取斐波那契数的石头，拿走最后一颗石子的人获胜，数据规模石头在`10^5`以内。**真实大厂笔试**

解法：依旧是算出这种拿取石头的方式对于每堆石头的SG值，然后做异或运算，这道题需要注意的是从SG表中并不容易看出规律，且由于斐波那契数增长速度很快，所以时间复杂度在这个数据量下基本在`O(N)`量级，可以答题完事，不需要非得找出规律

#### E&D游戏

问题描述：桌上有2N堆石子（偶数），其中每两堆为一组。每组可以进行分割操作，任取一堆石子，将其移走，然后分割同一组的另一堆石子，从中取出若干石子放在被移走的位置，组成新的一堆。操作完成后组内每堆的石子数必须保证大于0，显然被分割的一堆石子数至少为2。两个人轮流进行分割操作，如果轮到某人进行操作时，所有堆的石子数均为1，那么此人输掉比赛，返回先手能不能获胜

解法：每一组作为一个子游戏需要先求解各组的SG值，这里因为每组有两堆石子，所以SG表就是二维的，然后应用SG定理即可。由于石子的数量非常大，所以算出表中所有的值是不可能的。需要使用动态规划的方法求出一组的两堆石头的SG值，然后需要**观察规律**，结论就是对于任意两堆石子，`(a-1)|(b-1)`结果的0的最高位就是该组的SG值。这种观察的结果没有理由，应该就是这么设计的，需要多做练习来熟悉

⚠️注意，使用动态规划求SG值时`appear`数组需要每次求解子项之前初始化

#### 分裂游戏

问题描述：一共有N个瓶子，编号为0~N-1，每个瓶子有`nums[i]`个糖豆，所有糖豆是相同的。游戏规则是两个玩家轮流取糖豆，每一轮的玩家必须选i,j,k三个编号，并且满足`i < j <= k`，当前玩家从`i`号瓶拿出一颗糖豆，分裂成两颗糖豆，并且往`j`和`k`瓶子各放入一颗，分裂的糖豆和普通糖豆无区别。要求`i`号瓶一定要有糖豆，如果`j == k`，相当于从`i`拿出一颗，向`j/k`放入两颗。如果轮到某个玩家发现糖豆全部放在N-1号瓶（必然结果），导致无法行动，那么该玩家输掉比赛。先手希望知道，第一步如何行动可以保证自己获胜，要求返回字典序最小的行动（字典序按照每个编号本身作为一个字符，即`2 < 11`，而不是字符串字典序）。如果先手怎么行动都无法获胜，返回“-1 -1 -1”，还需要求先手自己有多少种第一步取糖豆的行动，可以确保自己获胜，返回方法数

解法：因为每次操作都会把一颗糖豆分裂后放到更后面的瓶子中，所以单个瓶子的豆子并不构成一个ICG。根据题意可知最后所有的豆子（包括分裂后的）都会在最后一个瓶子中，那么可以将这个游戏的子游戏等效为将任意瓶子的豆子移动到最后一个瓶子，这是一个ICG，符合ICG的要求，最终如果豆子已经在最后一个瓶子，表示该选手失败，回到原游戏视角，选手的目标就是将所有的豆子移动到最后一个瓶子，且每个豆子都是独立进行的。为了方便SG值的计算，将最后一个瓶子的编号设置为0，从右往左依次增加，有`SG(0) = 0`，遍历其他瓶子的豆子的后继节点需要循环遍历所有可能，异或所有的子游戏SG值求解当前游戏的SG值。最后计算总游戏的SG值，因为每个瓶子的所有豆子的异或和只跟数量的奇偶性有关，所以不需要做每个瓶子的计算。最后根据总SG值来判断先手是否会赢，然后开始遍历第一步，瓶子一定是从左到右遍历（保证字典序最小），每次第一步导向的下一个总SG值都是原先的SG值异或上关联的两个或者三个瓶子的SG值（根据奇偶性求异或和的关系可知，无论是多一个还是少一个豆子，原瓶子的新SG值都是异或上它本身），当新局面是必输时统计获胜数即可

## 质数判断、质因子分解

[code](./examples/76-prime.rs)

[code](./examples/76-miller-ranbin-lg.rs)

### 判断较小的数字是否是质数

解法：一个数字N，从2开始判断它是否能整除这个数，直到`√N`，时间复杂度`O(√N)`

如果一个数不可以被2整除，那么N/2之后的所有数都不可能被整除，以此类推，直到根号N可以筛选1/根号N的数字，之后不需要再判断。这种方法如果判断一个10^9的数，单次时间复杂度大概在10^4~10^5，如果要判断很多个这样的数字，或者这个数更大，那么时间复杂度就不够好

### 判断较大的数字是否是质数

判断N是否为质数，Miller-Rabin方法的大概步骤为

1. 每次选择一个1~N-1范围上的数字，或者使用小于N的质数进行测试
2. 测试过程中应用的原理不用纠结，除了验证质数以外没有扩展性
3. 原理：费马小定理，Carmichael（卡米切尔数（合数），费马素数判定法会误判），二次探测定理（算法导论31章），乘法同余和快速幂
4. 经过s次Miller-Rabin测试，s越大出错几率越低，但是速度会变慢，通常20次即可

⚠️因为使用了乘法同余，所以对于long类型（64位）数字的乘法，需要转为更高位数（128）位进行

时间复杂度为`O(s*(logN)^3)`，`s`表示试的次数

### 质因子分解

> 本节内容中的方法已经够用，扩展方法有pollard_rho启发式算法分解质因数，利用概率知识

质因子的分解过程就是从2开始遍历后面的整数，如果该数可以整除，那么直到整除到无法整除，进行下一个数字的判断，直到`√N`为止，当没有数可以整除后，如果剩下的那个数不是1，就是最后一个质因子。时间复杂度为`O(√N)`

#### 按公因数计算最大组件大小

问题描述：给定一个由不同正整数组成的非空数组nums，如果`nums[i]`和`nums[j]`有一个大于1的公因子，那么这两个数之间有无向边，返回nums中最大连通组件的大小

解法：首先计算每个数字的所有质因子，使用一个并查集维护每个质因子所包含的索引集合，遍历完之后返回那个长度最大的集合即可

### 质数筛

质数筛解决的问题是从1~N个数中返回所有的质数。除了每个数字跑质数测试以外有更好的方法，即质数筛

#### 埃氏筛

时间复杂度为`O(N*log(logN))`。首先使用一个布尔数组记录所有的数字是否为质数，初始均为质数，然后从2开始遍历每个数字，如果是质数，那么将它的整数倍（从`i`开始）都设置为合数，直到遍历到`√N`为止，最后统计所有的质数数量。时间复杂度的计算大概理解是，每遍历到一个数，就会缩小`1/i`的问题规模，由于`n+1/2+1/3+...1/n`的时间复杂度收敛于`O(N*logN)`，而埃氏筛每次会缩小`1/i`（`i`是质数）的问题规模，这个数字要比`O(N*logN)`更小

如果仅统计质数数量，埃氏筛可以进行改进，首先认为质数数量为`(N+1)/2`，然后从3开始遍历所有的奇数，如果碰到质数，就更新从`i*i`开始，每次递加2*N的数，直到小于N，因为（两个奇数相加）偶数一定不会是质数，如果这个数还是质数，就更新为合数，并且从估计的合数减1，表示有奇数不是质数。⚠️特殊情况是`N < 2`时返回0

#### 欧拉筛

时间复杂度为`O(N)`。因为原始的埃氏筛在更新的时候仍然会多次更新同一个数，所以欧拉筛的改进是每个数字只被它的最小质因子更新。准备一个布尔数组记录所有的数字是否为质数，默认所有数为质数，然后使用一个数组统计质数，从2开始遍历，如果这个数是质数，收集之后，从该数开始遍历收集的质数，将这个数与之前的质数的乘积都设置为合数，如果这个数字可以整除之前的质数就进入下一个循环，说明这个数本身包含更小的质因子。统计质数的数组大小可以使用`(N+1)/2`，这去除了所有的偶数，保证长度肯定够

#### 计数质数

问题描述：给定整数N，返回小于非负整数N的质数的数量

解法：埃氏筛的常数时间比欧拉筛更好

## 快速幂、矩阵快速幂与两类问题

[code](./examples/77-matrix-fast-exponentiation.rs)

[code](./examples/77-fast-exponentiation-lg.rs)

矩阵快速幂可以用来解决两类问题

1. **固定关系**的一维k阶递推表达式，用矩阵快速幂解决的时间复杂度为`O(logN*k^3)`
2. **固定关系**的k维一阶递推表达式，用矩阵快速幂解决的时间复杂度为`O(logN*k^3)`

### 乘法快速幂模版

问题描述：求`a`的`b`次方，结果对`p`取模

解法：将`b`次方从十进制转成二进制，设置`x = a^1`，每次`x = x * x`，这样每次就会得到二进制位数的值，然后设置结果为1，每次如果指数的二进制位是1，就用结果乘对应的值，注意所有操作需要取模，乘法操作需要先提高操作数的位数

### 矩阵乘法和矩阵快速幂

固定关系的一维一阶递推关系表达式明显可以用乘法快速幂解决，例如`f(n) = 2f(n-1)`，可以看出`f(n) = 2^n*f(0)`的关系

矩阵乘法的前提是，前一个矩阵的列数和后一个矩阵的行数相等，结果矩阵的行数是前一个矩阵的行数，列数是后一个矩阵的列数，乘法规则是，前一个矩阵的第`i`行逐个元素乘后一个矩阵的第`j`列，将结果相加作为第`i`行第`j`列的结果

矩阵快速幂和乘法快速幂的求法是一样的，指数使用二进制表示，只是结果的最初值为单位矩阵（除了对角线以外所有元素均为1），且矩阵求幂次要求矩阵必须为正方形（行列数相等）

矩阵快速幂求解固定关系的一维k阶递推表达式过程为，根据初始元素和递推关系可以得到之后的元素，k组元素的数据可以通过之前组的数据（逆序）乘上一个关系矩阵得到，关系矩阵的求法，简单的第一列是递推关系的系数，后面的列可以通过数据来求解（k元一次方程组）

#### 求斐波那契数列第n项

问题描述：如题

解法：关系是`f(n) = f(n-1) + f(n-2)`，第1项是0，第2项是1，关系矩阵是`[[1,1],[1,0]]`，`f(1[1,0])*rel=f(2[2,1])`，套公式计算即可

#### 爬楼梯

问题描述：假设你正在爬楼梯，每次可以爬1或2个台阶，有多少种不同的方法可以爬到N层

解法：递推表达式为`f(n) = f(n-1) + f(n-2)`，和斐波那契数列是一样的，只不过初始矩阵为`[2, 1]`，因为只有1个台阶就是1种方法，两个台阶是2种方法

#### 第n个泰波那契数

问题描述：初始值`t(0) = 0, t(1) = 1, t(2) = 1`，递推表达式是`t(i) = t(i-1) + t(i-2) + t(i-3)`，求`t(n)`

解法：初始矩阵为`[1,1,0]`，根据`t[3]=2, t[4]=4`，得到关系矩阵为`[[1,1,0],[1,0,1],[1,0,0]]`

### 多米诺和托米诺平铺

问题描述：有两种形状的瓷砖，一种是2\*1的多米诺形（2块），一种是形如“L”的托米诺形（3块）。两种形状都可以旋转，给定整数N，返回可以平铺2\*N的面板的方法数量。结果要对`10^9+7`取模

解法：使用暴力解法（不优化的动态规划）来列出当N比较小时候的结果，然后通过观察结果得到递推表达式，最后求出关系矩阵`[[2,], [0,], [1,]]`，再根据矩阵快速幂求结果。注意矩阵乘法中应加上取模操作

定义基本问题为求在`N = i`时，左边是否存在单一块情况下有多少种方法铺满，分情况讨论如下

- 如果左边没有单一块
  - 使用横多米诺铺，然后下面必然还要放横多米诺，结果为`dp[i-2][0]`
  - 使用竖多米诺铺，结果为`dp[i-1][0]`
  - 使用上托米诺铺，结果为`dp[i-2][1]`
  - 使用下托米诺铺，结果为`dp[i-2][1]`
- 如果左边有单一块
  - 用一个多米诺填满，结果为`dp[i-1][1]`
  - 用一个托米诺填满，结果为`dp[i-1][0]`

基本情况是，如果`i = 0`有一种方法（不铺），如果`i = 1`有一种方法，如果`i = 2`有两种方法，根据数据规律可知，`f(n) = 2*f(n-1) + f(n-3)`

### 统计元音字母序列的数目

问题描述：给定一个整数N，统计我们可以按照下述规则形成多少个长度为N的字符串

1. 字符串中的每个字符都应是小写元音字母 'a' 'e' 'i' 'o' 'u'
2. 每个元音 'a' 后面只能跟着 'e'
3. 每个元音 'e' 后面只能跟着 'a' 或者 'i'
4. 每个元音 'i' 后面不能再跟着另一个 'i'
5. 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
6. 每个元音 'u' 后面只能跟着 'a'

最终的结果需要对`10^9+7`取模

解法：首先定义问题`dp[i][j]`表示在`i`长度字符串中以`j`字符（小写元音字母）做结尾总共有多少种字符串，那么根据题意可知，当`i = 1`时，结果是`dp[i]['a']+...+dp[i]['u']`，而对于`dp[i+1]`，可以得到下列结论

- `dp[i+1]['a']`，等于`dp[i]['e'] + dp[i]['i'] + dp[i]['u']`
- `dp[i+1]['e']`，等于`dp[i]['a'] + dp[i]['i']`
- `dp[i+1]['i']`，等于`dp[i]['e'] + dp[i]['o']`
- `dp[i+1]['o']`，等于`dp[i]['i']`
- `dp[i+1]['u']`，等于`dp[i]['i'] + dp[i]['o']`

根据上述结论可知，`dp[i+1]`的值可以完全由`dp[i]`的值推出来且关系固定，所以这是一个一阶k维的递推表达式，也可以使用矩阵快速幂来解，初始矩阵（`i = 1`）为`[1, 1, 1, 1, 1]`，而关系矩阵就是每个字符相对于前一阶的每个字符的表达式系数`[[0,1,0,0,0],[1,0,1,0,0],[1,1,0,1,1],[0,0,1,0,1],[1,0,0,0,0]]`

### 学生出勤记录II

问题描述：可以用字符串来表示一个学生的出勤记录，每个字符可以标记当天的出勤情况

- 'A' Absent表示缺勤
- 'L' Late表示迟到
- 'P' Present表示到场

如果学生能**同时**满足下面两个条件，则可以获得出勤奖励，按总出勤计，学生缺勤（严格）少于两天，学生不会连续3天或3天以上迟到。给定一个整数N表示出勤记录的长度，求可能获得出勤奖励的记录情况数量。结果需要对`10^9+7`取模

解法：定义问题为`dp[i][j][k]`表示在`i`天内，保持`j`次缺勤且默认连续`k`次迟到总共有多少种出勤记录，`j`的取值范围是`0,1`，`k`的取值范围为`0,1,2`，因为只有这样的记录才能保证获得出勤奖励，最终结果是将这些记录全部加起来。考虑`dp[i+1]`时的情况

- `dp[i+1][0][0]`，它的值为`dp[i][0][0] + dp[i][0][1] + dp[i][0][2]`
- `dp[i+1][0][1]`，它的值为`dp[i][0][0]`
- `dp[i+1][0][2]`，它的值为`dp[i][0][1]`
- `dp[i+1][1][0]`，它的值为`dp[i][0][0] + dp[i][0][1] + dp[i][0][2] + dp[i][1][0] + dp[i][1][1] + dp[i][1][2]`
- `dp[i+1][1][1]`，它的值为`dp[i][1][0]`
- `dp[i+1][1][2]`，它的值为`dp[i][1][1]`

由上述结论可以看出这也是一个一阶k维的递推表达式，只需要将后面两个参数压缩为一维即可，初始矩阵为`[1,1,0,1,0,0]`，关系矩阵为`[[1,1,0,1,0,0],[1,0,1,1,0,0],[1,0,0,1,0,0],[0,0,0,1,1,0],[0,0,0,1,0,1],[0,0,0,1,0,0]]`

## 逆元和除法同余、容斥原理

[code](./examples/78-congruence-modulo-inverse.rs)

[code](./examples/78-consecutive-inverse-lg.rs)

[code](./examples/78-inclusive-exclusive-lg.rs)

[code](./examples/78-buy-lg.rs)

### 除法同余

如果要计算`(a / b) % MOD`，需要满足三个条件才能使用除法的同余原理

- 必须保证a和b可以整除，每次出现除法都可以整除
- 必须保证`MOD`是质数，求逆元的原理是费马小定理，要求`MOD`为质数
- 必须保证b和`MOD`的最大公约数为1，即b和`MOD`互质

*题目给定的数据一定会满足以上三条*，所以可以直接用以下结论：先求`1/b`的乘法同余数，即逆元（倒数），求法为`b^(MOD-2)%MOD`，然后再计算`((a % MOD) * inv(b)) % MOD`。求逆元的过程可以使用乘法快速幂

求连续数字的逆元有线形递推公式，在模p的意义下，公式为：

- `inv[1] = 1`
- `inv[i] = (p - inv[p % i] * (p / i) % p)`

求连续阶乘的逆元的线性递推公式，在模p的意义下，先用乘法同余求`n!`，然后求它的逆元，公式为：

- `n! = b`
- `inv[i] = ((i+1) * inv[i+1]) % MOD`

因为逆元就是倒数的含义，所以更大的n的阶乘的倒数只要乘自己就可以得到更低的阶乘模p的值，注意使用乘法同余

#### 求组合数

组合数的计算公式为：

$$
C_{n}^m=\frac{n!}{m!(n - m)!}
$$

也就是说先求`n!`，然后再求`m!`和`(n-m)!`的逆元，再进行相乘即可

### 容斥原理

容斥原理的内容很简单，公式就是求多个有交集的集合的并集，即

$$\left|\bigcup_{i = 1}^{n}A_i\right|=\sum_{i = 1}^{n}\vert A_i\vert-\sum_{1\leq i<j\leq n}\vert A_i\cap A_j\vert+\sum_{1\leq i<j<k\leq n}\vert A_i\cap A_j\cap A_k\vert-\cdots+(- 1)^{n - 1}\vert A_1\cap A_2\cap\cdots\cap A_n\vert$$

容斥原理的相关题目的重点是如何设计出**快速查询若干集合交集数量**的问答系统，主要有两类题目

1. 打表查询，预处理结构
2. 不用查询直接公式化简

#### 最大公约数为1的子序列数量

问题描述：给定一个数组，返回有多少个子序列的最大公约数是1。结果需要对`10^9+7`取模

解法：决定一个子序列中的最大公约数是多少的是那个最小的数字，所以给定任意一个数字，只要包含它本身及比它更大的它的整倍数的子序列就是最大公约数为它的子序列，据此以每个数为最大公约数的子序列数量就是它以及它的整倍数的个数（记为x）`2^x-1`个，然后上面所有可能的子序列数量需要减去以它的整倍数为最大公约数的子序列的数量，就是最后的答案，从最大值求到1即可

扩展问题：返回有多少子序列的最大公约数为`k`

解法：将所有元素除`k`，留下能被整除的元素，然后求最大公约数为1的所有子序列数量即可

### 多次查询购买方法

问题描述：一共有4种硬币，面值为v0、v1、v2、v3，这是固定的，每次取购物的具体情况由一个数组表示，每次购物是一次查询，数组前4个元素表示带上述四种面值硬币的数量，第5个元素是本次购物一定要花多少钱，返回每次（查询）有多少种花钱的方法

解法：如果每次购物都进行一次动态规划计算，根据数据量（1000次查询，`10^5`的硬币数量）来看显然无法满足要求。所以可以先求一个完全背包问题`dp[i]`，表示在所有硬币不限数量的情况下必须花`i`钱数的可能性，先计算出来，然后对于每次查询，就是`s`钱数在不限硬币条件下的所有可能性减去所有硬币不满足给定数量会发生的可能性，就是该次要求的答案

对于任意一种面值的硬币，在固定钱数的情况下，它不满足标准的可能性是`dp[i-(k+1)*v]`，其中`k`是携带该面值硬币的数量，因为这个dp的值表示这个钱数下所有硬币不限数量的可能性，那么对于`i`钱数来说，用上所有的`v`硬币正好还差一个才能补足，这就一定不满足限制，然后剩下的所有可能性无论用不用`v`硬币都可以。然后题目每次查询需要利用容斥原理将所有硬币不满足限制的可能性加起来，用`0000`四位数字来表示4种硬币是否满足情况，这里可以看出只要`1`的数量是奇数就是加，如果是偶数就是减，所以引入位运算来计算

### 播放列表的数量

问题描述：给定三个参数`n`、`l`、`k`，表示音乐播放器中有`n`首不同的歌，你的旅伴想听`l`首歌，允许歌曲重复，需要按照下面两个要求创建一个歌单，1）每首歌至少播放1次，2）一首歌只有在其它`k`首歌播放完之后才能再次播放。求可以满足要求的播放列表的数量。结果需要对`10^9+7`取模，`k < n < l`

解法：根据第一个条件无法得到有关播放列表数量的关系，所以先考虑第二个条件，即`f(n,l,k)`表示在不要求歌曲如何出现的情况下可以创建的歌单数量，首先选择`k+1`首歌放在开头，之后的每首歌`l-k-1`的可能性都是`n-k`，所以得到公式`A[n,k+1]*(n-k)^(l-k-1)`，展开排列表达式后为`n!*(n-k)^(l-k)/(n-k)!`，然后利用容斥原理，将缺少一首歌、缺少两首歌...的情况算出来并累加，最后用所有情况减去这些情况就是要求的内容。得到公式`accu[i](0,n-k)*(-1)^i*f(n-i,l,k)`，带入之前的公式就得到了`n!*(n-i-k)^(l-k)/(i!*(n-i-k)!)`，因为当`i = 0`时就是所有的可能性，所以直接求公式的结果即可，阶乘需要提前求出，阶乘的逆元也需要提前求出

⚠️这道题关键在于先选`k+1`首歌而不能先选`k`首歌，不然公式到后面无法消元，因为是先听的答案再做的题，很容易先入为主，如果无法直接看出，碰到类似的题还是应该两种情况都尝试

## KMP算法原理和代码详解

[code](./examples/79-kmp.rs)

KMP算法解决的问题是字符串匹配，即查找`s2`在`s1`中出现最早的位置，如果没有找到则返回-1。如果使用暴力方法实现，那么要从`s1`的所有位置尝试匹配`s2`，所以时间复杂度为`O(N*M)`。而KMP算法的时间复杂度可以做到`O(N+M)`。暴力方法的问题在于之前做的所有匹配操作对后面的操作没有影响，而KMP算法对此做了改进

### 理解`next`数组的定义

首先定义一个`next`数组，这个数组和`s2`字符串（查找的字符串）相关，它的元素的含义是**它之前的所有元素，不包含整个字符串，前缀和后缀的最大匹配长度**。首先不包含`i`位置本身的元素，其次这个长度不能是`i`位置之前的所有元素构成的字符串，因为如果算的话`next`数组就没有意义了。特殊的，`next[0] = -1, next[1] = 0`

### 假设已经有了`next`数组，详解匹配过程是如何加速的

首先从两个字符串的`0`位置匹配，假设碰到第一个不相同的字符，记为位置`k`，此时`next[k]`所指向的元素就是`s2`要开始继续匹配的位置，然后如果两个字符相同，继续往下匹配，如果两个字符不同，则更新匹配位置到`next[next[k]]`，直到这个位置为-1，那么要移动`s1`的匹配位置加1

#### 理解核心1：为什么当字符不匹配之后就能直接从`next[k]`位置直接开始匹配

因为`next[k]`的含义是`k`位置之前最长的前后缀匹配长度，因此从`next[k]`这个位置开始匹配，它之前的元素就是最大长度的前缀，这个前缀对于之前已经和`s1`匹配的后缀是一样的，所以挪过来无需再判断之前是否完全匹配

#### 理解核心2：为什么`s1`中从`0`到`k-i`范围中不可能有正确答案

这里使用反证法来证明，假设`next[k] = 7(i = 7)`，表示之前的元素的最长前后缀匹配长度为7，如果在`[0..k-7]`范围内存在答案的话，假设为`p`，那么`[p..k]`这个范围就会等于`s2`的前`k-p`个元素，显然这个长度会大于7，也就是`next[k] = 7`计算错了，而我们的前提是`next`为正确数组，所以推论矛盾，不成立

### `next`数组如何快速生成

对于`next`数组后续元素的生成，它和之前元素也是有关系的。维护一个自增值`incr = 0`，在任意`i`位置，如果`i-1`的字符和`incr`位置的的字符一样，那么`next[i] = incr + 1, incr += 1, i += 1`，因为求解是从左（第2个值）往右的，所以可以累加更长的最长前后缀匹配长度，如果不一样，为了尽量保留之前已匹配过的最长长度，就将`incr = next[i-1]`，直到`incr <= 0`，这个值的含义总是已匹配到的最长前后缀的长度和前缀之后的位置

### 时间复杂度的证明

对于`next`数组快速生成的证明和匹配过程的证明原理是一样的，首先定义两个变量`i`和`i-m`，因为`m`有可能会减少，所以使用减法来转换它的变化趋势，通过代码结构可以看出，所有的条件分支都会让这两个变量的值增加或者不变，它们相加就是小于`2i`的时间，所以时间复杂度都是`O(N)`，相加结果就是`O(N+M)`

### 另一棵树的子树

问题描述：给定两颗二叉树，检验前一棵树是否包含和后一棵树相同结构和节点值的子树，如果存在返回true，不存在返回false

解法：直接递归判断可以过题，但是时间复杂度为`O(M*N)`，每个节点比较一次

## KMP算法相关题目

[code](./examples/80-kmp-practice.rs)

[code](./examples/80-minimum-cycle-lg.rs)

[code](./examples/80-remove-str-lg.rs)

### 最短循环节的长度

问题描述：给定一个字符串，它一定是由某个循环节不断自我连接形成的，题目保证至少重复2次，但是字符串的最后一个循环节不一定完整，现在需要求该字符串的最短循环节

解法：求解该字符串的`next`数组，并且需要求到最后一个字符之后一个位置的值，然后`str.len() - next[n]`就是结果。通过举例和反证法的方式可以判断`next[n]`的值不可能更大，一旦这个值变大，事实上的最短循环节就会变成原先假定的循环节和值超出的部分的最大公约数

### 不停删除之后剩下的字符串

问题描述：给定一个字符串`s1`，如果其中包含`s2`字符串，就删除最左出现的那个，然后将剩余字符串拼接到一起，继续判断和删除，最后返回剩余的字符串

解法：使用一个栈结构来记忆`s1`和`s2`的`next`数组匹配到的索引位置。先求出`s2`的`next`数组，然后开始遍历字符串，如果相同，那么记录两个索引插入栈中，如果不同，`s2`需要向前跳转直到为`0`，并且记录`-1`索引，每次遍历完成需要查看是否已经将`s2`匹配完，如果匹配完就从栈中弹出`s2.len()`大小的元素，如果此时栈中还有元素，就从`next[stack.pop()+1]`位置继续匹配，否则就从`0`开始匹配，当`s1`遍历完成将栈中剩余字符返回即可

### 二叉树中的链表

问题描述：给定一棵树和一个链表，判断二叉树中是否有一条一直向下的路径正好所有数值等于链表的值

解法：首先对链表做一个`next`数组，然后开始以dfs的方式开始进行字符匹配，在递归调用的过程中需要带着当前正在匹配的`next`数组的位置，如果匹配到了就返回`true`，否则如果树没有节点就返回`false`，然后用当前节点的值来更新`next`数组的位置，之后递归调用子树节点即可。根据KMP算法的时间复杂度分析，节点跳转的时间复杂度可以分摊为`O(1)`，所以整个时间复杂度为`O(N+M)`，其中N是树上的节点数量

### 找到所有好字符串

问题描述：给定两个长度为N的字符串s1和s2，以及一个字符串evil，好字符串的定义是长度为N，字典序大于等于s1并且小于等于s2，且不包含evil字符串的字符串。求好字符串的数量

解法：假设没有不包含evil字符串的条件，求有多少字符串字典序小于等于另一个字符串可以使用数位dp的方法，再加上这个条件后就是在选择各个位置的字符时，判断是否匹配到了evil字符串，所以定义基本问题`dp[i][j][k]`表示在第`i`位上当前匹配的`next`数组上的`j`位并且本位是否能自由选择的条件下有多少小于等于指定字符串字典序的字符串。最后在计算的时候注意s1字符串要单独用KMP算法判断是否存在evil字符串，如果不包含则要加上。时间复杂度为`O(N*M*2*26)`，因为`next`数组内部的位置跳转操作均摊为`O(1)`

## AC自动机原理、优化、代码详解

[code](./examples/81-acauto-tmpl-lg.rs)

[code](./examples/81-acauto-count-lg.rs)

自动机又叫确定有限状态自动机，是对**信号序列**进行判定的**数学模型**。信号序列可以认为是字符串，比如判定s1是否包含s2，判定s是否为回文等等

自动机不是某种具体的算法、数据结构，只是一种数学模型，属于概念上的内容，不同的自动机的实现方式可能有多种

常见的自动机包括

- [前缀树](#前缀树原理和代码详解)
- KMP自动机，KMP算法实现
- 回文自动机，Manacher算法实现
- 后缀自动机（SAM），理解后缀数组的用法
- AC自动机

AC自动机的功能是，给定若干目标字符串，还有一篇文章，返回每个目标字符串在文章中出现了几次

AC自动机的实现就是前缀树加上了`fail`指针，这是经典AC自动机的结构

`fail`指针的含义是

- AC自动机（前缀树）上的某个节点a，表示某个**目标串**的前缀串s的终止节点
- 所有目标字符串的前缀串，要求和s的某个后缀串完全一致，并且要求长度最大，不能是s的整体（这里就体现了`fail`指针总是保存前一个字符串的非完整后缀如果是另一个目标字符串的前缀，那么是有可能继续匹配的）。满足这个条件的前缀串假设为t，那么节点a的fail指针就指向t的终止节点

`fail`指针的意义在于保留所有匹配成功的可能性。思想来自KMP算法。一旦匹配失败，就通过`fail`指针绕圈找到能继续的节点继续匹配

建立AC自动机的过程和应用的过程如下

1. 根据若干目标字符串构建好前缀树，使用一个二维数组，初始位置为0节点，列是不同的字符
2. 建立`fail`指针数组，计算`fail`指针的过程是BFS，根节点（0）和第一层的所有节点的`fail`指针都是0，`fail`指针是父节点为子节点设置的。规则是，找到一个子节点，判断到子节点边上的字符是什么，然后找到自己的`fail`节点，判断是否有一条边是同样的字符，如果没有继续向上找，直到为0，最终没有找到就设为0，如果找到，那么设置子节点的`fail`指针为该节点
3. 当有一篇文章输入后，从0节点开始寻找，如果有边则在边指向的节点以及它所有的`fail`指针上加1，如果没有则跳到`fail`指针的节点继续寻找，直到节点为0。0节点不需要统计词频。最后只要查看所有目标字符串的结束节点的词频数即可。在匹配的时候先找到目标点，再累计词频（倒推`fail`指针）

对于经典自动机中会出现的`fail`指针绕圈的现象，有对应的优化方法

1. 建议AC自动机时设置`fail`指针会绕圈，遍历文章时，匹配失败去寻找支路也会绕圈。优化方式是在设置每个节点的`fail`指针时，将所有可能字符都试一遍，如果不存在就找该节点的父节点的`fail`指针是否有指向的这些字符的边，找到后直接在前缀树数组中设置好对应的节点，之后设置`fail`指针时就不会绕圈，而是直接能找到
2. 遍历文章时，不知道是否命中了某个目标字符串，需要`fail`指针绕圈累计词频。优化方式是仅在节点上累计词频，结束遍历之后将`fail`指针数组建一棵反树，然后统计目标字符串终止节点上的词频即可
3. 在遍历文章时，不知道是否匹配到了某个字符串，需要`fail`指针绕圈查找。优化方式是单独维护一个`alert`数组来保存节点的报警状态，插入目标字符串的时候，每个字符串末尾节点的`alert`值都是`true`，设置`fail`指针的时候，将每个节点的`alert`状态设置成跟它的`fail`指针的`alert`值相同，这叫做命中标记前置

AC自动机的时间复杂度（优化后）是`O(所有的目标字符串长度) + O(匹配的文章长度)`

### AC自动机模版(优化版)

问题描述：给定若干目标字符串，还有一篇文章，求每个目标字符串在文章中出现了几次

解法：见AC自动机原理。链式前向星建图

⚠️Rust中的`Vec`不能直接当队列用，`pop`方法弹出的是末尾元素

### 数数(利用AC自动机检查命中)

问题描述：我们称一个正整数`x`为幸运数字的条件为：`x`的十进制表示不包含数字串集合`s`中任意一个元素作为子串，给定`n`和`s`，计算不大于`n`的幸运数字的个数。结果要对`10^9+7`取模

解法：对于不大于`n`的幸运数字遍历，可以使用数位dp的做法，注意这里的数字不能为0，且不存在前导0，但是不能匹配到的数字字符串中可能有前导0。首先对所有要判断的数字字符串构造AC自动机，需要创建一个`alert`数组，它的含义是当AC自动机到达某些节点，如果`alert[i] == true`就认为已经匹配到了某个字符串。然后定义基本问题`dp[i][j][free][has]`为在第`i`位上，AC自动机已经移动到了`j`位，并且本位是否可以自由选择且前一位是否选择了数字的情况下，还可以得到多少幸运数字，分情况讨论如下

- 如果之前没选数字
  - 不能自由选数字：第一位，可以继续不选，可以选小于当前位（大于0）之后自由选，可以选当前位之后不能自由选
  - 能自由选数字：更小的位数，可以继续不选，可以自由选数字（大于0），之后依然可以自由选
- 如果之前选了数字
  - 不能自由选数字：选小于当前位之后自由选，选当前位之后不能自由选
  - 能自由选数字：可以自由选数字，之后也能自由选

基本情况是如果`alert[j] == true`，然后判断如果已经到了最后一位，那么如果之前没有选择数字返回0，否则返回1

## Manacher算法、扩展KMP

[code](./examples/82-manacher-z.rs)

[code](./examples/82-manacher-tmpl-lg.rs)

[code](./examples/82-z-algorithm-tmpl-lg.rs)

### Manacher算法

Manacher算法求字符串中的最长回文子串长度只是最微小的用法。理解其中的回文半径数组更加重要

理解Manacher算法的步骤

#### 暴力查找字符串中的最长回文子串

遍历每个字符，从左右开始扩展，如果相同就继续扩展，否则记录结果处理下个字符。问题是对于偶数长度的回文来说，这种方法会错过

#### Manacher扩展串

Manacher扩展串是在原字符串的基础上使用一个其它字符，放到头尾两侧，然后在任意两个原相邻字符中间插入一个所构成的新字符串。在这个字符串上应用暴力方法可以找到奇、偶长度的回文子串。并且这个扩展字符没有限制，可以是原字符串中的字符，因为它本身只能匹配自己而不影响原始串

#### 回文半径和真实回文的长度对应

引入一个概念叫做回文半径数组`p`，在任意位置的`p[i]`表示该位置下能找到的最长回文在某一方向上的长度，对应到它的原始串中的这个位置的回文长度就是`p[i] - 1`

例如“cbaabc”，Manacher扩展串使用#字符“#c#b#a#a#b#c#”，`p[6] = 7`，所以原位置的回文长度就是6

#### 扩展回文串结尾下标和原始串的终止位置的对应

扩展回文串结尾下标为`i+p[i]-1`，对应原始串的结尾位置就是`(i+p[i]-1)/2 = 6`，注意这里是结尾位置，知道长度和结尾位置，起始位置就是`end - len`

#### 回文半径数组、回文覆盖最右边界、回文中心

- 回文半径数组就是上面的`p`
- 回文覆盖最右边界`r`，表示在任意位置向右扩展的回文长度的边界（不包含）
- 回文中心`c`，当`r`被扩大时，回文中心要使用当前遍历的位置更新，即总是目前找到的最长回文的中心

#### Manacher算法的加速过程

根据`i`、`p`、`r`、`c`这几个变量的关系，在如下情况下可以加速寻找过程

- 如果`r <= i`，此时无加速过程，要从`i`位置开始左右扩展长度，并更新`r`和`c`
- 如果`i`位置相对于`c`左边的对称点`i'`的回文长度被`r`包围，那么这个点的回文长度和`i'`相同，`p[i']`
- 如果`i`位置相对于`c`左边的对称点`i'`的回文长度超过了`r`，那么这个点的回文长度就是到`r`的距离，`r-i`
- 如果`i`位置相对于`c`左边的对称点`i'`的回文长度等于`r`，那么这个点要继续扩展，并且更新`r`和`c`

对于后三点的证明很简单，在`c`为中心，`r`为半径的回文子串中，任取点`i`，它的对称点就是`2*c-i`，这个点的回文半径如果小于`r`，则进入2情况，如果大于`r`，进入4情况，等于`r`进入3情况，通过设`i'`左右子串为`x`和`y`，就能推出各种情况的结论，这里不再赘述

#### 其它

Manacher算法的时间复杂度为`O(N)`，因为变量`r`在所有情况下都是单调递增（或不变），所以在遍历一次字符串之后就可以得到`p`数组结果

具体的代码实现中不需要判断所有四种情况，见代码

### 扩展KMP

又称Z算法（Z Algorithm）、Z函数

扩展KMP中有两个关键的结构

- z数组：一个字符串生成的z数组的含义是，`z[i]`表示从字符串`i`位置之后和从字符串前缀能匹配的最长长度
- e数组：对于两个字符串，`e[i]`表示a字符串的`i`位置开始能匹配到b字符串前缀的最长长度

#### z数组的求法

和Manacher算法相同，`z[0]`总是等于字符串长度，无意义，当`i > 0`时，它的关键点是`i-c`，`c`和`r`对应Manacher算法中的关键点和回文半径右边界，对于每个`i`位置同样有4种情况，处理方式也和Manacher算法相同

#### e数组的求法

对于a和b字符串，首先要求b字符串的z数组，然后求a字符串的e数组，关键点也是`i-c`，但是值是b字符串的z数组的值。需要注意的是e数组要从`0`位置开始求，因为不能直接确定a字符串和b字符串的前缀重合长度是多少，所以开始必须要先求出来

#### 将单词恢复初始状态所需的最短时间II

问题描述：给定一个下标从0开始的字符串和一个整数`k`，每一秒必须执行以下操作：1）移除字符串的前`k`个字符，2）在字符串的末尾添加`k`个任意字符，添加的字符不必和移除的字符相同。求将字符串恢复到初始状态所需的最短时间，该时间必须大于0

解法：只要对这个字符串求一个z数组，然后按照k的整数倍（大于1）开始判断`z[idx] == n-idx`，如果成立，那么那一秒就可以完成字符串的复原，如果无法复原，说明任意位置的字符都得不到和前缀相同的子串，所以答案是`n/k`向上取整，即重新创建一次这个字符串

## Manacher算法相关题目

[code](./examples/83-manacher-practice.rs)

[code](./examples/83-k-odd-palindrome-multi-lg.rs)

[code](./examples/83-longest-dual-palindrome-lg.rs)

### 最长回文子串

问题描述：求字符串的最长回文子串并返回

解法：Manacher算法的直接应用，求出回文半径数组之后注意记录起始索引即可

### 回文子串数量

问题描述：求字符串的回文子串数量

解法：在求解回文半径数组时，对于扩展字符（例如`#`），那么它生成的子串数量就是回文长度除2，即`(len-1)/2`，对于非扩展字符，它生成的子串数量要带上自身字符，即`len/2`

### 不重叠回文子串的最多数目

问题描述：给定一个字符串和一个正数`k`，可以随意把字符串分成多个子串，目的要找到某种切分方案，有尽可能多的回文子串，并且每个回文子串要求长度至少为`k`，且彼此不重合。求最多能划分出几个这样的回文子串

解法：题目要将所有长度大于等于`k`的回文子串找出来，那么可以在从左往右求解回文半径数组的过程中，只要找到一个长度为`k`的回文串，就进入下一个起始点开始重新计算回文半径数组，并返回下一次开始计算的起始点，这个起始点的位置是`i+len-1`，注意这个起始点必须是扩展字符的位置而不能是普通字符，因为普通字符可能会被重复计算，所以如果是普通字符需要返回再往后的一个位置

### 长度前k名的奇数长度回文子串长度乘积

问题描述：给定一个字符串和一个数`k`，只关心所有奇数长度的回文子串，返回其中长度前`k`名的回文子串的长度乘积是多少，如果奇数长度的回文子串个数不够`k`个，返回-1。结果需要对`19930726`取模

解法：对所有奇数长度的回文做一个词频表，然后从最大的词频不为0的奇数长度开始计算，每次计算小于等于`k`个长度，计算完之后将其个数累计到下一个奇数，在计算同一个长度的乘积时可以使用乘法快速幂

### 最长双回文串长度

问题描述：给定字符串，求它的最长双回文子串的长度。双回文子串就是可以分成两个回文串的字符串

解法：首先求出字符串的回文半径数组，如果对于每个扩展字符的点，能求出它左边和右边的最长回文子串，那么只要统计所有这些扩展字符位置的左右回文子串长度，求最大值即可。对于每个扩展字符，定义`left[i]`表示以`i`位置为终点扩展字符，它左边的最长回文子串长度，那么当求任意`i`位置的值时，要看它是被哪个前面哪个点覆盖到的，假设是`j`，则当`j + p[j] > i`时，`left[i] = i-j`，即当前要求的`left[i]`在`i`位置一定处于某个回文串中，且扩展字符中一半长度正好是原字符串中的回文长度，同理`right[i]`是从右往左求

## 字符串哈希原理、代码、题目详解

[code](./examples/84-string-hash-practice.rs)

[code](./examples/84-diff-string-lg.rs)

[code](./examples/84-match-substr-lg.rs)

哈希函数就是把复杂样本变成数字，之后对复杂样本之间的比对被转化为数字之间的比对

哈希函数有以下基本性质

1. 输入参数的可能性是无限的，但是输出的值范围是相对有限的
2. 输入同样的样本一定得到相同的输出，即哈希函数没有随机性
3. 输入不同的样本也可能得到相同的输出，这种现象叫做哈希碰撞
4. 输入大量不同的样本，得到大量的输出值，会几乎均匀地分布在整个输出域上

对于性质4，可以理解为无论输入的值之间有多么相似，它们的输出值都会均匀分布在输出域中，与原始输入值没有关系，这样熵最大。理论上哈希碰撞无法避免，但是好的哈希函数设计可以让碰撞的几率变得很低

### 字符串哈希

字符串哈希解决的问题是如何计算得到字符串的哈希值

1. long类型的自然溢出，在计算long类型（无论表达有无符号数）的加减乘时，自然溢出后的结果正好是对`2^64`取模之后的数值状态
2. 要将字符串转换为一个base进制的自然溢出后的long类型数字
3. base可以选择一些质数：433、499、599、1e9+7等，还有一些被证实好用的数字：31、131、1313、13131、131313等（建议选择质数而不是这些验证的经典值，因为会被出题人可以构造碰撞）
4. 转化时要让每一位从1开始，不从0开始，这样就得到了一个long类型的数字代表的字符串，如果从0开始会导致`a`和`aaa`的数字一样都是0
5. 利用数字的比较去替代字符串的比较可以大大减少复杂度

> 如果字符串哈希出现了碰撞，只需要替换质数再尝试即可

得到字符串中任意子串的哈希值

1. 选择一个质数作为进制数base
2. 首先计算base的各种次方的自然溢出数（long类型），长度为字符串长度
3. 然后计算每个位置`0~i`的哈希值
4. 在计算每个子串哈希的时候就有公式`hash[sub[i..=j]] = hash[j] - hash[i-1]*base^(j-i+1)`

> 字符串中子串对比变成哈希值对比非常好用，大量节省时间
>
> 很多较难算法都可以被字符串哈希替代，因为子串对比的代价变为`O(1)`。例如KMP算法和Manacher算法，对于Manacher算法，在求回文半径数组的时候，只要在任意位置左右两边使用字符串哈希来对比找到最大半径即可，具体的长度使用二分查找，所以时间复杂度为`O(N*logN)
>
> 字符串哈希易于理解且使用灵活，因为非常方便的子串对比让很多难题变得好想

### 统计有多少个不同的字符串

问题描述：给定字符串列表，求共有多少个不同的字符串

解法：计算每个字符串的哈希值，然后放到词频表中，最后将词频表排序后，遍历词频表判断前后两个哈希值是否相同，统计起来即可得到答案

### 独特子串的数量

问题描述：给定一个由数字组成的字符串，求其中独特子串的数量，独特子串中每个数字出现的频率都相同，且独特子串不能重复算

解法：首先大的流程是需要将所有子串遍历一遍，即`O(N^2)`复杂度，然后对于每个字符开头的所有子串，首先判断它是否为独特子串，如果是，则计算它的哈希值放到一个哈希表中（哈希表中存储数字的对比速度远比字符串对比快，尽管时间复杂度都是`O(1)`，见后续课程中哈希表的原理讲解）。判断是否为独特子串，需要几个指标，包括当前子串出现的字符的词频，最大词频，最大词频的字符种类，所有字符种类，当任意子串中最大词频的字符种类和所有字符种类相同，那么表示它是一个独特子串，统计即可。要注意当最大词频被更新时，最大词频的字符种类就变成了1

### 字符串哈希得到子串哈希

问题描述：查找字符串2在字符串1中出现的第一个位置

解法：提前准备好子串的哈希值和base的幂的溢出值，然后计算字符串2的哈希值，对比字符串1中所有的子串即可

### 重复叠加字符串匹配

问题描述：给定两个字符串a和b，寻找重复叠加字符串a的最小次数，使字符串b成为叠加后的字符串a的子串，如果不存在返回-1，叠加0次后变成空串

解法：如果a重复k次后会包含b，那么至少重复后的长度要大于等于b的长度，且这种情况下b可能会以a的某个前缀结尾，因此a需要重复k+1次保证如果包含b，那么这个重复后的结果一定就是答案。首先重复次数就是`b.len()/a.len()`向上取整再加1，生成a的重复后的结果串，然后计算b的哈希值，开始找a中是否有子串的哈希值等于b的哈希值，找到后判断子串结尾是否在第k+1次重复串中，如果在就返回k+1，如果不在就返回k，如果始终不存在则返回-1

### 串联所有单词的子串

问题描述：给定一个字符串和一个字符串数组。数组中所有的字符串长度相同。字符串中的串联子串是指一个包含字符串数组中所有字符串以任意顺序排列连接起来的子串，求所有串联子串在字符串中的开始索引，可以以任意顺序返回答案

解法：首先将字符串数组中所有字符串计算它们的哈希值，得到一个哈希数组，然后将字符串按照索引分组，起始从0开始，设字符串数组中字符串长度为`x`，那么从`0~x-1`这些起始索引就是所有可能的分组起始点，每`x`个字符计算一个哈希值，窗口中需要维护字符串数组长度个哈希值，首先填满窗口，判断是否满足哈希值都相等，如果相等就得到一个，然后开始滑动窗口遍历。时间复杂度为`O(N) + O(M)`，因为遍历过程没有反复，而哈希比对的时间复杂度为`O(1)`

### 根据匹配定义求匹配子串的数量

问题描述：给定长度为N的字符串s和长度为M的字符串p，还有一个正数`k`，定义s'和s匹配为：s'和s的长度相同，且最多有`k`个位置字符不同，求字符串s中有多少子串和字符串p匹配

解法：求s和p的子串哈希，然后从s遍历p长度的子串，对于任意两个子串，使用二分查找第一个不同的位置，如果找不到说明字符串完全相等，得到结果，如果找到了，那么跨越这个长度找下一段子串中第一个不同的位置，只要找到超过k个就结束匹配

## 哈希函数、哈希表、布隆过滤器、一致性哈希

[code](./examples/85-hash.rs)

哈希函数的性质见上一章的内容，这里介绍根据哈希函数的均匀性可以发挥的扩展作用，即将样本进行均匀分组

工程上常用的哈希函数：SHA-1、SHA-2、SHA-3、MD2、MD5

对于这些工程上常用的哈希函数，它们可以实现对于相似的输出得到在整个输出域上足够“平均”的输出，见代码中简单的实验，由a和b两个字母构成的1e6个长度为20短字符串的哈希值对10求模后基本可以达到每个结果的字符串数量相同或只有很少的差别

### 哈希函数相关问题

问题描述：一台机器上硬盘空间很大，但是内存只有4G。现在有100亿个字符串的文件，每行都是一个100字节的字符串，需要统计哪个字符串出现的次数最多

解法：如果直接用哈希表来统计，那么如果所有字符串都不相同，全部存下大概需要1T的内存。对于哈希表中的一条数据，可以认为是`(String, u64)`，大概108字节，大概计算后得到所有内存可以存储3000万条记录，假设内存还需要供给其它进程使用，最多只能存储1000万条记录，那么只要保证每次统计最多1000万种字符即可，根据哈希函数的特性，首先将所有的字符串计算哈希值，然后用结果模1000，生成1000个小文件，里面每个文件中字符串的**种类**都不会超过1000万，因为对于不同的字符，哈希值分布足够均匀，即如果所有字符串都不同，这样分完每个文件最多也就是1000万种字符串，这样每次统计一个小文件中出现次数最多的字符串，最后再计算其中出现次数最多的字符串即可

很多工程问题都是利用哈希函数把大数据量样本均匀分散到多台机器上或多个小文件里再处理，哈希函数可以保证相同样本一定会放在一起，还能保证把不同种类的样本均匀分开

### 哈希表原理

哈希表就是对于键值对或者不重复键的增删改查操作的时间复杂度为`O(k)`的数据结构，它的实现原理就是对于存储键先求一个哈希值，然后根据准备的初始桶的数量分散到不同的桶中，桶是一个连续存储结构（例如数组），当桶内的元素足够多的时候，就扩大桶，然后将现有的元素重新计算哈希值再次分散到新桶中，`k`是样本的平均长度，如果键的类型是字符串，那么在查找时比较字符串就和它的长度有关，如果是数字类型，那么时间复杂度就可以在`O(1)`。在扩容的过程中，假设是每次扩容2倍，且每个桶的阈值是6，初始10个桶，那么60时扩容需要`O(60)`（计算哈希值认为是`O(1)`），第二次是120、第三次是240，此时已经可以插入480个元素，因此之前扩容的时间不会超过`O(3*N)`，考虑到当前插入到元素是`N`，所以均摊时间复杂度依旧是`O(1)`

哈希表的实现中可以定制的部分

- 初始桶空间，开始准备多少桶？准备的多可以减少扩容次数
- 扩容阈值条件，链表长度多少时扩容？
- 扩容因子，一次增长多少桶空间？
- 哈希函数选择，简答哈希函数还是复杂哈希函数？简单哈希函数计算时间更快，复杂哈希函数结果分布更均匀
- 桶结构的具体实现，链表还是开放地址还是红黑树？不同的结构在不影响时间复杂度的情况下可以存储更多的元素，减少扩容次数

不同定制优化的只是哈希表的常数时间，哈希表的原理是不变的，时间复杂度无法再优化

### 布隆过滤器

设计一个黑名单系统（爬虫去重系统），假设有100亿个url需要进入黑名单，表示这些url不能被访问（或者不需要重复爬取内容），每个url有100字节。建立好整个系统后，可以判断任何一个url在不在黑名单系统内，**预期失误率**为万分之一，内存占用不超过30GB

布隆过滤器的原理：准备一个位图结构，即一个位数组（数组的每个元素仅表示一位），假设长度为`m`，对于每一个样本（url）求多个哈希值，假设准备了`k`个哈希函数，得到不同的值模`m`后得到不同的数组中的位置，将这些位置置为1，表示占位。这样判断时也只要计算出某个url的所有哈希函数的值去位图中做对比即可。根据哈希函数的特性，失误指的是一个不存在黑名单中的url有可能会被误报，而存在于黑名单中的url不会被误报，在现实中，只要预期失误率可以接受，布隆过滤器由于其占用内存少的特点就可以被使用

假设数据量为`n`，实际上每条数据（样本）自身长度是没有意义的，因为都会被计算成固定长度的哈希值。预期失误率为`p`

1. 根据`n`和`p`，可以算出布隆过滤器需要多少个位，即位数组的大小，向上取整为`m`。当样本量固定，`m`的值越小，`p`就越高，即更可能出现失误，当`m`的值越大，`p`就会越小，所以样本量固定，根据`p`的值可以求出`n`
2. 根据`m`和`n`，可以算出应该选择多少个哈希函数`k`。当样本量固定，位图长度固定，`p`和`k`的关系是开始`k`很小，`p`会比较高，因为此时判断的依据更少，更容易误判，随着`k`增加`p`会减少，达到一个最低点后，再多的哈希函数会让位图更快被填满，反而会增加`p`，所以要求`p`最低点时的`k`
3. 当实现好布隆过滤器后，如果给出的资源更多，可以根据具体的`m`来计算出真实的`k`

三个公式如下所示：

$$
m=-\frac{(n \ln p)}{(\ln 2)^2}
$$

$$
k=\ln 2*\frac{m}{n}=0.7*\frac{m}{n}
$$

$$
p'=(1-e^{-\frac{nk}{m}})^k
$$

### 一致性哈希

介绍一致性哈希之前先引入一种简单的分布式存储结构：假设有机器1、2、3，每个数据的键计算哈希值后模3放入不同的机器，根据哈希函数的均匀性可以得到数据的分布结果会比较均匀。这里引入一个**注意点**，选择哈希键的关键在于区分度要足够高，才能让不同的数据均匀分布到不同的机器中，比如使用身份证号就比使用性别更合适

上述存储结构的主要问题在于，当机器节点增加或减少时，所有已有数据都要重新计算哈希并迁移到新的对应机器，代价非常大。一致性哈希实现的分布式存储结构可以解决这个问题

一致性哈希的原理是，对于数据直接计算键的哈希值备用，对于每个机器的独有信息同样计算哈希值，认为哈希函数的输出域是一个数环，那么每个机器的哈希值就会在环中有一个点，数据的哈希值决定它应该归属到哪一台机器，假设将其归属到顺时针离他最近的机器节点，这样的话如果机器的哈希值可以平分环的话，可以实现一个负载均衡的情况，且在增加机器和减少机器节点后，要进行数据迁移的代价不再是全部而只是受其影响的一部分数据

上面这种直接的方式有两个重要的问题

1. 如果每台机器的哈希值是邻近的，那么会导致数据集中在某几台机器而一些机器几乎没有负载，叫做数据倾斜
2. 无法实现负载均衡，因为初始的哈希值就决定了这台机器能处理的数据范围

要解决上面的两个问题，可以利用哈希函数的均匀性，预先给每个机器节点分配数量相同的一些不同字符串（计算哈希值），让这些哈希值作为这台机器在环中的位置，那么所有机器在环中所占的位置就能各自分到均匀的负载量，这样就解决了数据倾斜问题。然后在新增和减少机器的情况下，首先确定新增和减少的哈希值，之后做数据迁移，和之前的步骤相同，并且通过指定每个机器不同数量的预先计算出的哈希值，可以让它们的负载区别开，实现负载均衡的效果

## 大厂面试中经常漫聊的有趣算法问题

[code](./examples/86-tricky.rs)

### 蓄水池采样

问题描述：假设有一个不停吐球的机器，每次吐出`i`号球，有一个袋子可以装下`k`个球，每次机器吐出球，可以选择放入袋子或者永远扔掉。如果做到机器吐出每一个球后，所有吐出的球可以等概率地放入袋子中

扩展问题：如何设计一个抽奖系统，一天内所有登陆的用户都有均等的中奖机会，一共100人中奖

解法：策略设计如下

- 对于前`k`个球，直接放入袋中
- 从第`k+1`个球，首先以`k/i`的几率选择留下还是丢弃，如果留下，对于袋中的球进行等概率地丢弃

基本证明，对于初始在袋中的球，在第`k+1`个球进来之后，被丢弃的概率就是`(k+1/i)*1/k`，那么留下的概率就是`1-(k+1/i)*1/k`，计算多次后结果会化简为`k/i`，因此它最终会等概率地留在袋中，对于非初始处于袋中的球的计算结果也是一样的

扩展问题和原始问题基本等效，只要维持一个初始奖池人选，后续所有的新用户根据上述策略决定是否进入奖池，这样可以省略大量的空间维护全量的参与抽奖人信息

### 内存限制类问题

原始问题：32位无符号整数的范围是0～4294967295，现在有一个正好包含40亿个无符号整数的文件（比32位无符号整数小一些），可以使用最多1GB内存，怎么找到次数最多的数

解法：参考上一节内容，使用哈希函数分组成小文件即可

#### 内存只有1GB，找出所有没出现过的数字

在内存中建立一个位图，要保存所有32位无符号整数之需要0.5GB内存，在遍历完所有数字后将位图中为`0`的位的对应数找出来即可

#### 内存只有1GB，找出所有出现了两次的数

在内存中建立一个位图，每两位（2bit）表示一个数字，正好占满内存，遍历数字过程中，每个数字出现1次在对应的两位上加1，如果这两位超过2就不再计算，最后统计所有值为2的两位组，这些组对应的数字即答案。每个两位组的0表示未出现，1表示出现1次，2表示出现2次

#### 内存只有3KB，只用找到一个没出现过的数字

一个32位无符号整数占4字节，总共内存只有3KB，最靠近的2的幂次个字节是2048字节，512个计数器，每个计数器负责一个范围内的数字的词频，统计完一遍之后，那些词频数小于这个数字所代表的范围的数就有可能是缺少数字的范围，然后在这个范围中继续分512组，重复这个过程，之后每个组表示的范围越来越少，直到最后每个组仅表示1个数的范围，当这个数为0时就找到了没出过的数字

#### 内存只有几个变量的空间，只用找到一个没出现过的数字

和上一题的方式类似，只是需要使用二分法，首先找中点范围，中点左边一个范围，右边一个范围，然后统计所有的数字，选取词频不足范围的一边继续二分处理，直到某个范围只有1个数字，然后找到那个词频为0的数即可

#### 内存只有3KB，找出这40亿个整数的上中位数（偶数中位数不再求平均值而只取一个）

首先分组统计，然后查看第20亿个数字在哪个组里，找到这个组后，由于知道这个数表示的范围（起始位置和截止位置）和要查找的位置，就能得出这个数在这个组里的偏移量，在这个范围上继续分组统计词频，直到细化到每个数字表示的范围为1，找到对应那个数即可

### 文件排序问题

问题描述：有一个10GB大小的文件，每一行都是一个32位无符号整数，这个文件是无序的，给你5GB的内存空间，输出10GB大小是原文件所有数字排序后的数字文件

解法：需要两个辅助结构，一个门槛堆（大根堆）和一个有序表（按顺序统计词频），门槛堆维护的是总是最小的某些数字，原理是遍历到一个数字时，如果它小于堆的最大值（堆的大小未达到限制），就进入堆，否则舍弃，这样最后堆中剩下的就是所有数字中最小的某些数字。准备好结构后开始遍历文件，假设门槛堆的大小为`k`，每次成功进入堆的数字（同样的数字不再进堆，依靠有序表判断）要在有序表中记录词频，从堆中弹出的数字要在有序表中同步删除，遍历完一遍后要记录当前堆中的最大值，然后将有序表中的数从小到大按照出现次数打印到新文件中，然后清空堆和有序表，进行下一轮遍历，并且所有不大于当前最大值的数都被略过，当所有的数都被打印完程序结束。一轮中一个有效数字在堆中、有序表中总共占12个字节（堆、有序表键值都是32位无符号数），所以根据要使用的内存就可以确定堆中预留多少数字

### 热词问题

问题描述：某搜索公司一天的用户搜索词汇是100亿规模的数据量，每个搜索词汇不超过64字节，设计一种每天从0点开始重新统计，当天任何时刻都能快速显示Top100高频词的可行办法

解法：方案很多，这里写一种水平扩展的可工程实践的方式。首先每个搜索词汇通过哈希函数分流到不同的机器上，每台机器维护一个有序表和词频表，词频表统计每个热词的词频，有序表仅维护Top100的热词，条目是`(hot, count)`，以词频排序，当词频表更新时，如果这个热词在有序表中，那么删除旧条目，将词频+1的新条目插入有序表，如果不在有序表中，查看当前有序表的最小词频，判断当前热词词频是否大于这个值，如果大于就删除旧热词，添加新热词，这些操作都是串行的。当需要获取所有的Top100热词时，首先准备一个大根堆，将所有机器的第一名热词信息`(hot, count, machine_seq, rank)`插入堆中，然后弹出堆顶之后，获取该机器的下一名热词加入堆中，直到弹出100条热词

其它问题：如果某个热词出现频率特别高，那么在分流处可以设置某个词一段时间（例如10分钟）分配到A机器，时间到了重新计时分配到B机器，这种方式可以缓解单点压力。统计时可以先对每台机器的Top100做一个快照再进行统计，预防实时数据的变化

### 多线程任务分配问题

问题描述：给定一个字符串列表，每个字符串长度是1～1000之间，数量有20亿。每个字符串的内容是逗号分隔的单词。设计一种多线程处理方案，统计列表中每个字符串切分出来的单词数量并且汇总到一个HashMap中，这个哈希表的操作是线程安全的。机器资源允许开100个线程，可以多线程读取列表，也可以多线程写入哈希表。希望完成目标的速度尽量快

解法：如果直接把切分和计数任务分配到100个线程上，或者抢占式工作，那么会导致部分线程得到的工作量可能总是很大，而部分线程的工作量很少导致资源浪费，所以考虑将原始任务划分为10份，交给10个线程去处理分配任务，即每个线程有2亿个有效下标给剩下90个线程分配任务，分配策略是随机选择线程，依靠随机函数来让所有工作线程的工作负载的相对均衡的，最终缩短完成所有工作的时间

### 跳出思维定式的系统设计

问题描述：请设计一个生成uuid的系统，要求理论上绝不允许出现相同的id，该系统供全球使用，需要支持每秒百万亿级别的并发。你的系统只需要负责不断生成uuid即可，除此之外不需要维持任何关系

解法：因为要求理论上不允许uuid发生重复，所以哈希类算法无法使用，应该使用自增的数字。系统设计不能使用水平扩展方式提升并发度，因为自增序列需要处理同步问题，机器出现异常时所有机器的同步会导致各种问题。可以使用一种垂直分散的结构，即只有一台机器负责分配uuid，它维护三个信息，包括当前起始值，范围值和增长值，它下面的每个国家的子服务器请求uuid时只需要配置一个数量，将起始值和范围值返回回去，更新起始值即可，并且记录请求时间，如果请求次数频繁，就增加返回的范围值，下面的每台子服务器都扮演自己作为uuid分配者的角色，直到最下层的服务器，它们负责直接响应或者分配具体的uuid，这种设计可以保证并发度足够高，并且无需考虑同步的问题，每次申请都是新uuid，对于子服务器，只要没有uuid，向上层要新的即可，不会发生碰撞

### 囚徒生存问题

问题描述：有100个犯人关在监狱，编号为0～99，监狱长在一个房间中放了100个盒子，开始盒子编号和犯人编号一一对应，然后他随机交换盒子中的编号。监狱长设置了一种处决规则，要求所有犯人打开50次盒子，只要有一个人无法找到自己的编号，就处决所有人，问是否有一种开盒子的策略能让这些犯人的生存概率最高

> 来自论文《The Cell Probe Complexity of Succinct Data Structures》，作者Anna Gal和Peter Bro Miltersen写于2007年

解法：每个犯人从他自己的编号开始打开盒子，如果是自己的编号就停止，否则继续打开盒子里面写的编号。如果犯人是随机打开盒子的话，每个人找到它们自己编号的概率是`1/2`，所有人都找到的概率是`(1/2)^100`，但是如果他们按照循环下标找的话，只要所有盒子里最长的环的长度小于等于50，就一定可以存活，问题就转化为求盒子的全排列中所形成的最长环不超过50的概率，也就是1减去所有长度超过50的环的概率，假设环的长度为`r`，那么出现这个环的可能性是$\binom{r}{100}\cdot(r-1)!\cdot(100-r)!$，然后除所有的可能性$100!$，就是长度为`r`的环概率，化简后是$\frac{1}{r}$，最终存活概率大概是$31\%$

## 树状数组

[code](./examples/87-index-tree-2d-sa-rq.rs)

[code](./examples/87-index-tree-sa-rq-lg.rs)

[code](./examples/87-index-tree-ra-sq-lg.rs)

[code](./examples/87-index-tree-ra-rq-lg.rs)

[code](./examples/87-index-tree-2d-ra-rq-lg.rs)

树状数组维护信息的类型：一般用来维护可差分的信息。例如累加和、累乘积或者出题人发现某个可差分的信息来出题，可差分的信息就是已知全局信息和局部信息可以得到剩下部分信息的信息类型。不可差分的信息例如最大值、最小值等，不可差分的信息一般不用树状数组维护，会选择用线段树维护，因为线段树维护的方式思考难度更低

多数情况下，线段树可以替代树状数组，两者的时间复杂度差不多，单次调用都是`O(logN)`

- 线段树的优势：用法全面，思考难度低，维护信息类型多（包括可差分、不可差分信息）
- 线段树的劣势：代码较多，使用空间较大，常数时间稍差
- 树状数组优势：代码量少，使用空间少，常数时间优异
- 树状数组劣势：维护信息类型少，维护某些不可差分的信息时思考难度大且不易实现

### 单点增加、范围查询

树状数组的经典模版，将原数组维护成树状数组，注意**索引必须从1开始**。树状数组的值是原数组某些值的累加和，对应规则如下

- 对于原数组中`i`位置加上一个数，对应树状数组中`i`位置、`i+last_1_bit`位置...直到这个数字大于数组元素个数都要加上这个数
- 对于原数组中`1~i`位置元素的累加和，就是树状数组中`i`位置、`i-last_1_bit`位置...直到这个数字等于0的所有位置的累加和

使用`Brian Kernighans算法`来求一个数字的二进制表示中最后一位1的位置

首先将原数组每个元素看作独立一份，然后以两个相邻作为一组，然后以四个相邻作为一组，以此类推，树状数组中每个索引表示的累加和包括的原数组的元素是，相同索引元素如果在某个组的右边界，那么那个最大的组中所有元素的累加和就是树状数组表示的累加和，根据这种组织方式，每次插入或者查询时，访问时间仅跟索引范围相关（`logN`）

### 范围增加、单点查询

因为问题改为范围增加，所以要利用原数组的差分数组来构建树状数组，差分数组就是每个位置`i`上`1~i`的累加和是原数组`i`位置的元素，这样在原数组某个范围上加上一个值就可以在差分数组上使用一维差分的公式，即`l`位置加上这个数，`r+1`位置减去这个数，然后查找原数组的某个位置的值就是查找差分数组的前`i`项累加和

### 范围增加、范围查询

这种用法实际是线段树的模版，树状数组也能实现，并且代码更少。使用差分数组求原数组的`1~k`范围的累加和的公式是$\sum_{i=1}^{k} k\cdot D_i - \sum_{i=1}^{k} (i-1) \cdot D_i$，其中`D`表示差分数组。因此需要准备两个差分数组的树状数组，一个表示普通的差分数组，另一个表示`(i-1)*D`，添加时要在`l`位置加上对应的数值，在`r+1`位置减去对应的数值

注意树状数组在增加值时，这个值是固定的，不能和索引有关系，所以本题的实现中，增加方法只能单独应用于某个数组而不能同时处理两个数组

### 二维数组上单点增加、范围查询

这个用法单次调用时间复杂度为`O(logN*logM)`。证明复杂略过，结论很简单，就是在两个维度上计算树状数组。二维数组上计算前缀和的方式是，以两点任意框定的范围，全局左上到范围右下的和减去全局左到范围左减去全局上到范围上再加上全局左上到范围左上的累加和。二维的树状数组同样需要从`(1, 1)`坐标作为左上角点。树状数组直接在原数组上构建

⚠️对于单点修改、范围查询的情况，不需要差分数组，直接在原数组构建树状数组，对于范围修改的情况，就需要在差分数组上（或者利用差分数组组合）构建树状数组

### 二维数组上范围增加、范围查询

首先构建二维数组的差分数组，对于每个元素的规则是任意位置元素减去左边元素，减去上边元素再加上左上元素，当原数组有一个范围增加了值后，差分数组只需要在范围内左上角加值，然后范围外左下减值，范围外右上减值，范围外右下加值

对于原值和差分数组的关系有$A_{i,j} = \sum_{x=1}^{i}\sum_{y=1}^{j} D_{x,y}$

对于原数组范围的累加和和差分数组的关系有$Sum(1,1,n,m) = \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x=1}^{i}\sum_{y=1}^{j} D_{x,y}$

对于差分数组的任何一个位置的点，它在上面的公式中只会被计算`(n-i+1)*(m-j+1)`次，因为只有大于`(i,j)`的位置才会用到这个点的差分数组的值，这个式子可以被缩减为$Sum(1,1,n,m) = \sum_{i=1}^{n}\sum_{j=1}^{m} D_{i,j}*(n-i+1)*(m-j+1)$

最终化简为$(n+1)\cdot(m+1) \sum_{i=1}^{n}\sum_{j=1}^{m} D_{i,j} - (m+1)  \sum_{i=1}^{n}\sum_{j=1}^{m} (D_{i,j} \cdot i) - (n+1)  \sum_{i=1}^{n}\sum_{j=1}^{m} (D_{i,j} \cdot j) +  \sum_{i=1}^{n}\sum_{j=1}^{m} (D_{i,j} \cdot i \cdot j)$

在代码中需要维护4个树状数组，各自的意义就是公式中的差分数组与索引的乘积

## 树状数组相关题目

[code](./examples/88-index-tree-practice.rs)

[code](./examples/88-inverse-pair-lg.rs)

[code](./examples/88-incr-triple-lg.rs)

[code](./examples/88-hh-necklace-lg.rs)

### 逆序对数量

问题描述：给定一个长度为N的数组，如果`i < j && arr[i] > arr[j]`，那么`(i, j)`就是一个逆序对，求数组中逆序对的数量

这道题的两个解法的时间复杂度是一样的`O(N*logN)`，各自有不同的优缺点

- 归并分支
  - 优点：无离散化代码，占用空间少，常数时间优良
  - 缺点：只能做离线计算，因为要修改原始数组的顺序
- 树状数组
  - 优点：支持实时计算，每个位置能得到的逆序对都在统计中，之后数组进行更新可以对应结果的修改和查询
  - 缺点：需要离散化代码，占用空间多，常数时间稍慢

⚠️树状数组这种支持实时计算的形式对于其它题目来说非常重要，更好想解题思路

#### 归并分治解法

定义一个递归函数`f(l, r)`，表示求解`[l..=r]`这个范围上所有逆序对的数量，并且在求解之后将这个范围上的元素进行排序。这种方式是利用排序后子序列可以加速逆序对的计数。当两个子序列都只有1个元素，那么逆序对数量为0，归并过程中，首先两个指针指向各自范围的最右元素，移动右边范围指针，直到那个元素小于左边指针指向的值，此时左边指针指向的值能增加`r-m`个逆序对，然后左边指针向左移动，持续这个过程直到右边指针或者左边指针超出范围。计数完之后使用归并排序过程将这部分元素进行排序

#### 树状数组解法

原数组中所有数的词频作为一个树状数组来组织，然后从后往前遍历原数组，那么每个位置逆序对的数量就是比它小的所有数字的词频之和，所有位置的逆序对之和就是结果，因为数组中的最大值可能非常大，所以需要做数组的**离散化处理**，过程是将原数组拷贝一份，然后重新排序，压缩重复的数字，然后每个数字用它所在的索引来表示，使用二分查找来得到每个数字的索引

### 升序三元组数量

问题描述：给定一个数组，如果`i < j < k && arr[i] < arr[j] < arr[k]`，那么称`(i, j, k)`为一个升序三元组，求数组中升序三元组的数量

解法：准备两个辅助数组，意义是以`i`位置元素的值结尾的升序一元组（它自身）和升序二元组数量，每遍历一个元素，先更新它的升序三元组数量，即所有小于这个数的升序二元组个数，这个可以通过计算升序二元组的累加和来求，计算完之后更新这个值的升序一元组（词频+1），然后再更新它的升序二元组，即小于这个数的升序一元组的数量。求解前依旧需要对数组做离散化处理，时间复杂度`O(N*logN)`

> 这道题和上一道题的共同点：当要求的是数量，且条件中包含索引和元素值的大小关系时，可以考虑词频表的统计，数组离散化后元素值是连续的，可以利用树状数组快速求累加和的特性来求解

### 最长递增子序列的个数

问题描述：给定一个未排序的整数数组，返回最长递增子序列的个数

解法：本题中树状数组维护的不是差分信息，而是以某个数结尾的最长递增子序列的长度和个数信息，对于一个新到来的数，先查看小于等于它的所有数中最长的递增子序列的长度，得到后这个位置的数，最长序列需要再加一，然后数量要取和1的最大值（因为它本身一定是一个），然后将这个信息加入到树状数组中，如果当前的长度更长，那么更新树状数组中的长度和数量，如果相等则仅增加数量，获取这个数之前的最长长度和数量也同理，统计的是最大值，当遍历完所有数后取最大数字的信息中的数量作为答案，时间复杂度为`O(N*logN)`。本题需要做离散化处理

### HH的项链

问题描述：一共有N个位置，每个位置颜色固定，给定M个查询，每个查询的信息是`(li, ri)`表示查询的是`[li..=ri]`范围上一共有多少种不同颜色，返回每条查询的答案

解法：需要准备一个表来记录每种颜色出现的最右位置在哪，另一个数组（树状数组）表示，如果该位置上是某种颜色出现的最右位置，就记为1，否则记为0，最终结果只要在树状数组上统计范围的累加和即可。由于这个处理过程必须完成一个任务就更新，所以任务需要编号后按照`ri`的位置进行排序，要完成哪个任务，先更新到这个`ri`位置出现的所有颜色的最右位置，然后统计输出结果，再进行下一个任务，时间复杂度`O(N*logN)`

### 得到回文串的最少操作次数

问题描述：给定一个只包含小写英文字母的字符串，每一次操作可以选择交换字符串中相邻的两个字符，求将字符串变成回文串的最少操作次数。输入数据保证字符串一定能变成一个回文串

解法：大思路应用了贪心，即每一轮都应该先将最左的未处理的字符和离它最远的相同字符的位置确定后，再进行下一组字符的处理，如果字符只剩一个，那么这个字符一定会放在结果字符串的中心位置。这个贪心的证明可以分析如下几种例子中先移动X还是先移动Y形成回文最终的步数之和，结论是先移动X至少和先移动Y一样，第一种情况比先移动Y的结果更好

- “\_X\_X\_Y\_Y\_”
- “\_X\_Y\_X\_Y\_”
- “\_X\_Y\_Y\_X\_”

首先要求原数组中所有字符最终要去的位置，这里使用一个初始值都为1的树状数组，遍历字符串时，每个位置的字符，如果它的位置还没有确定（结果数组中值为0），那么它要放的位置是它的当前位置在树状数组中的累加和（如果只有一个字符，就把它放到中间），然后查找离它最远的相同字符的位置，它的结果位置是`N-l+1`，`l`是已经放好的位置，当它放到指定位置后，它原本位置在树状数组中的值要减1。处理完的这个结果数组，其中的逆序对数量就是最少的操作步数，因为对于任意一个数，它要回到原始位置，就要跟后面所有小于它的数交换位置，这就是逆序对的含义（位置靠前的数更大），所以可以使用归并分治求逆序对的方式解决

维护一个字符串中每个字符的位置，可以利用类似链式前向星的结构，维护两个数组为`end`和`loc`，`end`表示每个字符出现的最后一个位置，`loc`表示上一个这个字符的位置，每次获取一个最后位置之后，先保存结果，然后更新`end`数组的值

## 线段树原理和代码详解

[code](./examples/89-segment-tree.rs)

[code](./examples/89-segment-uni.rs)

[code](./examples/89-segment-tree-add-reset-query-lg.rs)

线段树维护的信息类型：父范围上的某个信息，可以在`O(1)`的时间复杂度下从子范围的信息加工得到，例如累加和、最大值、最小值，不满足要求的信息例如：某范围上出现次数最多的数，因为每个子范围的结果不一定是整个范围的结果

线段树的经典功能，以下操作的时间复杂度为`O(logN)`

- 范围查询，查询范围内的累加和、最大值和最小值
- 范围修改，对范围内的数进行增加、重置等

线段树的范围修改功能如果要做到`O(logN)`复杂度，要求某个范围上修改了值后，可以在`O(1)`的时间复杂度下将这段范围上的维护的信息加工出来，例如一段范围上每个数加一个值，那么整个范围的累加和可以快速求出来，但是如果是每个数逆序，则无法快速得到这段范围上的新累加和

线段树很灵活，维护信息的种类很多，支持范围修改的类型也很多，例如如果不要求`O(logN)`时间复杂度的范围修改功能，依旧可以使用线段树来维护信息，只要在更新时遍历范围上的元素求新值即可

经典线段树的组织过程

1. 线段树开始下标为1（也可以为0，1是经典设计）
2. 线段树在初始化时确定维护的信息范围，确认后无法更改
3. 任何一个大范围，严格从中点拆分，左范围和右范围
4. 每个范围的信息填写在独立的维护信息数组中，原数组最大范围的信息，固定填在这个数组的`1`位置
5. 如果父范围的信息填在`i`位置，那么左范围就是`i<<1`，右范围就是`i<<1|1`，这是固定的
6. 父范围和独立数组的位置对应是上面的公式限制死的，利用递归参数维护，无需单独记录

如果原始信息（数组）的长度是`N`，那么独立维护信息的数组长度就是`4*N`，这个关系是因为，线段树是将原始数组尽量变成了一颗满二叉树，所以原始数组长度如果是2的阶乘，则独立数组只需要`2*N`的长度，所有节点和树高有固定关系`2^h-1`，但是非这种情况下，这棵二叉树的高度可能会达到`logN+2`，所以所需要的节点数就是`2^(logN+2)`，也就是`4*N`

### 懒更新操作

开始调用范围修改参数时，依照下述过程

1. 如果任务范围把当前范围包含，那么将当前范围的值懒更新（对应独立信息数组）
2. 如果不能全包，就将当前节点的懒信息先传递给下一层（只传递一次），传递过程就是在它的左右范围各自懒更新信息，然后在递归决定左右范围的更新内容，最后记住要更新当前位置的值
3. 退出当前递归过程

一些结论：

- 子范围的懒更新信息，发生一定早于父范围上的懒更新信息，因为真的需要更新当前范围的值时（无法懒更新），一定会先对子范围求值，此时懒信息值必须被计算
- ⚠️如果是单点更新，那么没必要实现懒更新机制，因为每个更新操作都会到最底层

### 通用API

```rust
trait SegmentTree {
  fn up(i:usize);
  fn down(i: usize);
  fn lazy(i: usize);
  fn build(l: usize, r: usize, i: usize);
  fn add(jobl: usize, jobr: usize, jobv: usize, l: usize, r: usize, i: usize);
  fn reset(jobl: usize, jobr: usize, jobv: usize, l: usize, r: usize, i: usize);
  fn query(jobl: usize, jobr: usize, l: usize, r: usize, i: usize);
}
```

### 题型

简单题型包括：范围增加、范围重置、范围查询累加和和最大值，直接应用即可

对于操作结合范围增加和范围重置，需要注意范围重置会把之前累计的范围增加的懒值情况，要注意向下传递时的优先级，总是范围重置的值先传，然后再传范围增加的值

## 线段树的离散化、二分搜索、特别修改

[code](./examples/90-segment-tree-discretization-binarys-modify-lg.rs)

[code](./examples/90-flower-in-vase-hdu.rs)

[code](./examples/90-range-sqrt-lg.rs)

[code](./examples/90-range-mod-single-set-cf.rs)

[code](./examples/90-poster-lg.rs)

### 掉落的方块

问题描述：有一个二维平面，x轴是底边，给定一个二维数组，每个元素表示`[lefti, leni]`，表示在左边界有一个边长为`leni`的正方形从高处垂直下落，如果掉落的方块碰到已经掉落的正方形的顶边或者x轴，就停止掉落。如果方块掉落时仅仅擦过已经掉落正方形的左侧或者右侧，那么不会停止掉落。返回一个整数数组，表示第`i`块方块掉落后整体的最大高度，`1 <= lefti <= 10^8, 1 <= leni <= 10^6`

解法：答案要求的是整个x轴范围上的最高高度，所以使用线段树来维护整个数轴上的最大值，每次掉落的方块相当于是重置操作，重置前需要先查询该范围上的最大值，然后加上新方块的长度，再设置回去即可。因为每个正方形的左右是两个点，根据题意，两个正方形贴住是允许的，所以表示一个正方形在x轴上的范围应该是原范围的左闭右开区间。还需要注意的是题目数据中，x轴的长度可能很长，维护空间这么大的线段树没有意义，需要做离散化处理，将所有的点（更新右边界后的值）排序去重，将它们的索引（从1开始）作为它们的范围表示，使用二分搜索来查找每个正方形具体的范围

### 瓶子里的花朵

> 杭州电子科技大学的OJ已经不接受外部IP注册，使用对数器来验证

问题描述：给定N个瓶子，编号为1~N，开始所有瓶子都是空的，每个瓶子最多插入一朵花，实现以下两种类型的操作

1. 参数为`from,flower`，总共有`flower`朵花，从`from`位置开始插入花朵，已经有花的瓶子就跳过，如果一直到最后的瓶子，花也没有用完，就丢弃剩余的花朵，返回这次操作插入的首个空瓶的位置和最后空瓶的位置。如果从`from`开始所有瓶子都有花，打印“Can not put any one.”
2. 参数为`left,right`，从`left`位置开始到`right`位置的瓶子变成空瓶，返回清理花朵的数量

解法：使用线段树维护所有瓶子范围上的累加和，每次操作是一个重置操作，对于操作1，首先查看`from`位置之后有多少个空瓶子，然后在这个范围上查找第1个和最后一个（要插花的数量和所有空瓶子的最小值），如果没有空瓶子就打印，如果有则返回，第二个操作只要先查找这个范围上有多少朵花，返回后重置为0即可。在范围查找第几个空瓶子需要使用二分搜索，例如找第`i`个空瓶子，首先看中点之前的范围是否有`i`个空瓶子，如果有，记录这个值继续往左找到这个瓶子的索引，如果没有，则扩大范围在右找

### 范围上开平方并求累加和

问题描述：给定一个长度为N的数组，实现以下两种类型的操作

1. 参数为`l,r`，将`arr[l..=r]`上的每个数开平方，结果向下取整
2. 参数为`l,r`，查询`arr[l..=r]`上所有数字的累加和

两种操作一共发生M次，数据可能有`l > r`的情况，需要交换范围

解法：需要一个线段树来维护某个范围上的累加和。因为每次的操作是开平方，所以无法实现在`O(1)`的时间内通过子范围的结果得到父范围的结果。那么无法实现`O(logN)`时间复杂度的范围修改。这里需要引用**势能分析**，因为操作是开平方，所以每个数字只会越来越小，当这个数字变成1的时候，任何开平方的操作都没有意义了，那么这个数的有效操作次数就是`h*logV`，而所有节点的总势能就是`N*logN*logV`，均摊到每个节点的修改上仍然是`O(logN)`的时间复杂度。还需要维护一个范围上的最大值信息，如果一个范围最大值是1，那么就不再进行开平方操作，这是一个剪枝，一般剪枝只是优化常数时间，但这个场景下剪枝直接影响了复杂度的计算。并且本题中线段树不需要懒信息，因为每个修改都会涉及到子节点

### 包含取模操作的线段树

问题描述：给定一个长度为N的数组，实现下列三种操作，一共调用M次

1. 参数为`l,r`，查询`arr[l..=r]`的累加和
2. 参数为`l,r,x`，把`arr[l..=r]`范围上所有数对`x`取模
3. 参数为`k,x`，将`arr[k]`上的数字设置为`x`

解法：本题依旧不能实现在`O(1)`时间内通过子范围的值更新父范围的值，所以时间复杂度需要使用势能分析，对于取模操作来说，任意一个数字只要对比它小的数字取模，经过有限次取模后就可以变成0，之后就不需要再执行取模操作了，这个有限次就是`logV`，因为每次取模最多还会剩下`1/2*V`的数。那么所有数字的总势能就是`N*logN*logV`，对于每次取模操作的时间复杂度就能均摊到`O(logN*logV)`，并且只要这些数字为0或者最大值小于要取模的数，就不需要进行取模操作。对于第三种操作，因为是单点设置数字，所以每次增加的势能有限，即`logN*logV`，不会影响整体的时间复杂度。依旧需要维持累加和和最大值信息

### 贴海报

问题描述：一面墙有固定高度，长度为N，总共有M张海报，每张海报的高度和墙的高度相同。每张海报的张贴位置有两个点，表示起点和终点，有可能发生后面贴的海报把前面的海报完全覆盖，导致看不到的情况，当所有海报贴完，求能看到的海报的数量（只要能看到就算）

解法：这道题的关键在于只需要最后查询一次结果，所以不需要实时汇总子范围的结果。使用线段树维护的是某个范围内最后出现的海报编号，如果是0则表示还没有贴过海报，当所有海报贴完，只要遍历所有位置上的海报编号，统计所有出现的海报编号即可。由于线段树的范围是点，而海报的有效范围是线（两点之间的线），所以在离散化每个海报的位置的时候，只要两个点中间的距离大于1，就随意添加一个点，这样可以保证后贴的海报不会**错误地**盖住早贴的海报

## 线段树维护更多类型的信息

[code](./examples/91-switch-lg.rs)

[code](./examples/91-greedy-land-lg.rs)

[code](./examples/91-boring-array-lg.rs)

[code](./examples/91-variance-lg.rs)

[code](./examples/91-color-board.rs)

### 开关

问题描述：现有N盏灯排成一排，编号为1~N，开始所有灯都是关着的，支持以下两种操作

- 参数为`0,l,r`，改变l~r范围上所有灯的状态，开的关闭，关的打开
- 参数为`1,l,r`，查询l~r范围上有多少灯是打开状态

解法：使用线段树维护范围上所有开着的灯的数量，使用一个辅助数组保存范围上的开关信息，每次设置一次开关，开着的灯的数量就变成那个范围所有灯的数量减去原本亮着的灯的数量（初始亮灯数量为0），使用懒信息更新机制。在传递懒信息的时候要注意开关信息是取反而不是固定设置为`true`

### 贪婪大陆

问题描述：一共有N个格子，编号是1～N，开始格子上没有地雷，支持两种操作

- 参数`1,l,r`，在l~r范围的格子上放置一种新型地雷，每次地雷都是和已放置地雷不一样的新款
- 参数`2,l,r`，查询l~r范围的格子上一共放置过多少款不同的地雷

解法：使用线段树维护两个信息，即范围上有多少款地雷的开始位置和结束位置，因为查询的是种类而非数量，这样每个范围上有多少种地雷可以等价为这个1~r范围上的开始位置数量减去1~l-1范围上的结束数量，所以每条信息就是单点更新，也没有懒信息的传递。要注意边界条件的判断，如果l就是1，那么直接统计即可

### 无聊的数列

问题描述：给定一个长度为N的数组，实现以下两种操作

- `1,l,r,k,d`，在l~r范围上的数依次加上等差数列，首项为k，公差为d
- `2,p`，查询p位置的值

解法：先求出原数组的差分数组，然后对于操作1，实际上就是差分数组的`l`位置加上`k`，然后在`l+1~r`位置加上`d`，然后在`r+1`位置减去这个等差数列的末项，所以在差分数组上创建一个线段树，维护累加和信息，查询的`p`位置就是差分数组中1~p范围的累加和。需要注意边界条件的处理

### 平均数和方差

问题描述：给定一个长度为N的数组，支持三种操作

- `1,l,r,k`，为l~r范围上的所有数字加上k，k为double类型
- `2,l,r`，查询数组l~r范围上所有数字的平均数，返回double类型
- `3,l,r`，查询数组l~r范围上所有数字的方差，返回double类型

解法：使用线段树维护一个范围上的累加和和平方和，平均数就是累加和除那个范围上的数字个数，方差的计算公式是每个数减去平均数的平方最后再除范围上的数字个数，化简后就是平方和除数字个数减去平均数的平方。对于每次的加法操作，范围平方和的变化就是原数值加上`2*v*avg`再加上`n*v^2`，所以先更新平方和再更新累加和即可

### 色板游戏

问题描述：一共有L个色板，编号1～L，开始所有色板都是1号颜色。一共有T种颜色，编号1～T，可以往色板上涂色，支持两种操作

- `C,A,B,C`，A~B范围的色板都涂上C颜色
- `P,A,B`，查询A~B范围的色板上一共有几种颜色

解法：根据数据特点，总共只有30种颜色，可以使用一个32位整型来表示一个范围上的颜色组成，每次查询的时候只要找出这个范围的颜色组成，然后计算1的个数就是结果。可以使用懒信息传递

## 线段树解决区间合并的问题

[code](./examples/92-seq-lg.rs)

[code](./examples/92-lr-alternate-lg.rs)

[code](./examples/92-connected-house-lg.rs)

[code](./examples/92-hotel-lg.rs)

区间合并类问题的经典模型：求连续1的最长子串长度，线段树直接维护这个信息是没办法直接合并求出的，所以需要多维护一些信息

- 连续1的最长子串长度（目标值）
- 连续1的最长前缀长度（从范围开始）
- 连续1的最长后缀长度（到范围结束）

这三个信息互相配合可以从左右范围各自的三个信息，推出父范围的三个信息，关键在于**不同类型的修改**发生时信息如何维护，**不同类型的查询**发生时信息如何汇总，会在题目中体现

### 序列操作

问题描述：给定一个长度为N的数组，内部只有0、1两种值，下标从0开始。这个序列支持5种操作和查询操作

- `0,l,r`，把l~r范围上的所有数字改为0
- `1,l,r`，把l~r范围上的所有数字改为1
- `2,l,r`，把l~r范围上的所有数字取反（1-0互换）
- `3,l,r`，查询l~r范围上有多少个1
- `4,l,r`，查询l~r范围上连续1的最长子串长度

解法：因为需要查询范围上1的个数，所以需要维护累加和信息，其次是连续1个数所需要的三个信息，并且取反操作更新这三个信息还需要维护对应的0的三个信息，辅助数组包括支持重置操作的`update`和`change`数组，还有支持取反操作的`reverse`数组。懒信息传递的优先级是重置大于取反，并且在重置操作后要记得将`reverse`数组的值修改回`false`

### 最长LR交替子串

问题描述：给定一个长度为N的字符串，初始内容全是'L'字符，每次可以修改一个位置的字符，如果原字符是'L'，那么改成'R'，否则改回'L'。如果一个子串是两种字符不停交替出现的样子，即'LRLR...'或者'RLRL...'，那么说这个子串是有效子串，每次修改后都打印整个字符串中最长交替子串的长度

解法：字符可以简化为01数字，这道题的修改操作就是单点的设置操作，特别的点是在合并时，最长长度的修改和中点两侧的值有关，如果两个值相同，那么左右的交替字符串可以连起来，否则就单独计算，包括整个范围上前缀和后缀的计算，因此**需要维护原数组的变化**，在合并过程中需要使用其中的值

### 地道相连的房子

问题描述：有N个房子排成一排，开始每相邻的两个房子之间都有地道，支持以下三个操作

- `D,x`，把x号房子摧毁，该房子附近的地道也一并摧毁
- `R`，恢复上次摧毁的房子，该房子附近的地道也一并恢复
- `Q,x`，查询x号房子能到达的房子数量，包括x号房子自身

解法：这道题可以认为是初始数组中所有数相同（比如都是0），摧毁即修改为不同值（比如1），恢复上一次摧毁的房子可以用一个栈来保存摧毁信息，重点在于查询过程，因为是查询一个点往两侧延伸的最长连续数量，所以不需要维护范围内的最长连续数量，只需要最长前缀和最长后缀信息，在查询时，需要确保一个条件，就是这个点在查询范围上一定有连续的值，并且这个值不会超出范围，如果这个点在左边，那么它和中点的距离如果小于左边范围的后缀，就去左边找，否则就是左边的后缀加上右边的前缀，对于右边同理

### 旅馆

问题描述：一共有N个房间，开始都是空房，有以下两种操作

- `1,x`，找到至少有连续x个空房间的区域，返回最左编号，如果找到多个，返回其中最左区域的最左编号，如果找不到打印0，不办理入住，如果找到，从这个编号为x个人办理入住
- `2,x,y`，从x开始数y个房间，做清空操作

解法：空房和入住可以使用01来表示状态，本题的重点是查询范围内最左边的连续0的最长长度，线段树维护查找连续0最长长度的相关信息，由于是范围设置值，所以需要使用`update`和`change`来处理设置值的懒信息，在找的时候，首先确保这个范围上一定存在长度为x的连续空房，然后开始查找，对于一般情况，如果左边范围的最长长度大于等于这个值，那么去左边找，否则看跨越部分是否大于等于这个值，如果是就返回左边后缀的起始点，否则去右边找。注意题目中做清空操作时可能超出范围，需要取一个最小值

## 开点线段树、区间最值和历史最值

[code](./examples/93-segment-tree-5-practice.rs)

[code](./examples/93-open-point-segment-tree-lg.rs)

[code](./examples/93-range-history-lg.rs)

### 开点线段树

开点线段树可以支持很大的数据范围，它开始并不为所有范围分配空间，只有当真的需要开辟左右两侧空间时才会申请。父范围的空间编号`i`，利用一个`cnt`自增变量来给左右两侧申请的空间，记录在`left[i]`和`right[i]`中，如果是`0`表示还没有申请空间，此外其它操作和普通线段树没有区别

开点线段树适用范围：需要支持的范围很大，实际操作数量并不大，对于类似题目可以使用开点线段树尝试，使用空间约为：操作数量\*树高\*2，原理是每个操作的两个边界有树高的长度到最下层节点，所以整个空间使用（真实分配）大概是这个数量，极限空间和普通线段树一样

- 优势：分析难度低，便于使用
- 劣势：常数时间不好，相比其它方法还是浪费空间（通常不是最优解）

大多数情况下开点线段树可以被其它方法替代，例如离散化、有序表结构（平衡树）、堆结构等。数据量允许时间复杂度不差

⚠️开点线段树不可被替代的用法是在线段树的合并和分裂中，这一话题和树链剖分结合比较紧密

#### 动态开点线段树

问题描述：给定一个长度为N的数组，开始所有元素为0，支持两个操作

- `1,l,r,v`，将l~r范围的每个树增加v
- `2,l,v`，查询l~r范围的累加和

`1 <= n <= 10^9, 1 <= m <= 10^3`

解法：开点线段树的模版题，根据之前的空间计算，大概需要60000个元素的空间（静态空间），只要在`down`和`add`过程中将新空间分配出来，其它的操作和普通线段树相同

#### 统计区间中的整数数目

问题描述：实现`CountIntervals`类的如下三个方法

- `CountIntervals()`，初始化
- `void add(int l, int r)`，把l~r范围上的数字都设置成1
- `int count()`，求整个区间上有多少个1

需要支持的范围是`1~10^9`范围，调用`add`和`count`方法共`10^5`次

解法：使用求累加和的开点线段树初始化，因为这道题只求所有的1，所以只要`sum[1]`的数据，只关注向上汇总即可，并且这道题在更新时只会设置1，所以不需要使用懒信息向下更新，范围上直接更新成范围长度的值即可。有一个剪枝是当给定范围上的数正好是它的范围长度时，不再需要重新设置值

### 线段树的区间最值操作

给定一个长度为N的数组，实现以下三个操作

- `0,l,r,x`，将数组l~r范围上的每个数v更新成`min(v,x)`
- `1,l,r`，查询l~r范围上的最大值
- `2,l,r`，查询l~r范围上的累加和

维护信息包括范围上的累加和、最大值，额外的信息包括最大值的个数和严格次大值，并且提供一个小于最小可能修改到的值的值作为叶子节点默认的次大值。处理过程是，如果设置的最大值大于等于当前范围的最大值，那么不处理（因为无意义），如果大于当前范围的次大值且当前范围在任务范围内，那么可以懒更新当前范围的最大值和累加和，最大值修改成更新的值，累加和减去变化值乘范围长度，如果小于等于当前范围的次大值，那么需要更新各自范围上的值，最后再汇总上来

时间复杂度分析（标签回收模型+势能分析）：首先根节点（最大范围）上有一个标签，最大值和父节点不相同的节点也有一个标签，每当设置一次值，更新过的节点，如果有标签就将标签回收，如果一棵子树上完全没有标签，就表示后续的设置不会再遍历这棵树的子节点（这些节点的次大值都会是无效值，即这个节点上不会再出现小于等于次大值的值更新操作），结合之前提到的势能分析，所有标签的数量是`O(N)`量级，而回收一个标签的成本是`O(logN)`，所以将所有标签回收的时间仍然是`O(N*logN)`

> 发明者吉如一，也叫吉如一线段树

#### 支持区间内批量增加值的操作

线段树上某个范围批量增加一个值，对于势能的影响在`O((logN)^2)`数量级，因为范围修改后，离两个边界最近的节点会重新被加上标签，那么每次批量增加操作新增的那些标签就是`logN`，这些标签被回收的时间根据之前的论述还是`logN`，所以即使带上批量增加的操作，导致的势能增加幅度也不会很大

代码层面的优化：对于`lazy`函数，增加最大值增加幅度和其它值增加幅度两个入参

#### 历史最值问题

问题描述：给定两个长度为N的数组，开始两个数组完全一样，任何操作做完，都更新B数组，`B[i] = max(B[i], A[i])`，支持以下操作

- `1,l,r,v`，l~r范围上的每个数加上v
- `2,l,r,v`，l~r范围上每个数变成`min(A[i],v)`
- `3,l,r`，返回l~r范围上的累加和
- `4,l,r`，返回l~r范围上的最大值
- `5,l,r`，返回l~r范围上B数组的最大值，即范围上的历史最大值

解法：这道题结合了线段树求区间最值的问题和支持批量增加操作，还需要求范围上的历史最大值，所以需要多维护一个历史最大值、最大值增加幅度和其它值增加幅度，具体解释见代码实现

## 线段树与扫描线结合的题目

[code](./examples/94-scanline-practice.rs)

[code](./examples/94-skiline-lg.rs)

[code](./examples/94-rec-area-lg.rs)

[code](./examples/94-rec-circumference-lg.rs)

### 包含每个查询的最小区间

问题描述：给定一个二维整数数组，每个元素是`intervals[i] = [l, r]`，表示第`i`个区间开始于`l`，结束于`r`，区间的长度是`r-l+1`，给定一个整数数组，每个值是要查询的位置，答案是所有包含这个值的区间中，最小长度的区间是多长。返回数组对应查询的所有答案，如果不存在这样的区间，那么答案是-1

解法：这道题是扫描线的简单应用，首先对所有区间根据左边界从小到大排序，然后将要查询的值（和原始编号）也进行排序，这个排序后的值就是扫描线，准备一个小根堆，堆中的元素是长度和右边界的元组，每遍历一个扫描线，先将所有左边界小于等于这个值的范围入堆，然后再将堆中右边界小于这个值的范围出堆，此时堆顶如果有元素，这个元素的长度就是这个扫描线对应的答案

### 天际线

问题描述：给定一个二维整数数组，每个元素包含三个信息，分别是建筑的起始点、终止点和高度，求所有高度发生变化的点和该点对应的高度

解法：对于建筑的终止点，如果有一个建筑的起始点和它相同且高度更低，那么这个点就无法记录，所以每个建筑的高度有效值范围为起始点和终止点-1，为了防止建筑的范围过大，所以需要离散化操作，得到一个离散化数组，用这个数组的索引表示建筑的范围。首先按照建筑起始点从小到大排序，然后离散化这个数组，创建一个大根堆，其中保存一个高度和右边界的元组，开始遍历建筑的所有点，先将左边界小于等于这个点的所有建筑插入堆，然后移出堆顶上右边界小于这个边界的建筑，然后堆顶的高度就是这个点的高度，得到所有点的高度后，将所有变化的点（和之前高度不同）和它的高度作为结果返回即可

扫描线：不是一种算法，只是一种**流程设计**，根据实际出现的边界来处理，边界从小到大依次扫描过去，扫描到某个边界时，把该边界造成的影响维护好（例如包含扫描线的范围，以及对应的高度和长度指标，并且将超出边界的内容移除掉，可能是延迟删除），扫描期间求解得到答案。如果边界造成的影响比较简单，可以用简单结构维护（堆），如果边界造成的影响比较复杂，可以使用高级结构维护（线段树）

### 矩形面积并

问题描述：在一个二维平面上有很多的矩形，求所有矩形的总面积，重叠面积只算一次

解法：在x轴上应用扫描线，每次到一个x点，会有一段y轴上的长度被收入，那么距离上一次的点作为长，目前的所有长度是宽，就可以计算这一段上的矩形面积。y轴上所有的点离散化后通过一个线段树维护，线段树维护的信息包括每个点的有效长度，覆盖长度和覆盖次数，如果覆盖次数等于0，那么该点的覆盖长度就是左边覆盖的长度加上右边覆盖的长度，否则就是自己的总长度。因为这道题每个覆盖+1的数据一定对应一个覆盖-1的数据，所以可以不做懒信息，也不需要向下传递信息。所有的矩形数据转换成事件，左边界表示一个y轴范围的覆盖数加1，右边界表示一个y轴范围的覆盖数减1，事件按照x轴左边界排序，依次进行扫描

### 矩形周长并

问题描述：在一个二维平面上有很多矩形，求所有矩形不重复部分的周长

解法：和上一道题相同，区别在于x轴和y轴要分别扫描，扫描过程中先引入线，再计算

## 摩尔投票大加强，线段树里捉海王

[code](./examples/95-moore-vote.rs)

摩尔投票描述的是寻找一个在数组中出现次数（严格）超过半数的数字，戏称为水王算法

算法前提

1. 如果数组中存在水王数，那么经过算法筛选到最后的就一定是水王数
2. 如果算法筛选到最后留下的不是水王数，说明这个数组中没有水王数

算法流程

大流程就是一次随机消除数组中两个不同的数，最后剩下的数可能是水王数，根据前提只要统计这个数的出现次数即可判断它是否为水王数

1. 有两个变量，`cand`和`hp`表示候选者和血量
2. 遍历数组
   1. 如果`hp == 0`，那么更新`cand`，然后`hp += 1`
   2. 如果`hp != 0`，判断当前数是否等于当前`cand`
      1. 如果等于，那么`hp += 1`
      2. 如果不等于，那么`cand`实效，将`hp`设置为0

最后如果`hp == 0`，表示没有水王数，否则再统计一次这个数出现次数，判断是否是水王数

### 出现次数大于n/2的数

问题描述：给定一个大小为N的数组，返回其中的水王数，如果不存在则返回-1

解法：直接应用水王算法即可

### 摩尔投票智力题

问题描述：给定一堆选票，开始所有选票背面朝上，正面朝下放在桌子上。有一台机器可以判断两张选票上写的人名是否一致。如果有任何一个人得票超过半数，那么该人当选，宣告投票成功，如果没有人得票超过半数，那么无人当选，宣告投票失败。只能利用机器，并且全程不看选票正面的情况下如何知道投票是成功还是失败。如果失败要向众人宣布这一点，如果投票成功需要找出任何一张写有当选人名字的选票，然后当着众人的面，在最后时刻才翻开这张选票，公布当选者的名字

解法：这道题无法使用词频统计，必须使用水王算法。首先为所有选票编号，然后记录一个`hp`，从第二张票可以使用机器来对比选票，如果相同就`hp`加1，并且将该选票编号更新为相同选票的编号，否则就`hp`减1，如果碰到`hp`为0，那么它成为被对比的选票。直到最后如果`hp`为0，那么投票失败，否则查看最多编号相同的选票是否超过半数，如果超过取任何一张作为结果，否则依旧宣布投票失败

### 摩尔投票可以并发执行

问题描述：如果允许多线程，如果让摩尔投票过程得到加速

解法：结论是将原始数组进行任意划分，每一部分使用水王算法得到水王数，最后任意两个不同的数字数量相减，最后剩下的数字依旧遵循水王算法的结论

### 划分左右使其水王数相同

问题描述：给定一个大小为N的数组，返回其中的一个划分点下标，使得左侧水王数等于右侧水王数，如果不存在这个划分点返回-1

解法：首先求这个数组的水王数，然后从起始点开始遍历，左边的水王数个数和右边的水王数个数如果在两边都超过半数时，则返回那个划分点，否则返回-1

### 出现次数大于n/k的数

问题描述：给定一个大小为N的数组，给定一个较小的的数`k`，返回所有的水王数，水王数的定义是这个数的词频要超过`N/k`，如果没有水王数返回空列表

解法：对于较小的`k`，可以维护`k-1`个`cand`列表，遍历数组，如果列表不包含这个数字，那么如果列表有`hp`为0的，就将它更新进去，否则全部`hp`减1，如果包含这个数字，将这个数字的`hp`加1，最后判断列表中所有的数是否是水王数

### 子数组里的海王数

问题描述：子数组的海王数首先必须是子数组上出现次数最多的数（水王数），并且要求出现次数大于等于`t`

解法：在原数组上构建一个线段树，维护信息为`cand`和`hp`数组，主要逻辑是合并时，左边的水王数和右边的水王数，哪个多就用哪个，然后再筛选出现次数大于等于`t`的条件。要快速使用两个索引获得某个数字在这个范围出现的次数，可以使用按照数字大小和原本索引进行排序，然后使用二分，寻找小于等于某个数且索引小于等于某个数的值的位置，找到两个位置之后想减就是这个数字在这个范围出现的次数

## 倍增算法和ST表

[code](./examples/96-nude-problem.rs)

[code](./examples/96-flag-plan-lg.rs)

[code](./examples/96-min-max-st-lg.rs)

[code](./examples/96-gcd-st-lg.rs)

[code](./examples/96-max-count-lg.rs)

### 预备问题

问题描述：给定一个正数x，已知x一定可以用m个二进制位来表示，从高位到低位打印x每一位的状态

解法：m个二进制位最多表示`2^m`，只要m满足条件，可以从`2^m`开始判断x是否包含这个数，如果包含就设置1，否则设置0到下一位，直到m为0

问题描述：给定一个正数x，打印小于等于x最大的2的幂次

解法：首先尝试`2^0`，如果小于等于x，幂次就加1，直到超过x，这样实现可能会在x接近整数最大值时越界，可以判断是否大于`x>>1`，如果大于就是那个幂次

### 倍增算法流程和ST表

以这样一个问题为例简述算法过程：线段上有N个点，给定每个点往右跳一步能最远覆盖的点`jump[i]`，已知从任意点出发都可以到达最后的点，并且对于任意两个点`i`和`j`，有`i < j => jump[j] >= jump[i]`。问题是如何快速计算任意两点间最少需要几步到达

这两个条件表示任何点（除终点）上都不会停止行动，总能向终点前进，且每个点的范围都不会出现完全覆盖的情况（确保倍增算法得到的是最优解）

构建ST表（Sparse Table）：`st[i][p] = st[st[i][p-1]][p-1]`，`p`表示跳`2^p`步，表的大小是`N*logN`，这个表可以通过第一列的值推算出后面所有的值，利用ST表，从x到y跳跃的过程，就是从最大步长开始，每次步长减少一半尝试，如果可以走就走，之后更新距离，最后结果需要再加1，查询过程时间复杂度`O(logN)`

### 国旗计划

问题描述：给定点的数量M，点的编号是1~M，所有点围成一个环。`i`号点一定可以顺时针到达`i+1`号点，最终`M`号点顺时针到1号点。给定N条线段，每条线段的数据是`(a,b)`，表示线段从`a`顺时针到`b`，输入数据保证所有线段可以把环覆盖，每条线段不会完全在另一条线段内部。返回一个长度为N的结果数组，每个值表示一定选`x`线段的情况下，至少选几条线段能覆盖整个环

解法：首先要把环上点的数据替换为线段上的点，如果给定线段的终点小于起点，那么线段的终点就是加上`M`之后的值，然后将所有线段按照起始点从小到大排序，每条线段一步能到的最远的下一条线段就是中间所有起点小于等于它终点的线段中最远的那个，根据这个数据构建ST表，ST表的列数是`logN`，最后遍历每条线段，根据每条线段的起点到它的终点的距离计算需要几步（经过几条线段），更新到答案列表即可

### ST表查询最大值和最小值

问题描述：给定一个长度为N的数组，一共有M次查询。每次查询`arr[l..=r]`上的最大值和最小值，每次查询打印最大值减最小值的结果

解法：用ST表来维护从某个点出发，包含自己在内的2的幂次范围的最大值或最小值，在查询的时候，先计算不超过这个范围的最大的2的幂次，然后使用ST表查询左边这个范围的最大/小值，在计算终点为右边的这个距离的最大/小值，最终取结果即可。生成ST的转移方程是`ST[i][p+1] = ST[i][p].max(ST[i+2^p][p])`，计算不超过某个数的最大的2的幂次的技巧是`log2[i] = log[i/2] + 1`

### 用法总结

ST表的适用范围是：如果A区间和B区间可能有重叠的部分，且两部分的答案可以加工出整体的答案，即在对应的区间查询就是一个**可重复贡献问题**，例如区间最大值、最小值、公约数等，但是区间累加和就不是，按位与和按位或操作也属于此类

优劣势，RMQ（range maximum/minimum query）可以用ST表维护也可以用线段树维护，区别如下

- 优势：构建时间复杂度好`O(N*logN)`，单次查询时间复杂度是`O(1)`，代码量较小
- 劣势：需要空间较大，因为`logN`相比线段树的`4`还是更大，且不支持修改操作

### ST表查询最大公约数

问题描述：给定一个长度为N的数组，一共有M次查询，每次查询l~r范围上所有数的最大公约数

解法：和求最大值、最小值相同，使用辗转相除法求最大公约数即可

### 出现次数最多的数有几个

问题描述：给定一个长度为N的数组，该数组一定有序。一共有M次查询，每次查询l~r范围上出现次数最多的数有几个

解法：因为数组有序，可以将相同的数放到一个桶中，然后给予桶的编号构造ST表，维护从一个桶，求一个包含它的2的幂次范围上的最大值，每个桶的值就是里面的数字个数，对于每个查询范围，先看这个范围左边所在桶有几个数字，然后看右边所在桶有几个数字，如果两个桶不是一个桶且中间还有其它桶，就求中间这个范围的最大值，最终结果就是三个数的最大值

## 树上问题专题1-树上倍增和LCA

[code](./examples/97-ontree-practice.rs)

[code](./examples/97-lca-ontree-lg.rs)

[code](./examples/97-lca-tarjan-lg.rs)

[code](./examples/97-emergency-muster-lg.rs)

[code](./examples/97-trucking-lg.rs)

[code](./examples/97-is-palindrome-newcoder.rs)

树：每个节点只有一个父节点（除顶点外）的图结构，就是树。如果所有的节点构成一棵树，节点数为N，边的数量就是N-1，如果是多棵树，就构成了森林结构，不满足这个数量关系。树上问题指的包括一叉树、二叉树、多叉树等

树上倍增的过程

1. 建立每个节点的深度表，即`deep`数组
2. 建立每个节点往上跳2的幂次步（0开始，不超过自己的深度）能到达的节点编号，ST表
3. 给定任意节点`i`，可以快速查询从`i`节点往上走的路径上位于第s层的节点编号

生成`deep`数组的时间复杂度为`O(N)`，构建ST表的时间复杂度为`O(N*logN)`，单次查询的时间复杂度是`O(logN)`

### 树节点的第K个祖先

问题描述：树上有N个节点，编号从0开始，树的结构用数组代表，`arr[i]`是节点`i`的父节点，树的根节点的编号为0，树节点`i`的第`k`个祖先节点，是从节点`i`开始往上跳`k`步来到的节点。实现`TreeAncestor`类，包括初始化和查询方法

解法：使用链式前向星建好树，本题只需要单向边，即父节点指向子节点。然后在构建的树上进行DFS，设置每个节点的层高和ST表信息，转移方程是`ST[i][p] = ST[ST[i][p-1]][p-1]`，同一行（同一个节点）仅依赖它之前节点的值，所以遍历过程中就设置ST表的值。查询过程中，如果这个点层级小于指定的`k`，那么范围-1，否则，开始从最大的值尝试，只要这个步幅小于`k`就走，遍历完所有步幅最后停止的节点就是要求的祖先节点

### LCA问题

给定树上任意两点a和b，快速查询出a和b的最低公共祖先（LCA），常见的有三个方法

1. 树上倍增
2. tarjan算法+并查集
3. 树链剖分（本节无）

#### 树上倍增解法

算法过程：

1. 先让a和b跳到同一层级
2. 利用倍增算法找到a和b的最低公共祖先

如果节点数为N，建立预处理结构的时间复杂度为`O(N*logN)`，单次查询的时间复杂度为`O(logN)`

这种解法的优势是可以在线查询，查询M次的时间复杂度是`O(M*logN)`

本题中使用DFS更新`deep`数组和ST表在数据量大的情况下可能爆栈，需要改为迭代过程，设栈上维护的变量为`u,p,e`，分别表示当前处理的点，当前点的父节点和当前处理的是哪条边，首先根节点入栈开始过程，出栈后判断当前边是否为-1（初始值），如果是则设置`deep`数组和ST表，然后遍历它的边，只要边的点不在栈顶，就更新自身的`e`，然后入栈本身，再将新边入栈

#### tarjan算法解法

算法过程：

1. 将所有问题整理好（建立成一颗树），权值是问题编号，然后开始遍历原树
2. 当遍历到任意一个节点，将其标记为已处理状态
3. 遍历这个点的所有子树，每棵子树遍历完后都和当前节点合并成一个集合（使用并查集），集合头节点为当前节点
4. 遍历完所有子树后，查询和当前节点相关的所有查询
   1. 如果这个查询的另一个点已经遍历过，那么答案就是它的集合头节点
   2. 如果这个查询的另一个点没有遍历过，那么查询不处理，等到遍历到该节点时再处理

答案可能会多次设置，但是不会出错。如果节点数为N，查询次数为M，那么时间复杂度是`O(N+M)`

### 紧急集合

问题描述：一共有N个节点，编号1～N，一定有N-1条边连接形成一棵树。从一个点到另一个点的路径上有几条边，行动就需要耗费几个金币。每条查询`(a, b, c)`表示有三个人分别在三个点上，他们想集合在树上的某个点，并且想花费的金币总数最少，一共有M条查询

解法：首先声明一个结论，在一棵树上，两点的最短距离是通过它们的最低公共祖先的路径长度，即`Dmin(a-b)=D(root-a)+D(root-b)-2*D(root-lca(a,b))`。本题中也有结论，三点中两两值虽然有三个最低公共祖先，但是这个节点只会有1个或者2个，如果三个点的最低公共祖先有2个节点，那么一定是有两个节点的最低公共祖先层级更高，而另一个层级更低，因为如果a和b的最低公共祖先层级更高，a/b和c的最低公共祖先层级也更高的话，这两个祖先节点一定是一个节点。根据这个结论，对于任意一个查询，通过树上倍增（ST表）求它们的三个最低公共祖先，如果三个最低公共祖先一样，那么三个点都集合到这个点，计算路径的累加和就是答案，如果有两个祖先节点，先让层级高的节点一起到这个点，然后再让层级低的点先到最低公共祖先，再从这个层级低的祖先节点移动到那个层级高的祖先节点

### 货车运输

问题描述：一共有N座城市，编号1～N，一共有M条双向道路，每条道路`u,v,w`，表示有一条限重为`w`，从`u`到`v`的双向道路，从一点到另一点的路途中，汽车载重不能超过每一条道路的限重，每条查询`(a,b)`，表示从`a`到`b`的路线中，求汽车允许的最大载重是多少，如果从`a`到`b`无法到达，那么答案为-1

解法：这道题里有一个贪心策略，即如果想求汽车的最大限重，那么一定要在权值最大的连通图里行动，由于所有的道路不一定是全连通的，使用Kruskal算法将图中的所有最大生成树得到，如果查询中的两个点在同一棵树上，那么它们的最大载重就是它们从两个点走到最低公共祖先过程中所有边的最小值，这个值用ST表来维护

### 边权相等的最小修改次数

问题描述：一棵树有N个节点，编号0～N-1，每条边`u,v,w`表示从`u`到`v`有一条权重为`w`的边，共有M条查询，每条查询`(a,b)`表示求`a`到`b`的最短路径中把所有边变成一种值需要修改几条边

解法：题目的数据条件中权值只有1～26的有效值，使用Tarjan算法求出每个查询中两个点的最低公共祖先，然后两点之间的距离减去路程中出现次数最多的那个值的次数就是结果，需要一个结构保存从头节点到某个节点，权值为`x`的边有几条，这个结构通过一个深度优先遍历得到

### 在传球游戏中最大化函数值

问题描述：给定一个长度为N的数组和一个整数`k`，数组中的值表示`i`位置的玩家会把球传给下一个人的编号，玩家可以传球给自己，你需要选择一名玩家，开始传球，球会被传`k`次，如果选择编号为`x`的玩家作为开始玩家，函数`f(x)`表示从`x`玩家开始，`k`次传球内所有接触过球的玩家编号之和，如果某位玩家多次触球，则累加多次，返回所有玩家中`f(x)`的最大值

解法：构建一个ST表，表示第`i`号选手传`2^j`步之后球会到谁的手里，另外一个ST表是所有的编号之和。将`k`分解为出现`1`的二进制位的数组，在计算的时候只要累加所有这些编号，比较从每个点出发能得到的最大值即可

> 本题的最优解是基环树DP

### 检查树上两节点间的路径是否是回文

问题描述：一棵树上有N个节点，编号1~N，给定长度为N的数组`parent`，`parent[i]`表示节点`i`的父节点编号，给定长度为N的数组`s`，`s[i]`表示该点是什么字符，从节点`a`到节点`b`经过节点最少的路叫做`a`和`b`的路径，一共有M条查询，每条查询`a,b`表示判断`a`和`b`的路径字符串是否是回文。如果是打印“YES”，不是打印“NO”

解法：首先需要查出`a`和`b`的最低公共祖先节点，然后利用字符串哈希的方式，将从左到右路径和从右到左路径上的哈希值得到，通过对比两个哈希值是否相等来判断最短路径的字符串是否是回文。求哈希值的过程需要两个特殊的ST表，一张表是计算从某个点往上跳`2^p`步后得到的哈希值，另一张表是计算跳`2^p`步跳到某个点得到的哈希值，计算哈希值的过程总是从起始点跳到最低公共祖先的哈希值拼接上最低公共祖先另一侧的下一个节点到终点的哈希值。字符串哈希的计算过程是利用数值计算的自然溢出，需要选择一个质数参与计算

⚠️计算下坡的哈希值时利用一个高度变量来维护走的步数

## 树上问题专题3-树的重心

[code](./c/centroid-1.c)

[code](./c/centroid-2.c)

[code](./examples/98-cows-lg.rs)

[code](./examples/98-delete-edge-lg.rs)

树的重心有三种定义，通过三种方式求出来的重心点是同一个

- 以某个节点为根时，最大子树的节点数**最少**，那么这个节点就是重心
- 以某个节点为根时，每棵子树的节点数**不超过总节点数的一半**，那么这个节点是重心
- 以某个节点为根时，所有节点都走向该节点的**总边数最少**，那么这个节点是重心

补充性质

- 一棵树最多有两个重心，如果有两个重心，那么两个重心一定相邻
- 如果把树上增加或删除一个**叶节点**，转移后的重心最多移动一条边
- 如果把两棵树连起来，那么新树的重心一定在原来两棵树重心的路径上
- 树上的边权如果都为**正数**，不管边权怎么分布，所有节点都走向重心的总距离和最小

### 平衡行为

问题描述：一共有N个节点，编号1～N，有N-1条边形成的一棵树。返回重心点和最大子树的节点数，如果有多个重心，返回编号更小的那个

解法：使用树的重心的第一种定义，求所有节点的子树节点的最大值，其中的最小值对应的就是重心

### 教父

问题描述：一共有N个节点，编号1～N，有N-1条边形成一棵树，返回所有重心点

解法：使用树的重心的第二种定义，每个节点作为根节点时，它所有的子树的节点数量都不能超过总数的一半，如果符合条件就是重心。同样只需要求每个节点作为根节点时的最大子树节点数量，最后判断此节点即可

### 牛群聚集

问题描述：一共有N个节点，每个点有牛的数量，一共有N-1条边把所有点连通为一棵树，每条边有权值，想把所有牛汇聚到一点，希望走过的总距离最小，返回总距离最小是多少

解法：利用树的重心的性质，只要边权大于等于0，无论如果分布，所有点到重心的距离之和一定最小。本题中点本身也有值，在求重心的时候需要将每个点的权值计算为该点的统计值，判断依据和重心相同，每棵子树的数量映射为统计值，然后从重心开始计算与其它所有点的距离，最后每个点的距离乘上该点牛的数量累加即可

### 删增边使其重心唯一

问题描述：一共有N个节点，编号为1～N，有N-1条边形成一棵树。现在希望重心只有一个，调整方式是先删除一条边，再增加一条边。如果树上只有一个重心，删掉连接重心的任意一条边，再把这条边加上。如果树上有两个重心，调整的方式是先删除一条边，再增加一条边，如果方案有多种，打印其中一种即可

解法：根据重心的定义，如果有两个重心，它们的最大子树就是各自为父节点所在的子树，只需要在一个重心的最大子树中删掉一个子节点，然后将这个节点新增到另一个重心上作为新的子树即可满足题目要求
